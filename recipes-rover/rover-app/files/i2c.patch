diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2555eee..c7e0e25 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -13,7 +13,6 @@ project (roverapp)
 #For find_package packages, export someextlib_DIR=/path/to/..
 
 # Required packages
-find_package (OpenCV REQUIRED)
 #find_package (raspicam REQUIRED)
 find_package (Threads)
 
@@ -34,7 +33,6 @@ include_directories (${CMAKE_SOURCE_DIR}/include)
 include_directories (${CMAKE_SOURCE_DIR}/include/drivers/oled_drivers)
 
 #Include directories for external libraries
-include_directories( ${OpenCV_INCLUDE_DIRS} )
 #include_directories( ${jsoncpp_INCLUDE_DIRS} )
 #include_directories( ${bluetooth_INCLUDE_DIRS} )
 
@@ -86,9 +84,6 @@ add_executable(roverapp ${CMAKE_SOURCE_DIR}/src/roverapp.cpp)
 #Link external libraries
 # Search with sudo find / -name *libx*
 # If there is an x.so, you can link x library
-target_link_libraries (roverapptasks opencv_core)
-target_link_libraries (roverapptasks opencv_imgproc)
-target_link_libraries (roverapptasks opencv_highgui)
 target_link_libraries (roverapptasks jsoncpp)
 target_link_libraries (roverapptasks bluetooth)
 target_link_libraries (roverapptasks pthread)
diff --git a/include/tasks/image_processing_task.h b/include/tasks/image_processing_task.h
deleted file mode 100644
index f71e3d6..0000000
--- a/include/tasks/image_processing_task.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (c) 2017 FH Dortmund and others
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Description:
- *    Image processing task that is used for basic traffic cone detection
- *    Using OpenCV 2.4.9
- *    Header file
- *
- * Contributors:
- *    M.Ozcelikors <mozcelikors@gmail.com>, libraries compiled for cross compilation 16.10.2017
- *    M.Ozcelikors <mozcelikors@gmail.com>, demonstrator image processing task added, 19.10.2017
- *
- * Usage Instructions:
- *    1) To cross compile OpenCV, make sure you install OpenCV in your Raspberry Pi
- *    2) Then find opencv shared objects using the following command
- *    		find / -name libopencv*.so
- *    		find / -name libopencv*.so*
- *    3) Copy all of the found .so files to your C:\SysGCC\Raspberry\arm-linux-gnueabihf\sysroot\lib\arm-linux-gnueabihf (on Windows)
- *    4) Be sure to use following Linker flags: (adjust the path to your system):
- *    		-Wl,-verbose,-rpath-link,"C:\SysGCC\Raspberry\arm-linux-gnueabihf\sysroot\lib\arm-linux-gnueabihf"
- *    5) Be sure to add the libraries you are using to the linker using -l:
- *			such as ... -lopencv_core -lopencv_ml -lopencv_imgproc
- *	  6) Be sure to include the library search paths using -L:
- *	        -L"C:\SysGCC\Raspberry\arm-linux-gnueabihf\sysroot\lib\arm-linux-gnueabihf"
- *	  7) Be sure to include OpenCV include directories in gcc using -I flag.
- *
- */
-
-#ifndef TASKS_IMAGE_PROCESSING_TASK_H_
-#define TASKS_IMAGE_PROCESSING_TASK_H_
-
-/* Interfaces */
-void *Image_Processing_Task (void *arg);
-
-
-
-#endif /* TASKS_IMAGE_PROCESSING_TASK_H_ */
diff --git a/src/drivers/oled_drivers/bcm2835.c b/src/drivers/oled_drivers/bcm2835.c
index 697f677..5f3ad60 100644
--- a/src/drivers/oled_drivers/bcm2835.c
+++ b/src/drivers/oled_drivers/bcm2835.c
@@ -7,7 +7,7 @@
 // Author: Mike McCauley
 // Copyright (C) 2011-2013 Mike McCauley
 // $Id: bcm2835.c,v 1.10 2013/03/18 05:57:36 mikem Exp mikem $
-// 
+//
 // 03/17/2013 : Charles-Henri Hallard (http://hallard.me)
 //              Modified Adding some fonctionnalities
 //							Added millis() function
@@ -19,7 +19,7 @@
 
 
 #include "bcm2835.h"
-#include <linux/i2c-dev.h> 
+#include <linux/i2c-dev-user.h> 
 #include <stdio.h>
 #include <stdlib.h>
 #include <fcntl.h>
@@ -76,13 +76,13 @@ void  bcm2835_set_debug(uint8_t d)
 
 
 // Get raspberry PI model version
-int bcm2835_get_pi_version( void ) 
-{ 
+int bcm2835_get_pi_version( void )
+{
 	int rev = 0;
 	char buff[512];
 	char * p;
 	char * pend;
-	
+
 	FILE * fd ;
 
 	// do some clean up
@@ -94,12 +94,12 @@ int bcm2835_get_pi_version( void )
 	if( fd )
 	{
 		//printf("File opened successfully through fopen()\n");
-		
+
 		// parse each line until we the end or we find the good one
-		while( fgets(buff, sizeof(buff), fd) != NULL && rev ==0 ) 
+		while( fgets(buff, sizeof(buff), fd) != NULL && rev ==0 )
 		{
-			// search 
-			if( (strstr(buff, "Revision" )) != NULL )  
+			// search
+			if( (strstr(buff, "Revision" )) != NULL )
 			{
 				// point to the separator ":" format is has follow
 				// Revision        : 000f
@@ -111,12 +111,12 @@ int bcm2835_get_pi_version( void )
 						// Revision Version is in hex format so put 0x before the number
 						*p   = 'x';
 						*--p = '0';
-						
+
 						// convert to number
 						rev = strtol(p, &pend, 16);
-						
+
 						//printf("rev=%d 0x%04x\n", rev, rev);
-						
+
 						// not Okay ?
 						if ( !*pend )
 						{
@@ -133,14 +133,14 @@ int bcm2835_get_pi_version( void )
 		}
 
 		// Close the file.
-		if(fd) 
+		if(fd)
 		{
 			fclose(fd);
 		}
 	}
 
 	return rev;
-} 
+}
 
 
 
@@ -437,7 +437,7 @@ void bcm2835_gpio_set_pad(uint8_t group, uint32_t control)
 void bcm2835_delay(unsigned int millis)
 {
     struct timespec sleeper;
-    
+
     sleeper.tv_sec  = (time_t)(millis / 1000);
     sleeper.tv_nsec = (long)(millis % 1000) * 1000000;
     nanosleep(&sleeper, NULL);
@@ -448,18 +448,18 @@ void bcm2835_delayMicroseconds(uint64_t micros)
 {
     struct timespec t1;
     uint64_t        start;
-	
+
     // Calling nanosleep() takes at least 100-200 us, so use it for
     // long waits and use a busy wait on the System Timer for the rest.
     start =  bcm2835_st_read();
-    
+
     if (micros > 450)
     {
 	t1.tv_sec = 0;
 	t1.tv_nsec = 1000 * (long)(micros - 200);
 	nanosleep(&t1, NULL);
-    }    
-  
+    }
+
     bcm2835_st_delay(start, micros);
 }
 
@@ -467,12 +467,12 @@ void bcm2835_delayMicroseconds(uint64_t micros)
 unsigned int bcm2835_millis(void)
 {
 	struct timeval now;
-	unsigned long long ms;    
-	
+	unsigned long long ms;
+
 	gettimeofday(&now, NULL);
-	
+
 	ms = (now.tv_sec * 1000000 + now.tv_usec) / 1000 ;
-	
+
 	return ((uint32_t) (ms - epoch ));
 }
 
@@ -537,11 +537,11 @@ void bcm2835_spi_begin(uint8_t cs)
     volatile uint32_t* paddr = bcm2835_spi0 + BCM2835_SPI0_CS/4;
 
     // Set the SPI0 pins to the Alt 0 function to enable SPI0 access on them
-		// except if we need custom Chip Select Pin 
+		// except if we need custom Chip Select Pin
 		// printf("bcm2835_spi_begin -> spi_custom_cs = %d \n",cs );
-		
-		// Do we need custom chip select control or 
-		// drive CE1 manually (because CE1 does not work with hardware) 
+
+		// Do we need custom chip select control or
+		// drive CE1 manually (because CE1 does not work with hardware)
 		if ( cs > BCM2835_SPI_CS_NONE || cs == BCM2835_SPI_CS1 )
 		{
 			// indicate we will use a custom GPIO port
@@ -552,9 +552,9 @@ void bcm2835_spi_begin(uint8_t cs)
 			{
 				// Dirty Hack CE1 in now custom Chip Select GPIO 26
 				// the real CE1 pin
-				spi_custom_cs = RPI_GPIO_P1_26 ; 
-				
-				bcm2835_gpio_fsel(spi_custom_cs, BCM2835_GPIO_FSEL_OUTP); 
+				spi_custom_cs = RPI_GPIO_P1_26 ;
+
+				bcm2835_gpio_fsel(spi_custom_cs, BCM2835_GPIO_FSEL_OUTP);
 				bcm2835_gpio_write(spi_custom_cs, HIGH);
 			}
 
@@ -566,17 +566,17 @@ void bcm2835_spi_begin(uint8_t cs)
 		{
 			// Just in case
 			spi_custom_cs = 0 ;
-			
+
 			// Mask in the CS bits of CS
 			bcm2835_peri_set_bits(paddr, cs, BCM2835_SPI0_CS_CS);
-		}		
-		
-		// Now we can drive the I/O as asked 
+		}
+
+		// Now we can drive the I/O as asked
 		if (spi_custom_cs == 0)
 		{
 			// Not custom CS, so hardware driven
-			bcm2835_gpio_fsel(RPI_GPIO_P1_24, BCM2835_GPIO_FSEL_ALT0); // CE0 
-			bcm2835_gpio_fsel(RPI_GPIO_P1_26, BCM2835_GPIO_FSEL_ALT0); // CE1 
+			bcm2835_gpio_fsel(RPI_GPIO_P1_24, BCM2835_GPIO_FSEL_ALT0); // CE0
+			bcm2835_gpio_fsel(RPI_GPIO_P1_26, BCM2835_GPIO_FSEL_ALT0); // CE1
 		}
 		else
 		{
@@ -584,21 +584,21 @@ void bcm2835_spi_begin(uint8_t cs)
 			bcm2835_gpio_fsel(spi_custom_cs, BCM2835_GPIO_FSEL_OUTP); // Custom GPIO
 			bcm2835_gpio_write(spi_custom_cs, HIGH);
 		}
-		
+
 		// Classic pin, hardware driven
     bcm2835_gpio_fsel(RPI_GPIO_P1_21, BCM2835_GPIO_FSEL_ALT0); // MISO
     bcm2835_gpio_fsel(RPI_GPIO_P1_19, BCM2835_GPIO_FSEL_ALT0); // MOSI
     bcm2835_gpio_fsel(RPI_GPIO_P1_23, BCM2835_GPIO_FSEL_ALT0); // CLK
-    
+
     // Set the SPI CS register to the some sensible defaults
     bcm2835_peri_write(paddr, 0); // All 0s
-    
+
     // Clear TX and RX fifos
     bcm2835_peri_write_nb(paddr, BCM2835_SPI0_CS_CLEAR);
 }
 
 void bcm2835_spi_end(void)
-{  
+{
     // Set all the SPI0 pins back to input
 		if (spi_custom_cs == 0)
 		{
@@ -662,7 +662,7 @@ uint8_t bcm2835_spi_transfer(uint8_t value)
 
     // This is Polled transfer as per section 10.6.1
     // BUG ALERT: what happens if we get interupted in this section, and someone else
-    // accesses a different peripheral? 
+    // accesses a different peripheral?
     // Clear TX and RX fifos
     bcm2835_peri_set_bits(paddr, BCM2835_SPI0_CS_CLEAR, BCM2835_SPI0_CS_CLEAR);
 
@@ -703,7 +703,7 @@ void bcm2835_spi_transfernb(char* tbuf, char* rbuf, uint32_t len)
 
     // This is Polled transfer as per section 10.6.1
     // BUG ALERT: what happens if we get interupted in this section, and someone else
-    // accesses a different peripheral? 
+    // accesses a different peripheral?
 
     // Clear TX and RX fifos
     bcm2835_peri_set_bits(paddr, BCM2835_SPI0_CS_CLEAR, BCM2835_SPI0_CS_CLEAR);
@@ -737,7 +737,7 @@ void bcm2835_spi_transfernb(char* tbuf, char* rbuf, uint32_t len)
 
 		// Custom chip select HIGH
 		bcm2835_spi_setChipSelect(HIGH);
-	
+
 }
 
 // Writes an number of bytes to SPI
@@ -802,7 +802,7 @@ void bcm2835_spi_setChipSelectPolarity(uint8_t cs, uint8_t active)
 		if (cs <= BCM2835_SPI_CS_NONE)
 		{
 			uint8_t shift = 21 + cs;
-			
+
 			// Mask in the appropriate CSPOLn bit
 			bcm2835_peri_set_bits(paddr, active << shift, 1 << shift);
 		}
@@ -814,15 +814,15 @@ int bcm2835_i2c_begin(void)
 
 	if ((fd = open (bcm2835_get_pi_version() == 1 ? "/dev/i2c-0":"/dev/i2c-1" , O_RDWR)) < 0)
 		return fd;
-		
+
 	// Set i2c descriptor
 	i2c_fd = fd;
 
 	return i2c_fd ;
-		
+
 }
 
-void bcm2835_i2c_end(void) 
+void bcm2835_i2c_end(void)
 {
 	// close i2c bus
 	if ( i2c_fd )
@@ -839,19 +839,19 @@ int bcm2835_i2c_setSlaveAddress(uint8_t addr)
 
 	// Set I2C Device Address
 	return (ioctl (i2c_fd, I2C_SLAVE, addr) );
-			
+
 }
 
 // set I2C clock divider by means of a baudrate number
 void bcm2835_i2c_set_baudrate(uint32_t baudrate)
 {
   volatile uint32_t* paddr = bcm2835_bsc1 + BCM2835_BSC_DIV/4;
-	
+
 	uint32_t divider;
-	
+
 	// use 0xFFFE mask to limit a max value and round down any odd number
 	divider = (BCM2835_CORE_CLK_HZ / baudrate) & 0xFFFE;
-	
+
   bcm2835_peri_write(paddr, divider);
 }
 
@@ -859,7 +859,7 @@ void bcm2835_i2c_set_baudrate(uint32_t baudrate)
 int bcm2835_i2c_write(const char * buf, uint32_t len)
 {
 	int reason = -1	;
-	
+
 	if (!i2c_fd)
 		return (-1);
 
@@ -871,9 +871,9 @@ int bcm2835_i2c_write(const char * buf, uint32_t len)
 	else if (len == 3)
 		reason = i2c_smbus_write_word_data(i2c_fd, buf[0], (buf[2]<<8) | buf[1] );
 	// Write bulk data
-	else 
+	else
 		reason = i2c_smbus_write_i2c_block_data(i2c_fd, buf[0], len-1, (const __u8 *) &buf[1]);
-		
+
 	usleep(1);
 
 	return ( reason );
@@ -941,8 +941,8 @@ static void unmapmem(void **pmem, size_t size)
 int bcm2835_init(void)
 {
 	struct timeval tv ;
-	
-    if (debug) 
+
+    if (debug)
     {
 	bcm2835_pads = (uint32_t*)BCM2835_GPIO_PADS;
 	bcm2835_clk = (uint32_t*)BCM2835_CLOCK_BASE;
@@ -957,13 +957,13 @@ int bcm2835_init(void)
     int memfd = -1;
     int ok = 0;
     // Open the master /dev/memory device
-    if ((memfd = open("/dev/mem", O_RDWR | O_SYNC) ) < 0) 
+    if ((memfd = open("/dev/mem", O_RDWR | O_SYNC) ) < 0)
     {
 	fprintf(stderr, "bcm2835_init: Unable to open /dev/mem: %s\n",
 		strerror(errno)) ;
 	goto exit;
     }
-	
+
     // GPIO:
     bcm2835_gpio = mapmem("gpio", BCM2835_BLOCK_SIZE, memfd, BCM2835_GPIO_BASE);
     if (bcm2835_gpio == MAP_FAILED) goto exit;
@@ -975,10 +975,10 @@ int bcm2835_init(void)
     // Clock control (needed for PWM)
     bcm2835_clk = mapmem("clk", BCM2835_BLOCK_SIZE, memfd, BCM2835_CLOCK_BASE);
     if (bcm2835_clk == MAP_FAILED) goto exit;
-    
+
     bcm2835_pads = mapmem("pads", BCM2835_BLOCK_SIZE, memfd, BCM2835_GPIO_PADS);
     if (bcm2835_pads == MAP_FAILED) goto exit;
-    
+
     bcm2835_spi0 = mapmem("spi0", BCM2835_BLOCK_SIZE, memfd, BCM2835_SPI0_BASE);
     if (bcm2835_spi0 == MAP_FAILED) goto exit;
 
@@ -1001,7 +1001,7 @@ exit:
 
     if (!ok)
 	bcm2835_close();
-	
+
   gettimeofday (&tv, NULL) ;
 	epoch = (tv.tv_sec * 1000000 + tv.tv_usec) / 1000 ;
 
@@ -1020,4 +1020,4 @@ int bcm2835_close(void)
     unmapmem((void**) &bcm2835_bsc1, BCM2835_BLOCK_SIZE);
     unmapmem((void**) &bcm2835_st,   BCM2835_BLOCK_SIZE);
     return 1; // Success
-}    
+}
diff --git a/src/roverapp.cpp b/src/roverapp.cpp
index 2a01cef..1b8cc1e 100644
--- a/src/roverapp.cpp
+++ b/src/roverapp.cpp
@@ -46,7 +46,6 @@
 #include <tasks/srf02_task.h>
 #include <tasks/bluetooth_task.h>
 #include <tasks/external_gpio_task.h>
-#include <tasks/image_processing_task.h>
 #include <tasks/booth_modes_task.h>
 #include <tasks/socket_client_task.h>
 #include <tasks/socket_server_task.h>
diff --git a/src/tasks/image_processing_task.cpp b/src/tasks/image_processing_task.cpp
deleted file mode 100644
index 0ad85da..0000000
--- a/src/tasks/image_processing_task.cpp
+++ /dev/null
@@ -1,363 +0,0 @@
-/*
- * Copyright (c) 2017 FH Dortmund and others
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Description:
- *    Image processing task that is used for basic traffic cone detection
- *    Using OpenCV 2.4.9
- *
- * Contributors:
- *    M.Ozcelikors <mozcelikors@gmail.com>, libraries compiled for cross compilation 16.10.2017
- *    M.Ozcelikors <mozcelikors@gmail.com>, demonstrator image processing task added, 19.10.2017
- *
- *
- * Usage Instructions:
- *    1) To cross compile OpenCV, make sure you install OpenCV in your Raspberry Pi
- *    2) Then find opencv shared objects using the following command
- *    		find / -name libopencv*.so
- *    		find / -name libopencv*.so*
- *    3) Copy all of the found .so files to your C:\SysGCC\Raspberry\arm-linux-gnueabihf\sysroot\lib\arm-linux-gnueabihf (on Windows)
- *    4) Be sure to use following Linker flags: (adjust the path to your system):
- *    		-Wl,-verbose,-rpath-link,"C:\SysGCC\Raspberry\arm-linux-gnueabihf\sysroot\lib\arm-linux-gnueabihf"
- *    5) Be sure to add the libraries you are using to the linker using -l:
- *			such as ... -lopencv_core -lopencv_ml -lopencv_imgproc
- *	  6) Be sure to include the library search paths using -L:
- *	        -L"C:\SysGCC\Raspberry\arm-linux-gnueabihf\sysroot\lib\arm-linux-gnueabihf"
- *	  7) Be sure to include OpenCV and raspicam libraries below to `include directories` in gcc using -I flag.
- *
- *	  IMPORTANT!: For this task to run, camera stream or any other processes that use the raspberry pi camera should be deactivated!
- *
- */
-
-#include <tasks/image_processing_task.h>
-
-#include <ctime>
-#include <wiringPi.h>
-#include <unistd.h>
-#include <libraries/timing/timing.h>
-#include <api/basic_psys_rover.h>
-#include <interfaces.h>
-#include <pthread.h>
-
-#include <libraries/pthread_monitoring/collect_thread_name.h>
-#include <roverapp.h>
-
-#include <iostream>
-#include <fstream>
-
-/* OpenCV 2.4.9 libraries, Includes (-I) are in /workspace, include paths are specified for "g++"!! */
-#include <opencv2/highgui/highgui.hpp>
-#include <opencv2/core/core.hpp>
-#include <opencv2/imgproc/imgproc.hpp>
-#include <opencv2/opencv.hpp>
-
-/* raspicam-0.1.3 libraries, Includes (-I) are in /workspace, include paths are specified for "g++"!! */
-//#include <raspicam.h>
-//#include <raspicam_cv.h>
-
-using namespace cv;
-using namespace std;
-
-void *Image_Processing_Task(void *arg)
-{
-	timing imgproc_task_tmr;
-
-	CollectThreadName("Image_Processing_Task");
-
-	imgproc_task_tmr.setTaskID("ImgPr");
-	imgproc_task_tmr.setDeadline(1);
-	imgproc_task_tmr.setPeriod(1);
-	/*
-	char key;
-	char* output_window_name = "Camera Output";
-	char* grayscale_window_name = "Grayscale Image";
-	char* thresholded_window_name = "Thresholded Image";
-	char* contours_window_name = "Contours Image";
-
-	int first_time_cmp = 1;
-
-	int canny_lowthreshold = 20;
-	int canny_highthreshold = 50;
-	int width_bound = 16;//5
-	int height_bound = 16;//5
-	int solidity_bound = 9;
-	int max_val = 200;
-	int float_max_val = 30;
-	int color_max_val = 256;
-
-	//Orange
-	int u_h=0;//0;//0;//0;  //0
-	int u_s=177;//148;//102;//134;//120; //197
-	int u_v=178;//149;//220;//212;//120; //189
-	int d_h=203;//5;//256;//256; //9
-	int d_s=256;//256; //256
-	int d_v=256;//256; //256
-
-	int up_aspectRatio = 26;
-	int down_aspectRatio = 15;
-	int aspect_max_val = 50;
-	RNG rng(12345);
-
-	int detections_w[10];
-	int detections_h[10];
-	int detections_x[10];
-	int detections_y[10];
-	double  detections_wh[10];
-	int detection_count = 0;
-
-	int send_flag = 0;
-
-	namedWindow(output_window_name, CV_WINDOW_AUTOSIZE);
-	namedWindow(grayscale_window_name, 100);
-	namedWindow(thresholded_window_name, 100);
-	namedWindow(contours_window_name, 100);
-
-	moveWindow(grayscale_window_name, 20,20);
-	moveWindow(thresholded_window_name, 20, 250);
-	moveWindow(contours_window_name, 20, 600);
-
-
-	vector<int> compression_params;
-	compression_params.push_back(CV_IMWRITE_JPEG_QUALITY);
-	compression_params.push_back(100);
-
-	raspicam::RaspiCam_Cv Camera;
-	//Camera.set (CV_CAP_PROP_FORMAT, CV_8UC3);//CV_BGR2HSV); // Original format in Raspicam -> CV_8UC1);
-	if (!Camera.open()){
-		printf("Camera failed to open!\n");
-		abort();
-	}
-
-	Mat frame;
-	Mat frameRGB;
-	Mat imgGrayScale;
-	Mat imgHsv;
-	Mat imgRedThresh;
-	Mat imgWhiteThresh;
-	Mat imgResultingThresh;
-	Mat edges;
-	vector< vector<Point> > contours;
-	vector< Vec4i > hierarchy;
-	vector<Point> approx;
-	vector<Point> tempCont;
-	vector<vector<Point> > tempVecCont;
-	double contPeri;
-	Rect bBox;
-	double aspectRatio;
-
-	double area;
-	double hullArea;
-	double solidity;
-
-	int opening_length;
-	int opening_midpoint;
-
-	double maximum ;
-	double second_maximum ;
-	double third_maximum;
-	int maximum_idx ;
-	int second_maximum_idx ;
-	int third_maximum_idx;
-	double second_last_maximum;
-	double last_maximum;
-
-	int counter = 0;
-	int counter_max = 1;
-	//createTrackbar("canny low Threshold: ", output_window_name, &canny_lowthreshold, max_val, canny);
-	//createTrackbar("canny high Threshold: ", output_window_name, &canny_highthreshold, max_val, canny);
-	//createTrackbar("height: ", output_window_name, &height_bound, float_max_val, canny);
-	//createTrackbar("width: ", output_window_name, &width_bound, float_max_val, canny);
-	//createTrackbar("solidity: ", output_window_name, &solidity_bound, float_max_val, canny);
-	//createTrackbar("Up AspectRatio: ", output_window_name, &up_aspectRatio, aspect_max_val, canny);
-	//createTrackbar("Down AspectRatio: ", output_window_name, &down_aspectRatio, aspect_max_val, canny);
-	//createTrackbar("Up H: ", output_window_name, &u_h, color_max_val, canny);
-	//createTrackbar("Up S: ", output_window_name, &u_s, color_max_val, canny);
-	//createTrackbar("Up v: ", output_window_name, &u_v, color_max_val, canny);
-	//createTrackbar("Down H: ", output_window_name, &d_h, color_max_val, canny);
-	//createTrackbar("Down S: ", output_window_name, &d_s, color_max_val, canny);
-	//createTrackbar("Down v: ", output_window_name, &d_v, color_max_val, canny);
-*/
-
-	while (1)
-	{
-		imgproc_task_tmr.recordStartTime();
-		imgproc_task_tmr.calculatePreviousSlackTime();
-
-		//Task content starts here -----------------------------------------------
-/*
-		//Capture image with Raspicam_CV
-		Camera.grab();
-		Camera.retrieve(frame);  //cap >> frame
-
-		//cv::imwrite("raspicam_img.jpg", frame);
-
-		//printf("Starting...\n");
-		//key = waitKey(10);
-		//cout <<(int) char(key) << endl;
-		//if(char(key) == 27){
-		//    break;
-		//}
-		// if(char(key) == 10){
-
-		frameRGB.create(frame.size(), frame.type());
-		cvtColor(frame, frameRGB, CV_BGR2RGB);
-
-		imgHsv.create(frameRGB.size(), frameRGB.type());
-		cvtColor(frameRGB, imgHsv, CV_RGB2HSV);//HSV
-
-		//cv::imwrite("raspicam_img.jpg", imgHsv);
-
-		inRange(imgHsv, Scalar(u_h, u_s, u_v), Scalar(d_h, d_s, d_v), imgRedThresh);
-
-		//converting the original image into grayscale
-		imgGrayScale.create(frame.size(), frame.type());
-		cvtColor(frame, imgGrayScale, CV_BGR2GRAY);
-		bitwise_and(imgRedThresh, imgGrayScale, imgGrayScale);
-
-		// Floodfill from point (0, 0)
-		Mat im_floodfill = imgGrayScale.clone();
-		floodFill(im_floodfill, cv::Point(0,0), Scalar(255));
-
-		// Invert floodfilled image
-		Mat im_floodfill_inv;
-		bitwise_not(im_floodfill, im_floodfill_inv);
-
-		// Combine the two images to get the foreground.
-		imgGrayScale = (imgGrayScale | im_floodfill_inv);
-
-		GaussianBlur(imgGrayScale, imgGrayScale, Size(7,7), 1.5, 1.5);
-
-		//imshow(grayscale_window_name, imgGrayScale);
-
-		edges.create(imgGrayScale.size(), imgGrayScale.type());
-		Canny(imgGrayScale, edges, canny_lowthreshold, canny_highthreshold, 3);
-
-		findContours(edges, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0,0));
-		Mat drawing = Mat::zeros(edges.size(), CV_8UC3);
-
-		//For all contours
-		for(int i=0 ; i<contours.size() ; i++){
-			contPeri = arcLength(contours.at(i), true);
-			approxPolyDP(contours.at(i), approx,  0.01 * contPeri, true);
-
-			//if(approx.size()>=7 && approx.size()<=9){
-			bBox = boundingRect(approx);
-			aspectRatio = bBox.width/bBox.height;
-
-			area = contourArea(contours.at(i));
-			convexHull(contours.at(i), tempCont);
-			hullArea = contourArea(tempCont);
-			solidity = area / hullArea;
-
-			// cout << "contour : " << approx.size() << endl;
-			// cout << bBox.width << "::" << bBox.height << "::" << solidity  << "::" << aspectRatio <<endl;
-
-			tempVecCont.clear();
-			tempVecCont.push_back(approx);
-
-			if(bBox.width > width_bound && bBox.height > height_bound && solidity > solidity_bound/10 )
-			{
-				//Find detections
-				//printf("%d\t%d\n",bBox.width, bBox.height);
-				detections_x[detection_count] = bBox.x;
-				detections_y[detection_count] = bBox.y;
-				detections_w[detection_count] = bBox.width;
-				detections_h[detection_count] = bBox.height;
-				detections_wh[detection_count] = bBox.width*bBox.height;
-				detection_count = detection_count + 1;
-
-				//Scalar color = Scalar(rng.uniform(0,255), rng.uniform(0,255), rng.uniform(0,255));
-				//drawContours(drawing, tempVecCont, 0, color, 2, 8, hierarchy, 0, Point());
-				//rectangle( drawing, Point( bBox.x, bBox.y), Point( bBox.x+bBox.width, bBox.y+bBox.height), Scalar( 0, 55, 255 ), +4, 4 );
-			}
-			//}
-
-		}
-		//First we shall select the biggest two boxes, having biggest w x h.
-		maximum = detections_wh[0];
-		second_maximum = detections_wh[0];
-		third_maximum = detections_wh[0];
-		maximum_idx = 0;
-		second_maximum_idx = 0;
-		third_maximum_idx = 0;
-		int c;
-		for (c = 0; c < detection_count; c++)
-		{
-			if (detections_wh[c] > maximum)
-			{
-				third_maximum = second_maximum;
-				third_maximum_idx = second_maximum_idx;
-				second_maximum = maximum;
-				second_maximum_idx = maximum_idx;
-				maximum  = detections_wh[c];
-				maximum_idx = c;
-			}
-		}
-
-		if(maximum > 10000 || second_maximum > 10000 || third_maximum > 10000) //was 3000
-		{
-			send_flag = 1;
-			//Clear detection width*height array after command is sent
-			for (c = 0; c<detection_count; c++)
-			{
-				detections_wh[c] = 0;
-			}
-		}
-		else
-		{
-			ofstream myfile;
-			myfile.open("../../logs/image_processing/detection.inc");
-			myfile << "undetected";
-			myfile.close();
-		}
-		second_last_maximum = second_maximum;
-		last_maximum = maximum;
-
-
-		if(send_flag == 1){
-
-			printf("CONTOUR DETECTED\n");
-			counter = 0;
-			send_flag = 0;
-		}
-
-
-
-		counter++;
-		*/
-
-		//Task content ends here -------------------------------------------------
-
-		imgproc_task_tmr.recordEndTime();
-		imgproc_task_tmr.calculateExecutionTime();
-		imgproc_task_tmr.calculateDeadlineMissPercentage();
-		imgproc_task_tmr.incrementTotalCycles();
-		pthread_mutex_lock(&imgproc_task_ti_l);
-			imgproc_task_ti.deadline = imgproc_task_tmr.getDeadline();
-			imgproc_task_ti.deadline_miss_percentage = imgproc_task_tmr.getDeadlineMissPercentage();
-			imgproc_task_ti.execution_time = imgproc_task_tmr.getExecutionTime();
-			imgproc_task_ti.period = imgproc_task_tmr.getPeriod();
-			imgproc_task_ti.prev_slack_time = imgproc_task_tmr.getPrevSlackTime();
-			imgproc_task_ti.task_id = imgproc_task_tmr.getTaskID();
-			imgproc_task_ti.start_time = imgproc_task_tmr.getStartTime();
-			imgproc_task_ti.end_time = imgproc_task_tmr.getEndTime();
-		pthread_mutex_unlock(&imgproc_task_ti_l);
-		imgproc_task_tmr.sleepToMatchPeriod();
-	}
-
-	// Destroy the screens
-	/*destroyWindow(output_window_name);
-	destroyWindow(thresholded_window_name);
-	destroyWindow(grayscale_window_name);
-	destroyWindow(contours_window_name);*/
-
-	//Close raspicam
-	//cap.release(); --> In webcam
-	/*Camera.release();*/
-
-	/* the function must return something - NULL will do */
-	return NULL;
-}
