diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/CMakeLists.txt b/mjpg-streamer-experimental/plugins/input_raspicam/CMakeLists.txt
index 4d91ea5..2ad3517 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/CMakeLists.txt
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/CMakeLists.txt
@@ -1,17 +1,15 @@
 cmake_minimum_required(VERSION 2.8)
 
-SET(COMPILE_DEFINITIONS -Werror)
-
 include_directories(/opt/vc/include)
 include_directories(/opt/vc/include/interface/vcos)
 include_directories(/opt/vc/include/interface/vcos/pthreads)
 include_directories(/opt/vc/include/interface/vmcs_host)
 include_directories(/opt/vc/include/interface/vmcs_host/linux)
 
-set(CMAKE_C_FLAGS "-DDEBUG")
-
 link_directories(/opt/vc/lib)
 
 add_library(input_raspicam SHARED input_raspicam.c)
 
 target_link_libraries(input_raspicam mmal_core mmal_util mmal_vc_client vcos bcm_host)
+
+install(TARGETS input_raspicam LIBRARY DESTINATION /usr/lib)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.c b/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.c
index adca7f3..c9d1d1a 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/RaspiCamControl.c
@@ -29,14 +29,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <stdio.h>
 #include <memory.h>
 
-#include "interface/vcos/vcos.h"
-
-#include "interface/vmcs_host/vc_vchi_gencmd.h"
-#include "mmal/mmal.h"
-//#include "mmal/mmal_logging.h"
-//#include "mmal/util/mmal_util.h"
-//#include "mmal/util/mmal_util_params.h"
-#include "mmal/util/mmal_default_components.h"
+#include <interface/vcos/vcos.h>
+
+#include <interface/vmcs_host/vc_vchi_gencmd.h>
+#include <interface/mmal/mmal.h>
+//#include <interface/mmal/mmal_logging.h>
+//#include <interface/mmal/util/mmal_util.h>
+//#include <interface/mmal/util/mmal_util_params.h>
+#include <interface/mmal/util/mmal_default_components.h>
 #include "RaspiCamControl.h"
 
 /// Cross reference structure, mode string against mode id
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/input_raspicam.c b/mjpg-streamer-experimental/plugins/input_raspicam/input_raspicam.c
index e069582..37414d0 100644
--- a/mjpg-streamer-experimental/plugins/input_raspicam/input_raspicam.c
+++ b/mjpg-streamer-experimental/plugins/input_raspicam/input_raspicam.c
@@ -41,12 +41,12 @@
 #include "../../mjpg_streamer.h"
 #include "../../utils.h"
 
-#include "bcm_host.h"
-#include "interface/vcos/vcos.h"
+#include <bcm_host.h>
+#include <interface/vcos/vcos.h>
 
-#include "mmal/mmal.h"
-#include "mmal/util/mmal_default_components.h"
-#include "mmal/util/mmal_connection.h"
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_connection.h>
 
 #include "RaspiCamControl.c"
 
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/CMakeLists.txt b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/CMakeLists.txt
deleted file mode 100644
index ae5889d..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/CMakeLists.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-
-add_definitions(-Wall -Werror)
-
-add_library(mmal SHARED util/mmal_util.c)
-
-add_subdirectory(core)
-add_subdirectory(util)
-add_subdirectory(vc)
-
-#add_subdirectory(test/lua)
-#add_subdirectory(test/standalone)
-
-if(BUILD_MMAL_APPS)
-add_subdirectory(components)
-target_link_libraries(mmal mmal_core mmal_util mmal_vc_client vcos mmal_components)
-else(BUILD_MMAL_APPS)
-target_link_libraries(mmal mmal_core mmal_util mmal_vc_client)
-endif(BUILD_MMAL_APPS)
-
-install(TARGETS mmal DESTINATION lib)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/CMakeLists.txt b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/CMakeLists.txt
deleted file mode 100644
index b5bae4c..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/CMakeLists.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-add_library (mmal_core SHARED
-   mmal_format.c
-   mmal_port.c
-   mmal_port_clock.c
-   mmal_component.c
-   mmal_buffer.c
-   mmal_queue.c
-   mmal_pool.c
-   mmal_events.c
-   mmal_logging.c
-   mmal_clock.c
-)
-
-target_link_libraries (mmal_core vcos)
-
-install(TARGETS mmal_core DESTINATION lib)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_buffer.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_buffer.c
deleted file mode 100644
index 3f83063..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_buffer.c
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "mmal_buffer.h"
-#include "core/mmal_buffer_private.h"
-#include "mmal_logging.h"
-
-#define ROUND_UP(s,align) ((((unsigned long)(s)) & ~((align)-1)) + (align))
-#define DEFAULT_COMMAND_SIZE 256 /**< 256 bytes of space for commands */
-#define ALIGN  8
-
-/** Acquire a buffer header */
-void mmal_buffer_header_acquire(MMAL_BUFFER_HEADER_T *header)
-{
-#ifdef ENABLE_MMAL_EXTRA_LOGGING
-   LOG_TRACE("%p (%i)", header, (int)header->priv->refcount+1);
-#endif
-   header->priv->refcount++;
-}
-
-/** Reset a buffer header */
-void mmal_buffer_header_reset(MMAL_BUFFER_HEADER_T *header)
-{
-   header->length = 0;
-   header->offset = 0;
-   header->flags = 0;
-   header->pts = MMAL_TIME_UNKNOWN;
-   header->dts = MMAL_TIME_UNKNOWN;
-}
-
-/** Release a buffer header */
-void mmal_buffer_header_release(MMAL_BUFFER_HEADER_T *header)
-{
-#ifdef ENABLE_MMAL_EXTRA_LOGGING
-   LOG_TRACE("%p (%i)", header, (int)header->priv->refcount-1);
-#endif
-
-   if(--header->priv->refcount != 0)
-      return;
-
-   if (header->priv->pf_pre_release)
-   {
-      if (header->priv->pf_pre_release(header, header->priv->pre_release_userdata))
-         return; /* delay releasing the buffer */
-   }
-   mmal_buffer_header_release_continue(header);
-}
-
-/** Finalise buffer release following a pre-release event */
-void mmal_buffer_header_release_continue(MMAL_BUFFER_HEADER_T *header)
-{
-   mmal_buffer_header_reset(header);
-   if (header->priv->reference)
-      mmal_buffer_header_release(header->priv->reference);
-   header->priv->reference = 0;
-   header->priv->pf_release(header);
-}
-
-/** Replicate a buffer header */
-MMAL_STATUS_T mmal_buffer_header_replicate(MMAL_BUFFER_HEADER_T *dest,
-   MMAL_BUFFER_HEADER_T *src)
-{
-#ifdef ENABLE_MMAL_EXTRA_LOGGING
-   LOG_TRACE("dest: %p src: %p", dest, src);
-#endif
-
-   if (!dest || !src || dest->priv->reference)
-      return MMAL_EINVAL;
-
-   mmal_buffer_header_acquire(src);
-   dest->priv->reference = src;
-
-   /* Copy all the relevant fields */
-   dest->cmd        = src->cmd;
-   dest->alloc_size = src->alloc_size;
-   dest->data       = src->data;
-   dest->offset     = src->offset;
-   dest->length     = src->length;
-   dest->flags      = src->flags;
-   dest->pts        = src->pts;
-   dest->dts        = src->dts;
-   *dest->type      = *src->type;
-   return MMAL_SUCCESS;
-}
-
-/** Get the size in bytes of a fully initialised MMAL_BUFFER_HEADER_T */
-unsigned int mmal_buffer_header_size(MMAL_BUFFER_HEADER_T *header)
-{
-   unsigned int header_size;
-
-   header_size = ROUND_UP(sizeof(*header), ALIGN);
-   header_size += ROUND_UP(sizeof(*header->type), ALIGN);
-   header_size += ROUND_UP(DEFAULT_COMMAND_SIZE, ALIGN);
-   header_size += ROUND_UP(sizeof(*header->priv), ALIGN);
-   return header_size;
-}
-
-/** Initialise a MMAL_BUFFER_HEADER_T */
-MMAL_BUFFER_HEADER_T *mmal_buffer_header_initialise(void *mem, unsigned int length)
-{
-   MMAL_BUFFER_HEADER_T *header;
-   unsigned int header_size = mmal_buffer_header_size(0);
-
-   if(length < header_size)
-      return 0;
-
-   memset(mem, 0, header_size);
-
-   header = (MMAL_BUFFER_HEADER_T *)mem;
-   header->type = (void *)&header[1];
-   header->priv = (MMAL_BUFFER_HEADER_PRIVATE_T *)&header->type[1];
-   return header;
-}
-
-/** Return a pointer to the area reserved for the driver */
-MMAL_DRIVER_BUFFER_T *mmal_buffer_header_driver_data(MMAL_BUFFER_HEADER_T *header)
-{
-   return (MMAL_DRIVER_BUFFER_T *)header->priv->driver_area;
-}
-
-/** Return a pointer to a referenced buffer header */
-MMAL_BUFFER_HEADER_T *mmal_buffer_header_reference(MMAL_BUFFER_HEADER_T *header)
-{
-   return header->priv->reference;
-}
-
-#ifdef __VIDEOCORE__
-# include "vcfw/rtos/common/rtos_common_mem.h"
-#endif
-
-/** Lock the data buffer contained in the buffer header */
-MMAL_STATUS_T mmal_buffer_header_mem_lock(MMAL_BUFFER_HEADER_T *header)
-{
-#ifdef __VIDEOCORE__
-   uint8_t *data = mem_lock((MEM_HANDLE_T)header->data);
-   if (!data)
-      return MMAL_EINVAL;
-   header->priv->payload_handle = (void *)header->data;
-   header->data = data;
-#else
-   MMAL_PARAM_UNUSED(header);
-#endif
-
-   return MMAL_SUCCESS;
-}
-
-/** Unlock the data buffer contained in the buffer header */
-void mmal_buffer_header_mem_unlock(MMAL_BUFFER_HEADER_T *header)
-{
-#ifdef __VIDEOCORE__
-   mem_unlock((MEM_HANDLE_T)header->priv->payload_handle);
-   header->data = header->priv->payload_handle;
-#else
-   MMAL_PARAM_UNUSED(header);
-#endif
-}
-
-/** Set a pre-release callback for a buffer header */
-void mmal_buffer_header_pre_release_cb_set(MMAL_BUFFER_HEADER_T *header, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata)
-{
-   header->priv->pf_pre_release = cb;
-   header->priv->pre_release_userdata = userdata;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_buffer_private.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_buffer_private.h
deleted file mode 100644
index d24be20..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_buffer_private.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_BUFFER_PRIVATE_H
-#define MMAL_BUFFER_PRIVATE_H
-
-/** Typedef for the private area the framework reserves for the driver / communication layer */
-typedef struct MMAL_DRIVER_BUFFER_T MMAL_DRIVER_BUFFER_T;
-
-/** Size of the private area the framework reserves for the driver / communication layer */
-#define MMAL_DRIVER_BUFFER_SIZE 32
-
-/** Typedef for the framework's private area in the buffer header */
-typedef struct MMAL_BUFFER_HEADER_PRIVATE_T
-{
-   /** Callback invoked just prior to actually releasing the buffer header. Returns TRUE if
-    * release should be delayed. */
-   MMAL_BH_PRE_RELEASE_CB_T pf_pre_release;
-   void *pre_release_userdata;
-
-   /** Callback used to release / recycle the buffer header. This needs to be set by
-    * whoever allocates the buffer header. */
-   void (*pf_release)(struct MMAL_BUFFER_HEADER_T *header);
-   void *owner;               /**< Context set by the allocator of the buffer header and passed
-                                   during the release callback */
-
-   int32_t refcount;          /**< Reference count of the buffer header. When it reaches 0,
-                                   the release callback will be called. */
-
-   MMAL_BUFFER_HEADER_T *reference; /**< Reference to another acquired buffer header. */
-
-   /** Callback used to free the payload associated with this buffer header. This is only
-    * used if the buffer header was created by MMAL with a payload associated with it. */
-   void   (*pf_payload_free)(void *payload_context, void *payload);
-   void    *payload;          /**< Pointer / handle to the allocated payload buffer */
-   void    *payload_context;  /**< Pointer to the context of the payload allocator */
-   uint32_t payload_size;     /**< Allocated size in bytes of payload buffer */
-
-   void *component_data;      /**< Field reserved for use by the component */
-   void *payload_handle;      /**< Field reserved for mmal_buffer_header_mem_lock */
-
-   uint8_t driver_area[MMAL_DRIVER_BUFFER_SIZE];
-
-} MMAL_BUFFER_HEADER_PRIVATE_T;
-
-/** Get the size in bytes of a fully initialised MMAL_BUFFER_HEADER_T */
-unsigned int mmal_buffer_header_size(MMAL_BUFFER_HEADER_T *header);
-
-/** Initialise a MMAL_BUFFER_HEADER_T */
-MMAL_BUFFER_HEADER_T *mmal_buffer_header_initialise(void *mem, unsigned int length);
-
-/** Return a pointer to the area reserved for the driver.
-  */
-MMAL_DRIVER_BUFFER_T *mmal_buffer_header_driver_data(MMAL_BUFFER_HEADER_T *);
-
-/** Return a pointer to a referenced buffer header.
- * It is the caller's responsibility to ensure that the reference is still
- * valid when using it.
- */
-MMAL_BUFFER_HEADER_T *mmal_buffer_header_reference(MMAL_BUFFER_HEADER_T *header);
-
-#endif /* MMAL_BUFFER_PRIVATE_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock.c
deleted file mode 100644
index 6f6c64f..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock.c
+++ /dev/null
@@ -1,845 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "interface/vcos/vcos.h"
-#include "interface/mmal/mmal_logging.h"
-#include "interface/mmal/util/mmal_list.h"
-#include "interface/mmal/util/mmal_util_rational.h"
-#include "interface/mmal/core/mmal_clock_private.h"
-
-#ifdef __VIDEOCORE__
-/* Use RTOS timer for improved accuracy */
-# include "vcfw/rtos/rtos.h"
-# define USE_RTOS_TIMER
-#endif
-
-
-/*****************************************************************************/
-#ifdef USE_RTOS_TIMER
-# define MIN_TIMER_DELAY  1     /* microseconds */
-#else
-# define MIN_TIMER_DELAY  10000 /* microseconds */
-#endif
-
-/* 1.0 in Q16 format */
-#define Q16_ONE  (1 << 16)
-
-/* Maximum number of pending requests */
-#define CLOCK_REQUEST_SLOTS  32
-
-/* Number of microseconds the clock tries to service requests early
- * to account for processing overhead */
-#define CLOCK_TARGET_OFFSET  20
-
-/* Default wait time (in microseconds) when the clock is paused. */
-#define CLOCK_WAIT_TIME  200000LL
-
-/* In order to prevent unnecessary clock jitter when updating the local media-time of the
- * clock, an upper and lower threshold is used. If the difference between the reference
- * media-time and local media-time is greater than the upper threshold, local media-time
- * is set to the reference time. Below this threshold, a weighted moving average is applied
- * to the difference. If this is greater than the lower threshold, the local media-time is
- * adjusted by the average. Anything below the lower threshold is ignored. */
-#define CLOCK_UPDATE_THRESHOLD_LOWER  8000   /* microseconds */
-#define CLOCK_UPDATE_THRESHOLD_UPPER  50000  /* microseconds */
-
-/* Default threshold after which backward jumps in media time are treated as a discontinuity. */
-#define CLOCK_DISCONT_THRESHOLD  1000000  /* microseconds */
-
-/* Default duration for which a discontinuity applies. Used for wall time duration for which
- * a discontinuity continues to cause affected requests to fire immediately, and as the media
- * time span for detecting discontinuous requests. */
-#define CLOCK_DISCONT_DURATION   1000000  /* microseconds */
-
-/* Absolute value macro */
-#define ABS_VALUE(v)  (((v) < 0) ? -(v) : (v))
-
-/* Macros used to make clock access thread-safe */
-#define LOCK(p)    vcos_mutex_lock(&(p)->lock);
-#define UNLOCK(p)  vcos_mutex_unlock(&(p)->lock);
-
-
-/*****************************************************************************/
-#ifdef USE_RTOS_TIMER
-typedef RTOS_TIMER_T MMAL_TIMER_T;
-#else
-typedef VCOS_TIMER_T MMAL_TIMER_T;
-#endif
-
-typedef struct MMAL_CLOCK_REQUEST_T
-{
-   MMAL_LIST_ELEMENT_T link; /**< must be first */
-   MMAL_CLOCK_VOID_FP priv;  /**< client-supplied function pointer */
-   MMAL_CLOCK_REQUEST_CB cb; /**< client-supplied callback to invoke */
-   void *cb_data;            /**< client-supplied callback data */
-   int64_t offset;           /**< time offset requested by the client (microseconds) */
-   int64_t media_time;       /**< media-time requested by the client (microseconds) */
-   int64_t media_time_adj;   /**< adjusted media-time at which the request will be
-                                  serviced in microseconds (this takes the client-supplied
-                                  offset and CLOCK_TARGET_OFFSET into account) */
-} MMAL_CLOCK_REQUEST_T;
-
-typedef struct MMAL_CLOCK_PRIVATE_T
-{
-   MMAL_CLOCK_T clock;        /**< must be first */
-
-   MMAL_BOOL_T is_active;     /**< TRUE -> media-time is advancing */
-
-   MMAL_BOOL_T stop_thread;
-   VCOS_SEMAPHORE_T event;
-   VCOS_THREAD_T thread;
-
-   VCOS_MUTEX_T lock;         /**< lock access to the request lists */
-
-   MMAL_TIMER_T timer;        /**< used for scheduling client requests */
-
-   int32_t scale;             /**< media-time scale factor (Q16 format) */
-   int32_t scale_inv;         /**< 1/scale (Q16 format) */
-   MMAL_RATIONAL_T scale_rational;
-                              /**< clock scale as a rational number; keep a copy since
-                                   converting from Q16 will result in precision errors */
-
-   int64_t  average_ref_diff; /**< media-time moving average adjustment */
-   int64_t  media_time;       /**< current local media-time in microseconds */
-   int64_t  media_time_offset;/**< media-time offset in microseconds */
-   uint32_t media_time_frac;  /**< media-time fraction in microseconds (Q24 format) */
-   int64_t  wall_time;        /**< current local wall-time (microseconds) */
-   uint32_t rtc_at_update;    /**< real-time clock value at local time update (microseconds) */
-   int64_t  media_time_at_timer;
-                              /**< media-time when the timer was last set */
-
-   int64_t  discont_expiry;   /**< wall-time when discontinuity expires; 0 = no discontinuity
-                                   in effect */
-   int64_t  discont_start;    /**< media-time at start of discontinuity
-                                   (n/a if discont_expiry = 0) */
-   int64_t  discont_end;      /**< media-time at end of discontinuity
-                                   (n/a if discont_expiry = 0) */
-   int64_t  discont_threshold;/**< Threshold after which backward jumps in media time are treated
-                                   as a discontinuity  (microseconds) */
-   int64_t  discont_duration; /**< Duration (wall-time) for which a discontinuity applies */
-
-   int64_t  request_threshold;/**< Threshold after which frames exceeding the media-time are
-                                   dropped (microseconds) */
-   MMAL_BOOL_T request_threshold_enable;/**< Enable the request threshold */
-   int64_t  update_threshold_lower;
-                              /**< Time differences below this threshold are ignored */
-   int64_t  update_threshold_upper;
-                              /**< Time differences above this threshold reset media time */
-
-   /* Client requests */
-   struct
-   {
-      MMAL_LIST_T* list_free;
-      MMAL_LIST_T* list_pending;
-      MMAL_CLOCK_REQUEST_T pool[CLOCK_REQUEST_SLOTS];
-   } request;
-
-} MMAL_CLOCK_PRIVATE_T;
-
-
-/*****************************************************************************/
-static void mmal_clock_wake_thread(MMAL_CLOCK_PRIVATE_T *private);
-
-/*****************************************************************************
- * Timer-specific functions
- *****************************************************************************/
-/* Callback invoked when timer expires */
-#ifdef USE_RTOS_TIMER
-static void mmal_clock_timer_cb(MMAL_TIMER_T *timer, void *ctx)
-{
-   MMAL_PARAM_UNUSED(timer);
-   /* Notify the worker thread */
-   mmal_clock_wake_thread((MMAL_CLOCK_PRIVATE_T*)ctx);
-}
-#else
-static void mmal_clock_timer_cb(void *ctx)
-{
-   /* Notify the worker thread */
-   mmal_clock_wake_thread((MMAL_CLOCK_PRIVATE_T*)ctx);
-}
-#endif
-
-/* Create a timer */
-static inline MMAL_BOOL_T mmal_clock_timer_create(MMAL_TIMER_T *timer, void *ctx)
-{
-#ifdef USE_RTOS_TIMER
-   return (rtos_timer_init(timer, mmal_clock_timer_cb, ctx) == 0);
-#else
-   return (vcos_timer_create(timer, "mmal-clock timer", mmal_clock_timer_cb, ctx) == VCOS_SUCCESS);
-#endif
-}
-
-/* Destroy a timer */
-static inline void mmal_clock_timer_destroy(MMAL_TIMER_T *timer)
-{
-#ifdef USE_RTOS_TIMER
-   /* Nothing to do */
-#else
-   vcos_timer_delete(timer);
-#endif
-}
-
-/* Set the timer. Delay is in microseconds. */
-static inline void mmal_clock_timer_set(MMAL_TIMER_T *timer, int64_t delay_us)
-{
-#ifdef USE_RTOS_TIMER
-   rtos_timer_set(timer, (RTOS_TIMER_TIME_T)delay_us);
-#else
-   /* VCOS timer only provides millisecond accuracy */
-   vcos_timer_set(timer, (VCOS_UNSIGNED)(delay_us / 1000));
-#endif
-}
-
-/* Stop the timer. */
-static inline void mmal_clock_timer_cancel(MMAL_TIMER_T *timer)
-{
-#ifdef USE_RTOS_TIMER
-   rtos_timer_cancel(timer);
-#else
-   vcos_timer_cancel(timer);
-#endif
-}
-
-
-/*****************************************************************************
- * Clock module private functions
- *****************************************************************************/
-/* Update the internal wall-time and media-time */
-static void mmal_clock_update_local_time(MMAL_CLOCK_PRIVATE_T *private)
-{
-   uint32_t time_now = vcos_getmicrosecs();
-   uint32_t time_diff = (time_now > private->rtc_at_update) ? (time_now - private->rtc_at_update) : 0;
-
-   private->wall_time += time_diff;
-
-   /* Only update the media-time if the clock is active */
-   if (private->is_active)
-   {
-      /* For small clock scale values (i.e. slow motion), the media-time increment
-       * could potentially be rounded down when doing lots of updates, so also keep
-       * track of the fractional increment. */
-      int64_t media_diff = ((int64_t)time_diff) * (int64_t)(private->scale << 8) + private->media_time_frac;
-
-      private->media_time += media_diff >> 24;
-      private->media_time_frac = media_diff & ((1<<24)-1);
-   }
-
-   private->rtc_at_update = time_now;
-}
-
-/* Comparison function used for inserting a request into
- * the list of pending requests when clock scale is positive. */
-static int mmal_clock_request_compare_pos(MMAL_LIST_ELEMENT_T *lhs, MMAL_LIST_ELEMENT_T *rhs)
-{
-   return ((MMAL_CLOCK_REQUEST_T*)lhs)->media_time_adj < ((MMAL_CLOCK_REQUEST_T*)rhs)->media_time_adj;
-}
-
-/* Comparison function used for inserting a request into
- * the list of pending requests when clock scale is negative. */
-static int mmal_clock_request_compare_neg(MMAL_LIST_ELEMENT_T *lhs, MMAL_LIST_ELEMENT_T *rhs)
-{
-   return ((MMAL_CLOCK_REQUEST_T*)lhs)->media_time_adj > ((MMAL_CLOCK_REQUEST_T*)rhs)->media_time_adj;
-}
-
-/* Insert a new request into the list of pending requests */
-static MMAL_BOOL_T mmal_clock_request_insert(MMAL_CLOCK_PRIVATE_T *private, MMAL_CLOCK_REQUEST_T *request)
-{
-   MMAL_LIST_T *list = private->request.list_pending;
-   MMAL_CLOCK_REQUEST_T *pending;
-
-   if (private->stop_thread)
-      return MMAL_FALSE; /* the clock is being destroyed */
-
-   if (list->length == 0)
-   {
-      mmal_list_push_front(list, &request->link);
-      return MMAL_TRUE;
-   }
-
-   /* It is more likely for requests to be received in sequence,
-    * so try adding to the back of the list first before doing
-    * a more expensive list insert. */
-   pending = (MMAL_CLOCK_REQUEST_T*)list->last;
-   if ((private->scale >= 0 && (request->media_time_adj >= pending->media_time_adj)) ||
-       (private->scale <  0 && (request->media_time_adj <= pending->media_time_adj)))
-   {
-      mmal_list_push_back(list, &request->link);
-   }
-   else
-   {
-      mmal_list_insert(list, &request->link,
-            (private->scale >= 0) ? mmal_clock_request_compare_pos : mmal_clock_request_compare_neg);
-   }
-   return MMAL_TRUE;
-}
-
-/* Flush all pending requests */
-static MMAL_STATUS_T mmal_clock_request_flush_locked(MMAL_CLOCK_PRIVATE_T *private,
-                                                     int64_t media_time)
-{
-   MMAL_LIST_T *pending = private->request.list_pending;
-   MMAL_LIST_T *list_free = private->request.list_free;
-   MMAL_CLOCK_REQUEST_T *request;
-
-   while ((request = (MMAL_CLOCK_REQUEST_T *)mmal_list_pop_front(pending)) != NULL)
-   {
-      /* Inform the client */
-      request->cb(&private->clock, media_time, request->cb_data, request->priv);
-      /* Recycle request slot */
-      mmal_list_push_back(list_free, &request->link);
-   }
-
-   private->media_time_at_timer = 0;
-
-   return MMAL_SUCCESS;
-}
-
-/* Process all pending requests */
-static void mmal_clock_process_requests(MMAL_CLOCK_PRIVATE_T *private)
-{
-   int64_t media_time_now;
-   MMAL_LIST_T* free = private->request.list_free;
-   MMAL_LIST_T* pending = private->request.list_pending;
-   MMAL_CLOCK_REQUEST_T *next;
-
-   if (pending->length == 0 || !private->is_active)
-      return;
-
-   LOCK(private);
-
-   /* Detect discontinuity */
-   if (private->media_time_at_timer != 0)
-   {
-      media_time_now = mmal_clock_media_time_get(&private->clock);
-      /* Currently only applied to forward speeds */
-      if (private->scale > 0 &&
-          media_time_now + private->discont_threshold < private->media_time_at_timer)
-      {
-         LOG_INFO("discontinuity: was=%" PRIi64 " now=%" PRIi64 " pending=%d",
-                  private->media_time_at_timer, media_time_now, pending->length);
-
-         /* It's likely that packets from before the discontinuity will continue to arrive for
-          * a short time. Ensure these are detected and the requests fired immediately. */
-         private->discont_start = private->media_time_at_timer;
-         private->discont_end = private->discont_start + private->discont_duration;
-         private->discont_expiry = private->wall_time + private->discont_duration;
-
-         /* Fire all pending requests */
-         mmal_clock_request_flush_locked(private, media_time_now);
-      }
-   }
-
-   /* Earliest request is always at the front */
-   next = (MMAL_CLOCK_REQUEST_T*)mmal_list_pop_front(pending);
-   while (next)
-   {
-      media_time_now = mmal_clock_media_time_get(&private->clock);
-
-      if (private->discont_expiry != 0 && private->wall_time > private->discont_expiry)
-      {
-         private->discont_expiry = 0;
-      }
-
-      /* Fire the request if it matches the pending discontinuity or if its requested media time
-       * has been reached. */
-      if ((private->discont_expiry != 0 &&
-           next->media_time_adj >= private->discont_start &&
-           next->media_time_adj < private->discont_end) ||
-          (private->scale > 0 && ((media_time_now + MIN_TIMER_DELAY) >= next->media_time_adj)) ||
-          (private->scale < 0 && ((media_time_now - MIN_TIMER_DELAY) <= next->media_time_adj)))
-      {
-         LOG_TRACE("servicing request: next %"PRIi64" now %"PRIi64, next->media_time_adj, media_time_now);
-         /* Inform the client */
-         next->cb(&private->clock, media_time_now, next->cb_data, next->priv);
-         /* Recycle the request slot */
-         mmal_list_push_back(free, &next->link);
-         /* Move onto next pending request */
-         next = (MMAL_CLOCK_REQUEST_T*)mmal_list_pop_front(pending);
-      }
-      else
-      {
-         /* The next request is in the future, so re-schedule the
-          * timer based on the current clock scale and media-time diff */
-         int64_t media_time_delay = ABS_VALUE(media_time_now - next->media_time_adj);
-         int64_t wall_time_delay = ABS_VALUE(((int64_t)private->scale_inv * media_time_delay) >> 16);
-
-         if (private->scale == 0)
-            wall_time_delay = CLOCK_WAIT_TIME; /* Clock is paused */
-
-         /* Put next request back into pending list */
-         mmal_list_push_front(pending, &next->link);
-         next = NULL;
-
-         /* Set the timer */
-         private->media_time_at_timer = media_time_now;
-         mmal_clock_timer_set(&private->timer, wall_time_delay);
-
-         LOG_TRACE("re-schedule timer: now %"PRIi64" delay %"PRIi64, media_time_now, wall_time_delay);
-      }
-   }
-
-   UNLOCK(private);
-}
-
-/* Trigger the worker thread */
-static void mmal_clock_wake_thread(MMAL_CLOCK_PRIVATE_T *private)
-{
-   vcos_semaphore_post(&private->event);
-}
-
-/* Stop the worker thread */
-static void mmal_clock_stop_thread(MMAL_CLOCK_PRIVATE_T *private)
-{
-   private->stop_thread = MMAL_TRUE;
-   mmal_clock_wake_thread(private);
-   vcos_thread_join(&private->thread, NULL);
-}
-
-/* Main processing thread */
-static void* mmal_clock_worker_thread(void *ctx)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)ctx;
-
-   while (1)
-   {
-      vcos_semaphore_wait(&private->event);
-
-      /* Either the timer has expired or a new request is pending */
-      mmal_clock_timer_cancel(&private->timer);
-
-      if (private->stop_thread)
-         break;
-
-      mmal_clock_process_requests(private);
-   }
-   return NULL;
-}
-
-/* Start the media-time */
-static void mmal_clock_start(MMAL_CLOCK_T *clock)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-
-   private->is_active = MMAL_TRUE;
-   mmal_clock_wake_thread(private);
-}
-
-/* Stop the media-time */
-static void mmal_clock_stop(MMAL_CLOCK_T *clock)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-
-   private->is_active = MMAL_FALSE;
-}
-
-/*****************************************************************************
- * Clock module public functions
- *****************************************************************************/
-/* Create new clock instance */
-MMAL_STATUS_T mmal_clock_create(MMAL_CLOCK_T **clock)
-{
-   unsigned int i, size = sizeof(MMAL_CLOCK_PRIVATE_T);
-   MMAL_BOOL_T timer_status = MMAL_FALSE;
-   VCOS_STATUS_T lock_status = VCOS_EINVAL;
-   VCOS_STATUS_T event_status = VCOS_EINVAL;
-   MMAL_RATIONAL_T scale = { 1, 0 };
-   VCOS_UNSIGNED priority;
-   MMAL_CLOCK_PRIVATE_T *private;
-
-   /* Sanity checking */
-   if (clock == NULL)
-      return MMAL_EINVAL;
-
-   private = vcos_calloc(1, size, "mmal-clock");
-   if (!private)
-   {
-      LOG_ERROR("failed to allocate memory");
-      return MMAL_ENOMEM;
-   }
-
-   timer_status = mmal_clock_timer_create(&private->timer, private);
-   if (!timer_status)
-   {
-      LOG_ERROR("failed to create timer %p", private);
-      goto error;
-   }
-
-   event_status = vcos_semaphore_create(&private->event, "mmal-clock sema", 0);
-   if (event_status != VCOS_SUCCESS)
-   {
-      LOG_ERROR("failed to create event semaphore %d", event_status);
-      goto error;
-   }
-
-   lock_status = vcos_mutex_create(&private->lock, "mmal-clock lock");
-   if (lock_status != VCOS_SUCCESS)
-   {
-      LOG_ERROR("failed to create lock mutex %d", lock_status);
-      goto error;
-   }
-
-   private->request.list_free = mmal_list_create();
-   private->request.list_pending = mmal_list_create();
-   if (!private->request.list_free || !private->request.list_pending)
-   {
-      LOG_ERROR("failed to create list %p %p", private->request.list_free, private->request.list_pending);
-      goto error;
-   }
-
-   /* Set the default threshold values */
-   private->update_threshold_lower = CLOCK_UPDATE_THRESHOLD_LOWER;
-   private->update_threshold_upper = CLOCK_UPDATE_THRESHOLD_UPPER;
-   private->discont_threshold      = CLOCK_DISCONT_THRESHOLD;
-   private->discont_duration       = CLOCK_DISCONT_DURATION;
-   private->request_threshold      = 0;
-   private->request_threshold_enable = MMAL_FALSE;
-
-   if (vcos_thread_create(&private->thread, "mmal-clock thread", NULL,
-                          mmal_clock_worker_thread, private) != VCOS_SUCCESS)
-   {
-      LOG_ERROR("failed to create worker thread");
-      goto error;
-   }
-   priority = vcos_thread_get_priority(&private->thread);
-   vcos_thread_set_priority(&private->thread, 1 | (priority & VCOS_AFFINITY_MASK));
-
-   /* Populate the list of available request slots */
-   for (i = 0; i < CLOCK_REQUEST_SLOTS; ++i)
-      mmal_list_push_back(private->request.list_free, &private->request.pool[i].link);
-
-   /* Default scale = 1.0, i.e. normal playback speed */
-   mmal_clock_scale_set(&private->clock, scale);
-
-   *clock = &private->clock;
-   return MMAL_SUCCESS;
-
-error:
-   if (lock_status == VCOS_SUCCESS) vcos_mutex_delete(&private->lock);
-   if (event_status == VCOS_SUCCESS) vcos_semaphore_delete(&private->event);
-   if (timer_status) mmal_clock_timer_destroy(&private->timer);
-   if (private->request.list_free) mmal_list_destroy(private->request.list_free);
-   if (private->request.list_pending) mmal_list_destroy(private->request.list_pending);
-   vcos_free(private);
-   return MMAL_ENOSPC;
-}
-
-/* Destroy a clock instance */
-MMAL_STATUS_T mmal_clock_destroy(MMAL_CLOCK_T *clock)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-
-   mmal_clock_stop_thread(private);
-
-   mmal_clock_request_flush(clock);
-
-   mmal_list_destroy(private->request.list_free);
-   mmal_list_destroy(private->request.list_pending);
-
-   mmal_clock_timer_destroy(&private->timer);
-
-   vcos_mutex_delete(&private->lock);
-
-   vcos_semaphore_delete(&private->event);
-
-   vcos_free(private);
-
-   return MMAL_SUCCESS;
-}
-
-/* Add new client request to list of pending requests */
-MMAL_STATUS_T mmal_clock_request_add(MMAL_CLOCK_T *clock, int64_t media_time, int64_t offset,
-      MMAL_CLOCK_REQUEST_CB cb, void *cb_data, MMAL_CLOCK_VOID_FP priv)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-   MMAL_CLOCK_REQUEST_T *request;
-   MMAL_BOOL_T success;
-   int64_t media_time_now;
-
-   LOG_TRACE("media time %"PRIi64" offset %"PRIi64, media_time, offset);
-
-   /* Drop the request if request_threshold_enable and the frame exceeds the request threshold */
-   media_time_now = mmal_clock_media_time_get(&private->clock);
-   LOCK(private);
-   if(private->request_threshold_enable && (media_time > (media_time_now + private->request_threshold))) {
-      LOG_TRACE("dropping request: media time %"PRIi64" now %"PRIi64, media_time, media_time_now);
-      UNLOCK(private);
-      return MMAL_ECORRUPT;
-   }
-   UNLOCK(private);
-   request = (MMAL_CLOCK_REQUEST_T*)mmal_list_pop_front(private->request.list_free);
-   if (request == NULL)
-   {
-      LOG_ERROR("no more free clock request slots");
-      return MMAL_ENOSPC;
-   }
-
-   request->cb = cb;
-   request->cb_data = cb_data;
-   request->priv = priv;
-   request->offset = offset;
-   request->media_time = media_time;
-   request->media_time_adj = media_time - (int64_t)(private->scale * (request->offset + CLOCK_TARGET_OFFSET) >> 16);
-
-   LOCK(private);
-   success = mmal_clock_request_insert(private, request);
-   UNLOCK(private);
-
-   /* Notify the worker thread */
-   if (success)
-      mmal_clock_wake_thread(private);
-
-   return success ? MMAL_SUCCESS : MMAL_EINVAL;
-}
-
-/* Flush all pending requests */
-MMAL_STATUS_T mmal_clock_request_flush(MMAL_CLOCK_T *clock)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-
-   LOCK(private);
-   mmal_clock_request_flush_locked(private, MMAL_TIME_UNKNOWN);
-   UNLOCK(private);
-
-   return MMAL_SUCCESS;
-}
-
-/* Update the local media-time with the given reference */
-MMAL_STATUS_T mmal_clock_media_time_set(MMAL_CLOCK_T *clock, int64_t media_time)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-   MMAL_BOOL_T wake_thread = MMAL_TRUE;
-   int64_t time_diff;
-
-   /* Reset the local media-time with the given time reference */
-   mmal_clock_update_local_time(private);
-
-   time_diff = private->media_time - media_time;
-   if (time_diff >  private->update_threshold_upper ||
-       time_diff < -private->update_threshold_upper)
-   {
-      LOG_TRACE("cur:%"PRIi64" new:%"PRIi64" diff:%"PRIi64, private->media_time, media_time, time_diff);
-      private->media_time = media_time;
-      private->average_ref_diff = 0;
-   }
-   else
-   {
-      private->average_ref_diff = ((private->average_ref_diff << 6) - private->average_ref_diff + time_diff) >> 6;
-      if(private->average_ref_diff >  private->update_threshold_lower ||
-         private->average_ref_diff < -private->update_threshold_lower)
-      {
-         LOG_TRACE("cur:%"PRIi64" new:%"PRIi64" ave:%"PRIi64, private->media_time,
-               private->media_time - private->average_ref_diff, private->average_ref_diff);
-         private->media_time -= private->average_ref_diff;
-         private->average_ref_diff = 0;
-      }
-      else
-      {
-         /* Don't update the media-time */
-         wake_thread = MMAL_FALSE;
-         LOG_TRACE("cur:%"PRIi64" new:%"PRIi64" diff:%"PRIi64" ave:%"PRIi64" ignored", private->media_time,
-               media_time, private->media_time - media_time, private->average_ref_diff);
-      }
-   }
-
-   if (wake_thread)
-      mmal_clock_wake_thread(private);
-
-   return wake_thread ? MMAL_SUCCESS : MMAL_EINVAL;
-}
-
-/* Set a media-time offset */
-MMAL_STATUS_T mmal_clock_media_time_offset_set(MMAL_CLOCK_T *clock, int64_t offset)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-
-   LOG_TRACE("new offset %"PRIi64, offset);
-
-   private->media_time_offset = offset;
-
-   mmal_clock_wake_thread(private);
-
-   return MMAL_SUCCESS;
-}
-
-/* Change the clock scale */
-MMAL_STATUS_T mmal_clock_scale_set(MMAL_CLOCK_T *clock, MMAL_RATIONAL_T scale)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-
-   LOG_TRACE("new scale %d/%d", scale.num, scale.den);
-
-   mmal_clock_update_local_time(private);
-
-   LOCK(private);
-
-   private->scale_rational = scale;
-   private->scale = mmal_rational_to_fixed_16_16(scale);
-
-   if (private->scale)
-      private->scale_inv = (int32_t)((1LL << 32) / (int64_t)private->scale);
-   else
-      private->scale_inv = Q16_ONE; /* clock is paused */
-
-   UNLOCK(private);
-
-   mmal_clock_wake_thread(private);
-
-   return MMAL_SUCCESS;
-}
-
-/* Set the clock state */
-MMAL_STATUS_T mmal_clock_active_set(MMAL_CLOCK_T *clock, MMAL_BOOL_T active)
-{
-   if (active)
-      mmal_clock_start(clock);
-   else
-      mmal_clock_stop(clock);
-
-   return MMAL_SUCCESS;
-}
-
-/* Get the clock's scale */
-MMAL_RATIONAL_T mmal_clock_scale_get(MMAL_CLOCK_T *clock)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-   MMAL_RATIONAL_T scale;
-
-   LOCK(private);
-   scale = private->scale_rational;
-   UNLOCK(private);
-
-   return scale;
-}
-
-/* Return the current local media-time */
-int64_t mmal_clock_media_time_get(MMAL_CLOCK_T *clock)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T*)clock;
-
-   mmal_clock_update_local_time(private);
-
-   return private->media_time + (private->scale * private->media_time_offset >> 16);
-}
-
-/* Return the media-time offset */
-int64_t mmal_clock_media_time_offset_get(MMAL_CLOCK_T *clock)
-{
-   return ((MMAL_CLOCK_PRIVATE_T*)clock)->media_time_offset;
-}
-
-/* Get the clock's state */
-MMAL_BOOL_T mmal_clock_is_active(MMAL_CLOCK_T *clock)
-{
-   return ((MMAL_CLOCK_PRIVATE_T*)clock)->is_active;
-}
-
-/* Get the clock's media-time update threshold values */
-MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
-
-   LOCK(private);
-   update_threshold->threshold_lower = private->update_threshold_lower;
-   update_threshold->threshold_upper = private->update_threshold_upper;
-   UNLOCK(private);
-
-   return MMAL_SUCCESS;
-}
-
-/* Set the clock's media-time update threshold values */
-MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
-
-   LOG_TRACE("new clock update thresholds: upper %"PRIi64", lower %"PRIi64,
-         update_threshold->threshold_lower, update_threshold->threshold_upper);
-
-   LOCK(private);
-   private->update_threshold_lower = update_threshold->threshold_lower;
-   private->update_threshold_upper = update_threshold->threshold_upper;
-   UNLOCK(private);
-
-   return MMAL_SUCCESS;
-}
-
-/* Get the clock's discontinuity threshold values */
-MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
-
-   LOCK(private);
-   discont->threshold = private->discont_threshold;
-   discont->duration  = private->discont_duration;
-   UNLOCK(private);
-
-   return MMAL_SUCCESS;
-}
-
-/* Set the clock's discontinuity threshold values */
-MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
-
-   LOG_TRACE("new clock discontinuity values: threshold %"PRIi64", duration %"PRIi64,
-         discont->threshold, discont->duration);
-
-   LOCK(private);
-   private->discont_threshold = discont->threshold;
-   private->discont_duration  = discont->duration;
-   UNLOCK(private);
-
-   return MMAL_SUCCESS;
-}
-
-/* Get the clock's request threshold values */
-MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
-
-   LOCK(private);
-   req->threshold = private->request_threshold;
-   req->threshold_enable = private->request_threshold_enable;
-   UNLOCK(private);
-
-   return MMAL_SUCCESS;
-}
-
-/* Set the clock's request threshold values */
-MMAL_STATUS_T mmal_clock_request_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req)
-{
-   MMAL_CLOCK_PRIVATE_T *private = (MMAL_CLOCK_PRIVATE_T *)clock;
-
-   LOG_TRACE("new clock request values: threshold %"PRIi64,
-         req->threshold);
-
-   LOCK(private);
-   private->request_threshold = req->threshold;
-   private->request_threshold_enable = req->threshold_enable;
-   UNLOCK(private);
-
-   return MMAL_SUCCESS;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock_private.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock_private.h
deleted file mode 100644
index c90461d..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_clock_private.h
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_CLOCK_PRIVATE_H
-#define MMAL_CLOCK_PRIVATE_H
-
-#include "interface/mmal/mmal.h"
-#include "interface/mmal/mmal_clock.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/** Handle to a clock. */
-typedef struct MMAL_CLOCK_T
-{
-   void *user_data;   /**< Client-supplied data (not used by the clock). */
-} MMAL_CLOCK_T;
-
-/** Create a new instance of a clock.
- *
- * @param clock Returned clock
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_create(MMAL_CLOCK_T **clock);
-
-/** Destroy a previously created clock.
- *
- * @param clock The clock to destroy
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_destroy(MMAL_CLOCK_T *clock);
-
-/** Definition of a clock request callback.
- * This is invoked when the media-time requested by the client is reached.
- *
- * @param clock      The clock which serviced the request
- * @param media_time The current media-time
- * @param cb_data    Client-supplied data
- * @param priv       Function pointer used by the framework
- */
-typedef void (*MMAL_CLOCK_VOID_FP)(void);
-typedef void (*MMAL_CLOCK_REQUEST_CB)(MMAL_CLOCK_T *clock, int64_t media_time, void *cb_data, MMAL_CLOCK_VOID_FP priv);
-
-/** Register a request with the clock.
- * When the specified media-time is reached, the clock will invoke the supplied callback.
- *
- * @param clock      The clock
- * @param media_time The media-time at which the callback should be invoked (microseconds)
- * @param offset     Time offset (in microseconds) applied to the media-time. This can be used
- *                   to schedule the request slightly in advance of the media-time.
- * @param cb         Callback to invoke
- * @param cb_data    Client-supplied callback data
- * @param priv       Function pointer used by the framework
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_request_add(MMAL_CLOCK_T *clock, int64_t media_time, int64_t offset,
-                                     MMAL_CLOCK_REQUEST_CB cb, void *cb_data, MMAL_CLOCK_VOID_FP priv);
-
-/** Remove all previously registered clock requests.
- *
- * @param clock      The clock
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_request_flush(MMAL_CLOCK_T *clock);
-
-/** Update the clock's media-time.
- *
- * @param clock      The clock to update
- * @param media_time New media-time to be applied (microseconds)
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_media_time_set(MMAL_CLOCK_T *clock, int64_t media_time);
-
-/** Update the clock's media-time offset.
- *
- * @param clock      The clock to update
- * @param media_time New media-time offset to be applied (microseconds)
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_media_time_offset_set(MMAL_CLOCK_T *clock, int64_t offset);
-
-/** Set the clock's scale.
- *
- * @param clock      The clock
- * @param scale      Scale factor
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_scale_set(MMAL_CLOCK_T *clock, MMAL_RATIONAL_T scale);
-
-/** Set the clock state.
- *
- * @param clock      The clock
- * @param active     TRUE -> clock is active and media-time is advancing
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_active_set(MMAL_CLOCK_T *clock, MMAL_BOOL_T active);
-
-/** Get the clock's scale.
- *
- * @param clock      The clock
- *
- * @return Current clock scale
- */
-MMAL_RATIONAL_T mmal_clock_scale_get(MMAL_CLOCK_T *clock);
-
-/** Get the clock's current media-time.
- * This takes the clock scale and media-time offset into account.
- *
- * @param clock      The clock to query
- *
- * @return Current media-time in microseconds
- */
-int64_t mmal_clock_media_time_get(MMAL_CLOCK_T *clock);
-
-/** Get the clock's media-time offset.
- *
- * @param clock      The clock to query
- *
- * @return Current media-time offset in microseconds
- */
-int64_t mmal_clock_media_time_offset_get(MMAL_CLOCK_T *clock);
-
-/** Get the clock's state.
- *
- * @param clock      The clock to query
- *
- * @return TRUE if clock is running (i.e. local media-time is advancing)
- */
-MMAL_BOOL_T mmal_clock_is_active(MMAL_CLOCK_T *clock);
-
-/** Get the clock's media-time update threshold values.
- *
- * @param clock             The clock
- * @param update_threshold  Pointer to clock update threshold values to fill
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_update_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold);
-
-/** Set the clock's media-time update threshold values.
- *
- * @param clock             The clock
- * @param update_threshold  Pointer to new clock update threshold values
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_update_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *update_threshold);
-
-/** Get the clock's discontinuity threshold values.
- *
- * @param clock      The clock
- * @param discont    Pointer to clock discontinuity threshold values to fill
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_discont_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont);
-
-/** Set the clock's discontinuity threshold values.
- *
- * @param clock      The clock
- * @param discont    Pointer to new clock discontinuity threshold values
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_discont_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *discont);
-
-/** Get the clock's request threshold values.
- *
- * @param clock      The clock
- * @param future     Pointer to clock request threshold values to fill
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_request_threshold_get(MMAL_CLOCK_T *clock, MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req);
-
-/** Set the clock's request threshold values.
- *
- * @param clock      The clock
- * @param discont    Pointer to new clock request threshold values
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_clock_request_threshold_set(MMAL_CLOCK_T *clock, const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *req);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_CLOCK_PRIVATE_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component.c
deleted file mode 100644
index 849a350..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component.c
+++ /dev/null
@@ -1,763 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "core/mmal_component_private.h"
-#include "core/mmal_port_private.h"
-#include "core/mmal_core_private.h"
-#include "mmal_logging.h"
-
-/* Minimum number of buffers that will be available on the control port */
-#define MMAL_CONTROL_PORT_BUFFERS_MIN 4
-
-/** Definition of the core private context. */
-typedef struct
-{
-   MMAL_COMPONENT_PRIVATE_T private;
-
-   /** Action registered by component and run when buffers are received by any of the ports */
-   void (*pf_action)(MMAL_COMPONENT_T *component);
-
-   /** Action thread */
-   VCOS_THREAD_T action_thread;
-   VCOS_SEMAPHORE_T action_sema;
-   VCOS_MUTEX_T action_mutex;
-   MMAL_BOOL_T action_quit;
-
-   VCOS_MUTEX_T lock; /**< Used to lock access to the component */
-   MMAL_BOOL_T destruction_pending;
-
-} MMAL_COMPONENT_CORE_PRIVATE_T;
-
-/*****************************************************************************/
-static void mmal_core_init(void);
-static void mmal_core_deinit(void);
-
-static MMAL_STATUS_T mmal_component_supplier_create(const char *name, MMAL_COMPONENT_T *component);
-static void mmal_component_init_control_port(MMAL_PORT_T *port);
-
-static MMAL_STATUS_T mmal_component_destroy_internal(MMAL_COMPONENT_T *component);
-static MMAL_STATUS_T mmal_component_release_internal(MMAL_COMPONENT_T *component);
-
-/*****************************************************************************/
-static VCOS_MUTEX_T mmal_core_lock;
-/** Used to generate a unique id for each MMAL component in this context.    */
-static unsigned int mmal_core_instance_count;
-static unsigned int mmal_core_refcount;
-/*****************************************************************************/
-
-/** Create an instance of a component */
-static MMAL_STATUS_T mmal_component_create_core(const char *name,
-   MMAL_STATUS_T (*constructor)(const char *name, MMAL_COMPONENT_T *),
-   struct MMAL_COMPONENT_MODULE_T *constructor_private,
-   MMAL_COMPONENT_T **component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private;
-   MMAL_STATUS_T status = MMAL_ENOMEM;
-   unsigned int size = sizeof(MMAL_COMPONENT_T) + sizeof(MMAL_COMPONENT_CORE_PRIVATE_T);
-   unsigned int i, name_length = strlen(name) + 1;
-   unsigned int port_index;
-   char *component_name;
-
-   if(!component)
-      return MMAL_EINVAL;
-
-   mmal_core_init();
-
-   *component = vcos_calloc(1, size + name_length, "mmal component");
-   if(!*component)
-      return MMAL_ENOMEM;
-
-   private = (MMAL_COMPONENT_CORE_PRIVATE_T *)&(*component)[1];
-   (*component)->priv = (MMAL_COMPONENT_PRIVATE_T *)private;
-   (*component)->name = component_name= (char *)&((MMAL_COMPONENT_CORE_PRIVATE_T *)(*component)->priv)[1];
-   memcpy(component_name, name, name_length);
-   (*component)->priv->refcount = 1;
-   (*component)->priv->priority = VCOS_THREAD_PRI_NORMAL;
-
-   if(vcos_mutex_create(&private->lock, "mmal component lock") != VCOS_SUCCESS)
-   {
-      vcos_free(*component);
-      return MMAL_ENOMEM;
-   }
-
-   vcos_mutex_lock(&mmal_core_lock);
-   (*component)->id=mmal_core_instance_count++;
-   vcos_mutex_unlock(&mmal_core_lock);
-
-   /* Create the control port */
-   (*component)->control = mmal_port_alloc(*component, MMAL_PORT_TYPE_CONTROL, 0);
-   if(!(*component)->control)
-      goto error;
-   mmal_component_init_control_port((*component)->control);
-
-   /* Create the actual component */
-   (*component)->priv->module = constructor_private;
-   if (!constructor)
-      constructor = mmal_component_supplier_create;
-   status = constructor(name, *component);
-   if (status != MMAL_SUCCESS)
-   {
-      if (status == MMAL_ENOSYS)
-         LOG_ERROR("could not find component '%s'", name);
-      else
-         LOG_ERROR("could not create component '%s' (%i)", name, status);
-      goto error;
-   }
-
-   /* Make sure we have enough space for at least a MMAL_EVENT_FORMAT_CHANGED */
-   if ((*component)->control->buffer_size_min <
-       sizeof(MMAL_ES_FORMAT_T) + sizeof(MMAL_ES_SPECIFIC_FORMAT_T) + sizeof(MMAL_EVENT_FORMAT_CHANGED_T))
-      (*component)->control->buffer_size_min = sizeof(MMAL_ES_FORMAT_T) +
-         sizeof(MMAL_ES_SPECIFIC_FORMAT_T) + sizeof(MMAL_EVENT_FORMAT_CHANGED_T);
-   /* Make sure we have enough events */
-   if ((*component)->control->buffer_num_min < MMAL_CONTROL_PORT_BUFFERS_MIN)
-      (*component)->control->buffer_num_min = MMAL_CONTROL_PORT_BUFFERS_MIN;
-
-   /* Create the event pool */
-   (*component)->priv->event_pool = mmal_pool_create((*component)->control->buffer_num_min,
-         (*component)->control->buffer_size_min);
-   if (!(*component)->priv->event_pool)
-   {
-      status = MMAL_ENOMEM;
-      LOG_ERROR("could not create event pool (%d, %d)", (*component)->control->buffer_num_min,
-            (*component)->control->buffer_size_min);
-      goto error;
-   }
-
-   /* Build the list of all the ports */
-   (*component)->port_num = (*component)->input_num + (*component)->output_num + (*component)->clock_num + 1;
-   (*component)->port = vcos_malloc((*component)->port_num * sizeof(MMAL_PORT_T *), "mmal ports");
-   if (!(*component)->port)
-   {
-      status = MMAL_ENOMEM;
-      LOG_ERROR("could not create list of ports");
-      goto error;
-   }
-   port_index = 0;
-   (*component)->port[port_index++] = (*component)->control;
-   for (i = 0; i < (*component)->input_num; i++)
-      (*component)->port[port_index++] = (*component)->input[i];
-   for (i = 0; i < (*component)->output_num; i++)
-      (*component)->port[port_index++] = (*component)->output[i];
-   for (i = 0; i < (*component)->clock_num; i++)
-      (*component)->port[port_index++] = (*component)->clock[i];
-   for (i = 0; i < (*component)->port_num; i++)
-      (*component)->port[i]->index_all = i;
-
-   LOG_INFO("created '%s' %d %p", name, (*component)->id, *component);
-
-   /* Make sure the port types, indexes and buffer sizes are set correctly */
-   (*component)->control->type = MMAL_PORT_TYPE_CONTROL;
-   (*component)->control->index = 0;
-   for (i = 0; i < (*component)->input_num; i++)
-   {
-      MMAL_PORT_T *port = (*component)->input[i];
-      port->type = MMAL_PORT_TYPE_INPUT;
-      port->index = i;
-   }
-   for (i = 0; i < (*component)->output_num; i++)
-   {
-      MMAL_PORT_T *port = (*component)->output[i];
-      port->type = MMAL_PORT_TYPE_OUTPUT;
-      port->index = i;
-   }
-   for (i = 0; i < (*component)->clock_num; i++)
-   {
-      MMAL_PORT_T *port = (*component)->clock[i];
-      port->type = MMAL_PORT_TYPE_CLOCK;
-      port->index = i;
-   }
-   for (i = 0; i < (*component)->port_num; i++)
-   {
-      MMAL_PORT_T *port = (*component)->port[i];
-      if (port->buffer_size < port->buffer_size_min)
-         port->buffer_size = port->buffer_size_min;
-      if (port->buffer_num < port->buffer_num_min)
-         port->buffer_num = port->buffer_num_min;
-   }
-
-   return MMAL_SUCCESS;
-
- error:
-   mmal_component_destroy_internal(*component);
-   *component = 0;
-   return status;
-}
-
-/** Create an instance of a component */
-MMAL_STATUS_T mmal_component_create(const char *name,
-   MMAL_COMPONENT_T **component)
-{
-   LOG_TRACE("%s", name);
-   return mmal_component_create_core(name, 0, 0, component);
-}
-
-/** Create an instance of a component */
-MMAL_STATUS_T mmal_component_create_with_constructor(const char *name,
-   MMAL_STATUS_T (*constructor)(const char *name, MMAL_COMPONENT_T *),
-   struct MMAL_COMPONENT_MODULE_T *constructor_private,
-   MMAL_COMPONENT_T **component)
-{
-   LOG_TRACE("%s", name);
-   return mmal_component_create_core(name, constructor, constructor_private, component);
-}
-
-/** Destroy a previously created component */
-static MMAL_STATUS_T mmal_component_destroy_internal(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-   MMAL_STATUS_T status;
-
-   LOG_TRACE("%s %d", component->name, component->id);
-
-   mmal_component_action_deregister(component);
-
-   /* Should pf_destroy be allowed to fail ?
-    * If so, what do we do if it fails ?
-    */
-   if (component->priv->pf_destroy)
-   {
-      status = component->priv->pf_destroy(component);
-      if(!vcos_verify(status == MMAL_SUCCESS))
-         return status;
-   }
-
-   if (component->priv->event_pool)
-      mmal_pool_destroy(component->priv->event_pool);
-
-   if (component->control)
-      mmal_port_free(component->control);
-
-   if (component->port)
-      vcos_free(component->port);
-
-   vcos_mutex_delete(&private->lock);
-   vcos_free(component);
-   mmal_core_deinit();
-   return MMAL_SUCCESS;
-}
-
-/** Release a reference to a component */
-static MMAL_STATUS_T mmal_component_release_internal(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-   unsigned int i;
-
-   if (!vcos_verify(component->priv->refcount > 0))
-      return MMAL_EINVAL;
-
-   vcos_mutex_lock(&private->lock);
-   if (--component->priv->refcount)
-   {
-      vcos_mutex_unlock(&private->lock);
-      return MMAL_SUCCESS;
-   }
-   private->destruction_pending = 1;
-   vcos_mutex_unlock(&private->lock);
-
-   LOG_TRACE("%s %d preparing for destruction", component->name, component->id);
-
-   /* Make sure the ports are all disabled */
-   for(i = 0; i < component->input_num; i++)
-      if(component->input[i]->is_enabled)
-         mmal_port_disable(component->input[i]);
-   for(i = 0; i < component->output_num; i++)
-      if(component->output[i]->is_enabled)
-         mmal_port_disable(component->output[i]);
-   for(i = 0; i < component->clock_num; i++)
-      if(component->clock[i]->is_enabled)
-         mmal_port_disable(component->clock[i]);
-   if(component->control->is_enabled)
-      mmal_port_disable(component->control);
-
-   /* Make sure all the ports are disconnected. This is necessary to prevent
-    * connected ports from referencing destroyed components */
-   for(i = 0; i < component->input_num; i++)
-      mmal_port_disconnect(component->input[i]);
-   for(i = 0; i < component->output_num; i++)
-      mmal_port_disconnect(component->output[i]);
-   for(i = 0; i < component->clock_num; i++)
-      mmal_port_disconnect(component->clock[i]);
-
-   /* If there is any reference pending on the ports we will delay the actual destruction */
-   vcos_mutex_lock(&private->lock);
-   if (component->priv->refcount_ports)
-   {
-      private->destruction_pending = 0;
-      vcos_mutex_unlock(&private->lock);
-      LOG_TRACE("%s %d delaying destruction", component->name, component->id);
-      return MMAL_SUCCESS;
-   }
-   vcos_mutex_unlock(&private->lock);
-
-   return mmal_component_destroy_internal(component);
-}
-
-/** Destroy a component */
-MMAL_STATUS_T mmal_component_destroy(MMAL_COMPONENT_T *component)
-{
-   if(!component)
-      return MMAL_EINVAL;
-
-   LOG_TRACE("%s %d", component->name, component->id);
-
-   return mmal_component_release_internal(component);
-}
-
-/** Acquire a reference to a component */
-void mmal_component_acquire(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-
-   LOG_TRACE("component %s(%d), refcount %i", component->name, component->id,
-             component->priv->refcount);
-
-   vcos_mutex_lock(&private->lock);
-   component->priv->refcount++;
-   vcos_mutex_unlock(&private->lock);
-}
-
-/** Release a reference to a component */
-MMAL_STATUS_T mmal_component_release(MMAL_COMPONENT_T *component)
-{
-   if(!component)
-      return MMAL_EINVAL;
-
-   LOG_TRACE("component %s(%d), refcount %i", component->name, component->id,
-             component->priv->refcount);
-
-   return mmal_component_release_internal(component);
-}
-
-/** Enable processing on a component */
-MMAL_STATUS_T mmal_component_enable(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private;
-   MMAL_STATUS_T status;
-   unsigned int i;
-
-   if(!component)
-      return MMAL_EINVAL;
-
-   private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-
-   LOG_TRACE("%s %d", component->name, component->id);
-
-   vcos_mutex_lock(&private->lock);
-
-   /* Check we have anything to do */
-   if (component->is_enabled)
-   {
-      vcos_mutex_unlock(&private->lock);
-      return MMAL_SUCCESS;
-   }
-
-   status = component->priv->pf_enable(component);
-
-   /* Resume all input / output ports */
-   for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
-      status = mmal_port_pause(component->input[i], MMAL_FALSE);
-   for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
-      status = mmal_port_pause(component->output[i], MMAL_FALSE);
-
-   if (status == MMAL_SUCCESS)
-      component->is_enabled = 1;
-
-   vcos_mutex_unlock(&private->lock);
-
-   return status;
-}
-
-/** Disable processing on a component */
-MMAL_STATUS_T mmal_component_disable(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private;
-   MMAL_STATUS_T status;
-   unsigned int i;
-
-   if (!component)
-      return MMAL_EINVAL;
-
-   private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-
-   LOG_TRACE("%s %d", component->name, component->id);
-
-   vcos_mutex_lock(&private->lock);
-
-   /* Check we have anything to do */
-   if (!component->is_enabled)
-   {
-      vcos_mutex_unlock(&private->lock);
-      return MMAL_SUCCESS;
-   }
-
-   status = component->priv->pf_disable(component);
-
-   /* Pause all input / output ports */
-   for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
-      status = mmal_port_pause(component->input[i], MMAL_TRUE);
-   for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
-      status = mmal_port_pause(component->output[i], MMAL_TRUE);
-
-   if (status == MMAL_SUCCESS)
-      component->is_enabled = 0;
-
-   vcos_mutex_unlock(&private->lock);
-
-   return status;
-}
-
-static MMAL_STATUS_T mmal_component_enable_control_port(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
-{
-   (void)port;
-   (void)cb;
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_component_disable_control_port(MMAL_PORT_T *port)
-{
-   (void)port;
-   return MMAL_SUCCESS;
-}
-
-MMAL_STATUS_T mmal_component_parameter_set(MMAL_PORT_T *control_port,
-                                           const MMAL_PARAMETER_HEADER_T *param)
-{
-   (void)control_port;
-   (void)param;
-   /* No generic component control parameters */
-   LOG_ERROR("parameter id 0x%08x not supported", param->id);
-   return MMAL_ENOSYS;
-}
-
-MMAL_STATUS_T mmal_component_parameter_get(MMAL_PORT_T *control_port,
-                                           MMAL_PARAMETER_HEADER_T *param)
-{
-   (void)control_port;
-   (void)param;
-   /* No generic component control parameters */
-   LOG_ERROR("parameter id 0x%08x not supported", param->id);
-   return MMAL_ENOSYS;
-}
-
-static void mmal_component_init_control_port(MMAL_PORT_T *port)
-{
-   port->format->type = MMAL_ES_TYPE_CONTROL;
-   port->buffer_num_min = MMAL_CONTROL_PORT_BUFFERS_MIN;
-   port->buffer_num = port->buffer_num_min;
-   port->buffer_size_min = sizeof(MMAL_ES_FORMAT_T) + sizeof(MMAL_ES_SPECIFIC_FORMAT_T);
-   port->buffer_size = port->buffer_size_min;
-
-   /* Default to generic handling */
-   port->priv->pf_enable = mmal_component_enable_control_port;
-   port->priv->pf_disable = mmal_component_disable_control_port;
-   port->priv->pf_parameter_set = mmal_component_parameter_set;
-   port->priv->pf_parameter_get = mmal_component_parameter_get;
-   /* No pf_set_format - format of control port cannot be changed */
-   /* No pf_send - buffers cannot be sent to control port */
-}
-
-/** Acquire a reference on a port */
-void mmal_port_acquire(MMAL_PORT_T *port)
-{
-   MMAL_COMPONENT_T *component = port->component;
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-
-   LOG_TRACE("port %s(%p), refcount %i", port->name, port,
-             component->priv->refcount_ports);
-
-   vcos_mutex_lock(&private->lock);
-   component->priv->refcount_ports++;
-   vcos_mutex_unlock(&private->lock);
-}
-
-/** Release a reference on a port */
-MMAL_STATUS_T mmal_port_release(MMAL_PORT_T *port)
-{
-   MMAL_COMPONENT_T *component = port->component;
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-
-   LOG_TRACE("port %s(%p), refcount %i", port->name, port,
-             component->priv->refcount_ports);
-
-   /* Sanity check the refcount */
-   if (!vcos_verify(component->priv->refcount_ports > 0))
-      return MMAL_EINVAL;
-
-   vcos_mutex_lock(&private->lock);
-   if (--component->priv->refcount_ports ||
-       component->priv->refcount || private->destruction_pending)
-   {
-      vcos_mutex_unlock(&private->lock);
-      return MMAL_SUCCESS;
-   }
-   vcos_mutex_unlock(&private->lock);
-
-   return mmal_component_destroy_internal(component);
-}
-
-/*****************************************************************************
- * Actions support
- *****************************************************************************/
-
-/** Registers an action with the core */
-static void *mmal_component_action_thread_func(void *arg)
-{
-   MMAL_COMPONENT_T *component = (MMAL_COMPONENT_T *)arg;
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-   VCOS_STATUS_T status;
-
-   while (1)
-   {
-      status = vcos_semaphore_wait(&private->action_sema);
-
-      if (status == VCOS_EAGAIN)
-         continue;
-      if (private->action_quit)
-         break;
-      if (!vcos_verify(status == VCOS_SUCCESS))
-         break;
-
-      vcos_mutex_lock(&private->action_mutex);
-      private->pf_action(component);
-      vcos_mutex_unlock(&private->action_mutex);
-   }
-   return 0;
-}
-
-/** Registers an action with the core */
-MMAL_STATUS_T mmal_component_action_register(MMAL_COMPONENT_T *component,
-                                             void (*pf_action)(MMAL_COMPONENT_T *) )
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-   VCOS_THREAD_ATTR_T attrs;
-   VCOS_STATUS_T status;
-
-   if (private->pf_action)
-      return MMAL_EINVAL;
-
-   status = vcos_semaphore_create(&private->action_sema, component->name, 0);
-   if (status != VCOS_SUCCESS)
-      return MMAL_ENOMEM;
-
-   status = vcos_mutex_create(&private->action_mutex, component->name);
-   if (status != VCOS_SUCCESS)
-   {
-      vcos_semaphore_delete(&private->action_sema);
-      return MMAL_ENOMEM;
-   }
-
-   vcos_thread_attr_init(&attrs);
-   vcos_thread_attr_setpriority(&attrs,
-                                private->private.priority);
-   status = vcos_thread_create(&private->action_thread, component->name, &attrs,
-                               mmal_component_action_thread_func, component);
-   if (status != VCOS_SUCCESS)
-   {
-      vcos_mutex_delete(&private->action_mutex);
-      vcos_semaphore_delete(&private->action_sema);
-      return MMAL_ENOMEM;
-   }
-
-   private->pf_action = pf_action;
-   return MMAL_SUCCESS;
-}
-
-/** De-registers the current action with the core */
-MMAL_STATUS_T mmal_component_action_deregister(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-
-   if (!private->pf_action)
-      return MMAL_EINVAL;
-
-   private->action_quit = 1;
-   vcos_semaphore_post(&private->action_sema);
-   vcos_thread_join(&private->action_thread, NULL);
-   vcos_semaphore_delete(&private->action_sema);
-   vcos_mutex_delete(&private->action_mutex);
-   private->pf_action = NULL;
-   private->action_quit = 0;
-   return MMAL_SUCCESS;
-}
-
-/** Triggers a registered action */
-MMAL_STATUS_T mmal_component_action_trigger(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-
-   if (!private->pf_action)
-      return MMAL_EINVAL;
-
-   vcos_semaphore_post(&private->action_sema);
-   return MMAL_SUCCESS;
-}
-
-/** Lock an action to prevent it from running */
-MMAL_STATUS_T mmal_component_action_lock(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-
-   if (!private->pf_action)
-      return MMAL_EINVAL;
-
-   vcos_mutex_lock(&private->action_mutex);
-   return MMAL_SUCCESS;
-}
-
-/** Unlock an action to allow it to run again */
-MMAL_STATUS_T mmal_component_action_unlock(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_CORE_PRIVATE_T *private = (MMAL_COMPONENT_CORE_PRIVATE_T *)component->priv;
-
-   if (!private->pf_action)
-      return MMAL_EINVAL;
-
-   vcos_mutex_unlock(&private->action_mutex);
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************
- * Initialisation / Deinitialisation of the MMAL core
- *****************************************************************************/
-static void mmal_core_init_once(void)
-{
-   vcos_mutex_create(&mmal_core_lock, VCOS_FUNCTION);
-}
-
-static void mmal_core_init(void)
-{
-   static VCOS_ONCE_T once = VCOS_ONCE_INIT;
-   vcos_init();
-   vcos_once(&once, mmal_core_init_once);
-
-   vcos_mutex_lock(&mmal_core_lock);
-   if (mmal_core_refcount++)
-   {
-      vcos_mutex_unlock(&mmal_core_lock);
-      return;
-   }
-
-   mmal_logging_init();
-   vcos_mutex_unlock(&mmal_core_lock);
-}
-
-static void mmal_core_deinit(void)
-{
-   vcos_mutex_lock(&mmal_core_lock);
-   if (!mmal_core_refcount || --mmal_core_refcount)
-   {
-      vcos_mutex_unlock(&mmal_core_lock);
-      return;
-   }
-
-   mmal_logging_deinit();
-   vcos_mutex_unlock(&mmal_core_lock);
-   vcos_deinit();
-}
-
-/*****************************************************************************
- * Supplier support
- *****************************************************************************/
-
-/** a component supplier gets passed a string and returns a
-  * component (if it can) based on that string.
-  */
-
-#define SUPPLIER_PREFIX_LEN 32
-typedef struct MMAL_COMPONENT_SUPPLIER_T
-{
-   struct MMAL_COMPONENT_SUPPLIER_T *next;
-   MMAL_COMPONENT_SUPPLIER_FUNCTION_T create;
-   char prefix[SUPPLIER_PREFIX_LEN];
-} MMAL_COMPONENT_SUPPLIER_T;
-
-/** List of component suppliers.
-  *
-  * Does not need to be thread-safe if we assume that suppliers
-  * can never be removed.
-  */
-static MMAL_COMPONENT_SUPPLIER_T *suppliers;
-
-/** Create an instance of a component  */
-static MMAL_STATUS_T mmal_component_supplier_create(const char *name, MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_SUPPLIER_T *supplier = suppliers;
-   MMAL_STATUS_T status = MMAL_ENOSYS;
-   const char *dot = strchr(name, '.');
-   size_t dot_size = dot ? dot - name : (int)strlen(name);
-
-   /* walk list of suppliers to see if any can create this component */
-   while (supplier)
-   {
-      if (strlen(supplier->prefix) == dot_size && !memcmp(supplier->prefix, name, dot_size))
-      {
-         status = supplier->create(name, component);
-         if (status == MMAL_SUCCESS)
-            break;
-      }
-      supplier = supplier->next;
-   }
-   return status;
-}
-
-void mmal_component_supplier_register(const char *prefix,
-   MMAL_COMPONENT_SUPPLIER_FUNCTION_T create_fn)
-{
-   MMAL_COMPONENT_SUPPLIER_T *supplier = vcos_calloc(1,sizeof(*supplier),NULL);
-
-   LOG_TRACE("prefix %s fn %p", (prefix ? prefix : "NULL"), create_fn);
-
-   if (vcos_verify(supplier))
-   {
-      supplier->create = create_fn;
-      strncpy(supplier->prefix, prefix, SUPPLIER_PREFIX_LEN);
-      supplier->prefix[SUPPLIER_PREFIX_LEN-1] = '\0';
-
-      supplier->next = suppliers;
-      suppliers = supplier;
-   }
-   else
-   {
-      LOG_ERROR("no memory for supplier registry entry");
-   }
-}
-
-MMAL_DESTRUCTOR(mmal_component_supplier_destructor);
-void mmal_component_supplier_destructor(void)
-{
-   MMAL_COMPONENT_SUPPLIER_T *supplier = suppliers;
-
-   /* walk list of suppliers and free associated memory */
-   while (supplier)
-   {
-      MMAL_COMPONENT_SUPPLIER_T *current = supplier;
-      supplier = supplier->next;
-      vcos_free(current);
-   }
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component_private.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component_private.h
deleted file mode 100644
index 6699a02..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_component_private.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_COMPONENT_PRIVATE_H
-#define MMAL_COMPONENT_PRIVATE_H
-
-#define MMAL_VIDEO_DECODE  "video_decode"
-#define MMAL_VIDEO_ENCODE  "video_encode"
-#define MMAL_VIDEO_RENDER  "video_render"
-#define MMAL_AUDIO_DECODE  "audio_decode"
-#define MMAL_AUDIO_ENCODE  "audio_encode"
-#define MMAL_AUDIO_RENDER  "audio_render"
-#define MMAL_CAMERA        "camera"
-
-#if defined(__GNUC__) && (__GNUC__ > 2)
-# define MMAL_CONSTRUCTOR(func) void __attribute__((constructor,used)) func(void)
-# define MMAL_DESTRUCTOR(func) void __attribute__((destructor,used)) func(void)
-#else
-# define MMAL_CONSTRUCTOR(func) void func(void)
-# define MMAL_DESTRUCTOR(func) void func(void)
-#endif
-
-#include "mmal.h"
-#include "mmal_component.h"
-
-/** Definition of a component. */
-struct MMAL_COMPONENT_PRIVATE_T
-{
-   /** Pointer to the private data of the component module in use */
-   struct MMAL_COMPONENT_MODULE_T *module;
-
-   MMAL_STATUS_T (*pf_enable)(MMAL_COMPONENT_T *component);
-   MMAL_STATUS_T (*pf_disable)(MMAL_COMPONENT_T *component);
-   MMAL_STATUS_T (*pf_destroy)(MMAL_COMPONENT_T *component);
-
-   /** Pool of event buffer headers, for sending events from component to client. */
-   MMAL_POOL_T *event_pool;
-
-   /** Reference counting of the component */
-   int refcount;
-   /** Reference counting of the ports. Component won't be destroyed until this
-    * goes to 0 */
-   int refcount_ports;
-
-   /** Priority associated with the 'action thread' for this component, when
-    * such action thread is applicable. */
-   int priority;
-};
-
-/** Set a generic component control parameter.
-  *
-  * @param control_port control port of component on which to set the parameter.
-  * @param param        parameter to be set.
-  * @return MMAL_SUCCESS or another status on error.
-  */
-MMAL_STATUS_T mmal_component_parameter_set(MMAL_PORT_T *control_port,
-                                           const MMAL_PARAMETER_HEADER_T *param);
-
-/** Get a generic component control parameter.
-  *
-  * @param contorl_port control port of component from which to get the parameter.
-  * @param param        parameter to be retrieved.
-  * @return MMAL_SUCCESS or another status on error.
-  */
-MMAL_STATUS_T mmal_component_parameter_get(MMAL_PORT_T *control_port,
-                                           MMAL_PARAMETER_HEADER_T *param);
-
-/** Registers an action with the core.
-  * The MMAL core allows components to register an action which will be run
-  * from a separate thread context when the action is explicitly triggered by
-  * the component.
-  *
-  * @param component    component registering the action.
-  * @param action       action to register.
-  * @return MMAL_SUCCESS or another status on error.
-  */
-MMAL_STATUS_T mmal_component_action_register(MMAL_COMPONENT_T *component,
-                                             void (*pf_action)(MMAL_COMPONENT_T *));
-
-/** De-registers the current action registered with the core.
-  *
-  * @param component    component de-registering the action.
-  * @return MMAL_SUCCESS or another status on error.
-  */
-MMAL_STATUS_T mmal_component_action_deregister(MMAL_COMPONENT_T *component);
-
-/** Triggers a registered action.
-  * Explicitly triggers an action registered by a component.
-  *
-  * @param component    component on which to trigger the action.
-  * @return MMAL_SUCCESS or another status on error.
-  */
-MMAL_STATUS_T mmal_component_action_trigger(MMAL_COMPONENT_T *component);
-
-/** Lock an action to prevent it from running.
-  * Allows a component to make sure no action is running while the lock is taken.
-  *
-  * @param component    component.
-  * @return MMAL_SUCCESS or another status on error.
-  */
-MMAL_STATUS_T mmal_component_action_lock(MMAL_COMPONENT_T *component);
-
-/** Unlock an action to allow it to run again.
-  *
-  * @param component    component.
-  * @return MMAL_SUCCESS or another status on error.
-  */
-MMAL_STATUS_T mmal_component_action_unlock(MMAL_COMPONENT_T *component);
-
-/** Prototype used by components to register themselves to the supplier. */
-typedef MMAL_STATUS_T (*MMAL_COMPONENT_SUPPLIER_FUNCTION_T)(const char *name,
-                                                            MMAL_COMPONENT_T *component);
-
-/** Create an instance of a component given a constructor for the component.
- * This allows the creation of client-side components which haven't been registered with the core.
- * See \ref mmal_component_create for the public interface used to create components.
- *
- * @param name name assigned to the component by the client
- * @param constructor constructor function for the component
- * @param constructor_private private data for the constructor
- * @param component returned component
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_component_create_with_constructor(const char *name,
-   MMAL_STATUS_T (*constructor)(const char *name, MMAL_COMPONENT_T *),
-   struct MMAL_COMPONENT_MODULE_T *constructor_private,
-   MMAL_COMPONENT_T **component);
-
-/** Register a component with the mmal component supplier.
-  *
-  * @param prefix     prefix for this supplier, e.g. "VC"
-  * @param create_fn  function which will instantiate a component given a name.
-  */
-void mmal_component_supplier_register(const char *prefix,
-                                      MMAL_COMPONENT_SUPPLIER_FUNCTION_T create_fn);
-
-#endif /* MMAL_COMPONENT_PRIVATE_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_core_private.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_core_private.h
deleted file mode 100644
index 8dc6cba..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_core_private.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_CORE_PRIVATE_H
-#define MMAL_CORE_PRIVATE_H
-
-/** Initialise the logging system.
-  */
-void mmal_logging_init(void);
-
-/** Deinitialise the logging system.
-  */
-void mmal_logging_deinit(void);
-
-#endif /* MMAL_CORE_PRIVATE_H */
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_events.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_events.c
deleted file mode 100644
index 4b5f58f..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_events.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "mmal_port_private.h"
-#include "mmal_buffer.h"
-#include "mmal_logging.h"
-
-MMAL_EVENT_FORMAT_CHANGED_T *mmal_event_format_changed_get(MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_EVENT_FORMAT_CHANGED_T *event;
-   MMAL_ES_FORMAT_T *format;
-   uint32_t size;
-
-   size = sizeof(MMAL_EVENT_FORMAT_CHANGED_T);
-   size += sizeof(MMAL_ES_FORMAT_T) + sizeof(MMAL_ES_SPECIFIC_FORMAT_T);
-
-   if (buffer->cmd != MMAL_EVENT_FORMAT_CHANGED || !buffer || buffer->length < size)
-      return 0;
-
-   event = (MMAL_EVENT_FORMAT_CHANGED_T *)buffer->data;
-   format = event->format = (MMAL_ES_FORMAT_T *)&event[1];
-   format->es = (MMAL_ES_SPECIFIC_FORMAT_T *)&format[1];
-   format->extradata = (uint8_t *)&format->es[1];
-   format->extradata_size = buffer->length - size;
-   return event;
-}
-
-MMAL_STATUS_T mmal_event_error_send(MMAL_COMPONENT_T *component, MMAL_STATUS_T error_status)
-{
-   MMAL_BUFFER_HEADER_T* event;
-   MMAL_STATUS_T status;
-
-   if(!component)
-   {
-      LOG_ERROR("invalid component");
-      return MMAL_EINVAL;
-   }
-
-   status = mmal_port_event_get(component->control, &event, MMAL_EVENT_ERROR);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("event not available for component %s %p, result %d", component->name, component, status);
-      return status;
-   }
-
-   event->length = sizeof(MMAL_STATUS_T);
-   *(MMAL_STATUS_T *)event->data = error_status;
-   mmal_port_event_send(component->control, event);
-
-   return MMAL_SUCCESS;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_format.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_format.c
deleted file mode 100644
index 71606ff..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_format.c
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal_types.h"
-#include "mmal_format.h"
-
-#define MMAL_ES_FORMAT_MAGIC MMAL_FOURCC('m','a','g','f')
-#define EXTRADATA_SIZE_DEFAULT 32
-#define EXTRADATA_SIZE_MAX (10*1024)
-
-typedef struct MMAL_ES_FORMAT_PRIVATE_T
-{
-   MMAL_ES_FORMAT_T format;
-   MMAL_ES_SPECIFIC_FORMAT_T es;
-
-   uint32_t magic;
-
-   unsigned int extradata_size;
-   uint8_t *extradata;
-
-   uint8_t buffer[EXTRADATA_SIZE_DEFAULT];
-
-} MMAL_ES_FORMAT_PRIVATE_T;
-
-/** Allocate a format structure */
-MMAL_ES_FORMAT_T *mmal_format_alloc(void)
-{
-   MMAL_ES_FORMAT_PRIVATE_T *private;
-
-   private = vcos_malloc(sizeof(*private), "mmal format");
-   if(!private) return 0;
-   memset(private, 0, sizeof(*private));
-
-   private->magic = MMAL_ES_FORMAT_MAGIC;
-   private->format.es = (void *)&private->es;
-   private->extradata_size = EXTRADATA_SIZE_DEFAULT;
-
-   return &private->format;
-}
-
-/** Free a format structure */
-void mmal_format_free(MMAL_ES_FORMAT_T *format)
-{
-   MMAL_ES_FORMAT_PRIVATE_T *private = (MMAL_ES_FORMAT_PRIVATE_T *)format;
-   vcos_assert(private->magic == MMAL_ES_FORMAT_MAGIC);
-   if(private->extradata) vcos_free(private->extradata);
-   vcos_free(private);
-}
-
-/** Copy a format structure */
-void mmal_format_copy(MMAL_ES_FORMAT_T *fmt_dst, MMAL_ES_FORMAT_T *fmt_src)
-{
-   void *backup = fmt_dst->es;
-   *fmt_dst->es = *fmt_src->es;
-   *fmt_dst = *fmt_src;
-   fmt_dst->es = backup;
-   fmt_dst->extradata = 0;
-   fmt_dst->extradata_size = 0;
-}
-
-/** Full copy of a format structure (including extradata) */
-MMAL_STATUS_T mmal_format_full_copy(MMAL_ES_FORMAT_T *fmt_dst, MMAL_ES_FORMAT_T *fmt_src)
-{
-   mmal_format_copy(fmt_dst, fmt_src);
-
-   if (fmt_src->extradata_size)
-   {
-      MMAL_STATUS_T status = mmal_format_extradata_alloc(fmt_dst, fmt_src->extradata_size);
-      if (status != MMAL_SUCCESS)
-         return status;
-      fmt_dst->extradata_size = fmt_src->extradata_size;
-      memcpy(fmt_dst->extradata, fmt_src->extradata, fmt_src->extradata_size);
-   }
-   return MMAL_SUCCESS;
-}
-
-/** Compare 2 format structures */
-uint32_t mmal_format_compare(MMAL_ES_FORMAT_T *fmt1, MMAL_ES_FORMAT_T *fmt2)
-{
-   MMAL_VIDEO_FORMAT_T *video1, *video2;
-   uint32_t result = 0;
-
-   if (fmt1->type != fmt2->type)
-      return MMAL_ES_FORMAT_COMPARE_FLAG_TYPE;
-
-   if (fmt1->encoding != fmt2->encoding)
-      result |= MMAL_ES_FORMAT_COMPARE_FLAG_ENCODING;
-   if (fmt1->bitrate != fmt2->bitrate)
-      result |= MMAL_ES_FORMAT_COMPARE_FLAG_BITRATE;
-   if (fmt1->flags != fmt2->flags)
-      result |= MMAL_ES_FORMAT_COMPARE_FLAG_FLAGS;
-   if (fmt1->extradata_size != fmt2->extradata_size ||
-       (fmt1->extradata_size && (!fmt1->extradata || !fmt2->extradata)) ||
-       memcmp(fmt1->extradata, fmt2->extradata, fmt1->extradata_size))
-      result |= MMAL_ES_FORMAT_COMPARE_FLAG_EXTRADATA;
-
-   /* Compare the ES specific information */
-   switch (fmt1->type)
-   {
-   case MMAL_ES_TYPE_VIDEO:
-      video1 = &fmt1->es->video;
-      video2 = &fmt2->es->video;
-      if (video1->width != video2->width || video1->height != video2->height)
-         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_RESOLUTION;
-      if (memcmp(&video1->crop, &video2->crop, sizeof(video1->crop)))
-         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_CROPPING;
-      if (memcmp(&video1->par, &video2->par, sizeof(video1->par)))
-         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_ASPECT_RATIO;
-      if (memcmp(&video1->frame_rate, &video2->frame_rate, sizeof(video1->frame_rate)))
-         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_FRAME_RATE;
-      if (video1->color_space != video2->color_space)
-         result |= MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_COLOR_SPACE;
-      /* coverity[overrun-buffer-arg] We're comparing the rest of the video format structure */
-      if (memcmp(((char*)&video1->color_space) + sizeof(video1->color_space),
-                 ((char*)&video2->color_space) + sizeof(video2->color_space),
-                 sizeof(*video1) - offsetof(MMAL_VIDEO_FORMAT_T, color_space) - sizeof(video1->color_space)))
-         result |= MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER;
-      break;
-   case MMAL_ES_TYPE_AUDIO:
-      if (memcmp(fmt1->es, fmt2->es, sizeof(MMAL_AUDIO_FORMAT_T)))
-         result |= MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER;
-      break;
-   case MMAL_ES_TYPE_SUBPICTURE:
-      if (memcmp(fmt1->es, fmt2->es, sizeof(MMAL_SUBPICTURE_FORMAT_T)))
-         result |= MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER;
-      break;
-   default:
-      break;
-   }
-
-   return result;
-}
-
-/** */
-MMAL_STATUS_T mmal_format_extradata_alloc(MMAL_ES_FORMAT_T *format, unsigned int size)
-{
-   MMAL_ES_FORMAT_PRIVATE_T *private = (MMAL_ES_FORMAT_PRIVATE_T *)format;
-
-   /* Sanity check the size requested */
-   if(size > EXTRADATA_SIZE_MAX)
-      return MMAL_EINVAL;
-
-   /* Allocate memory if needed */
-   if(private->extradata_size < size)
-   {
-      if(private->extradata) vcos_free(private->extradata);
-      private->extradata = vcos_malloc(size, "mmal format extradata");
-      if(!private->extradata)
-         return MMAL_ENOMEM;
-      private->extradata_size = size;
-   }
-
-   /* Set the fields in the actual format structure */
-   if(private->extradata) private->format.extradata = private->extradata;
-   else private->format.extradata = private->buffer;
-
-   return MMAL_SUCCESS;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_logging.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_logging.c
deleted file mode 100644
index e05bc92..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_logging.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "mmal_logging.h"
-#include "core/mmal_core_private.h"
-
-VCOS_LOG_CAT_T mmal_log_category;
-static VCOS_LOG_LEVEL_T mmal_log_level = VCOS_LOG_ERROR;
-
-void mmal_logging_init(void)
-{
-   vcos_log_set_level(VCOS_LOG_CATEGORY, mmal_log_level);
-   vcos_log_register("mmal", VCOS_LOG_CATEGORY);
-}
-
-void mmal_logging_deinit(void)
-{
-   mmal_log_level = mmal_log_category.level;
-   vcos_log_unregister(VCOS_LOG_CATEGORY);
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_pool.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_pool.c
deleted file mode 100644
index 1eac85f..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_pool.c
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "mmal_pool.h"
-#include "core/mmal_buffer_private.h"
-#include "mmal_logging.h"
-
-/** Definition of a pool */
-typedef struct MMAL_POOL_PRIVATE_T
-{
-   MMAL_POOL_T pool; /**< Actual pool */
-
-   MMAL_POOL_BH_CB_T cb; /**< Buffer header release callback */
-   void *userdata;       /**< User provided data to pass with callback */
-
-   mmal_pool_allocator_alloc_t allocator_alloc; /**< Allocator for the payload buffers */
-   mmal_pool_allocator_free_t allocator_free;   /**< Allocator for the payload buffers */
-   void *allocator_context;                     /**< Context for the allocator */
-
-   unsigned int header_size; /**< Size of an initialised buffer header structure */
-   unsigned int payload_size;
-
-   unsigned int headers_alloc_num; /**< Number of buffer headers allocated as part of the private structure */
-
-} MMAL_POOL_PRIVATE_T;
-
-#define ROUND_UP(s,align) ((((unsigned long)(s)) & ~((align)-1)) + (align))
-#define ALIGN  8
-
-static void mmal_pool_buffer_header_release(MMAL_BUFFER_HEADER_T *header);
-
-static void *mmal_pool_allocator_default_alloc(void *context, uint32_t size)
-{
-   MMAL_PARAM_UNUSED(context);
-   return vcos_malloc(size, "mmal_pool payload");
-}
-
-static void mmal_pool_allocator_default_free(void *context, void *mem)
-{
-   MMAL_PARAM_UNUSED(context);
-   vcos_free(mem);
-}
-
-static MMAL_STATUS_T mmal_pool_initialise_buffer_headers(MMAL_POOL_T *pool, unsigned int headers,
-                                                         MMAL_BOOL_T reinitialise)
-{
-   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
-   MMAL_BUFFER_HEADER_T *header;
-   uint8_t *payload = NULL;
-   unsigned int i;
-
-   header = (MMAL_BUFFER_HEADER_T *)((uint8_t *)pool->header + ROUND_UP(sizeof(void *)*headers,ALIGN));
-
-   for (i = 0; i < headers; i++)
-   {
-      if (reinitialise)
-         header = mmal_buffer_header_initialise(header, private->header_size);
-
-      if (private->payload_size && private->allocator_alloc)
-      {
-         LOG_TRACE("allocating %u bytes for payload %u/%u", private->payload_size, i, headers);
-         payload = (uint8_t*)private->allocator_alloc(private->allocator_context, private->payload_size);
-         if (! payload)
-         {
-            LOG_ERROR("failed to allocate payload %u/%u", i, headers);
-            return MMAL_ENOMEM;
-         }
-      }
-      else
-      {
-         if (header->priv->pf_payload_free && header->priv->payload && header->priv->payload_size)
-         {
-            LOG_TRACE("freeing %u bytes for payload %u/%u", header->priv->payload_size, i, headers);
-            header->priv->pf_payload_free(header->priv->payload_context, header->priv->payload);
-         }
-      }
-      header->data = payload;
-      header->alloc_size = private->payload_size;
-      header->priv->pf_release = mmal_pool_buffer_header_release;
-      header->priv->owner = (void *)pool;
-      header->priv->refcount = 1;
-      header->priv->payload = payload;
-      header->priv->payload_context = private->allocator_context;
-      header->priv->pf_payload_free = private->allocator_free;
-      header->priv->payload_size = private->payload_size;
-      pool->header[i] = header;
-      pool->headers_num = i+1;
-      header = (MMAL_BUFFER_HEADER_T *)((uint8_t*)header + private->header_size);
-   }
-
-   return MMAL_SUCCESS;
-}
-
-/** Create a pool of MMAL_BUFFER_HEADER_T */
-MMAL_POOL_T *mmal_pool_create(unsigned int headers, uint32_t payload_size)
-{
-   return mmal_pool_create_with_allocator(headers, payload_size, NULL,
-             mmal_pool_allocator_default_alloc, mmal_pool_allocator_default_free);
-}
-
-/** Create a pool of MMAL_BUFFER_HEADER_T */
-MMAL_POOL_T *mmal_pool_create_with_allocator(unsigned int headers, uint32_t payload_size,
-                              void *allocator_context, mmal_pool_allocator_alloc_t allocator_alloc,
-                              mmal_pool_allocator_free_t allocator_free)
-{
-   unsigned int i, headers_array_size, header_size, pool_size;
-   MMAL_POOL_PRIVATE_T *private;
-   MMAL_BUFFER_HEADER_T **array;
-   MMAL_POOL_T *pool;
-   MMAL_QUEUE_T *queue;
-
-   queue = mmal_queue_create();
-   if (!queue)
-   {
-      LOG_ERROR("failed to create queue");
-      return NULL;
-   }
-
-   /* Calculate how much memory we need */
-   pool_size = ROUND_UP(sizeof(MMAL_POOL_PRIVATE_T),ALIGN);
-   headers_array_size = ROUND_UP(sizeof(void *)*headers,ALIGN);
-   header_size = ROUND_UP(mmal_buffer_header_size(0),ALIGN);
-
-   LOG_TRACE("allocating %u + %u + %u * %u bytes for pool",
-             pool_size, headers_array_size, header_size, headers);
-   private = vcos_calloc(pool_size, 1, "MMAL pool");
-   array = vcos_calloc(headers_array_size + header_size * headers, 1, "MMAL buffer headers");
-   if (!private || !array)
-   {
-      LOG_ERROR("failed to allocate pool");
-      if (private) vcos_free(private);
-      if (array) vcos_free(array);
-      mmal_queue_destroy(queue);
-      return NULL;
-   }
-   pool = &private->pool;
-   pool->queue = queue;
-   pool->header = (MMAL_BUFFER_HEADER_T **)array;
-   private->header_size = header_size;
-   private->payload_size = payload_size;
-   private->headers_alloc_num = headers;
-
-   /* Use default allocators if none has been specified by client */
-   if (!allocator_alloc || !allocator_free)
-   {
-      allocator_alloc = mmal_pool_allocator_default_alloc;
-      allocator_free = mmal_pool_allocator_default_free;
-      allocator_context = NULL;
-   }
-
-   /* Keep reference to the allocator to allow resizing the payloads at a later point */
-   private->allocator_alloc = allocator_alloc;
-   private->allocator_free = allocator_free;
-   private->allocator_context = allocator_context;
-
-   if (mmal_pool_initialise_buffer_headers(pool, headers, 1) != MMAL_SUCCESS)
-   {
-      mmal_pool_destroy(pool);
-      return NULL;
-   }
-
-   /* Add all the headers to the queue */
-   for (i = 0; i < pool->headers_num; i++)
-      mmal_queue_put(queue, pool->header[i]);
-
-   return pool;
-}
-
-/** Destroy a pool of MMAL_BUFFER_HEADER_T */
-void mmal_pool_destroy(MMAL_POOL_T *pool)
-{
-   unsigned int i;
-
-   if (!pool)
-      return;
-
-   /* If the payload_size is non-zero then the buffer header payload
-    * must be freed. Otherwise it is the caller's responsibility. */
-   for (i = 0; i < pool->headers_num; ++i)
-   {
-      MMAL_BUFFER_HEADER_PRIVATE_T* priv = pool->header[i]->priv;
-
-      if (priv->pf_payload_free && priv->payload && priv->payload_size)
-         priv->pf_payload_free(priv->payload_context, priv->payload);
-   }
-
-   if (pool->header)
-      vcos_free(pool->header);
-
-   if(pool->queue) mmal_queue_destroy(pool->queue);
-   vcos_free(pool);
-}
-
-/** Resize a pool of MMAL_BUFFER_HEADER_T */
-MMAL_STATUS_T mmal_pool_resize(MMAL_POOL_T *pool, unsigned int headers, uint32_t payload_size)
-{
-   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
-   unsigned int i;
-
-   if (!private || !headers)
-      return MMAL_EINVAL;
-
-   /* Check if anything needs to be done */
-   if (headers == pool->headers_num && payload_size == private->payload_size)
-      return MMAL_SUCCESS;
-
-   /* Remove all the headers from the queue */
-   for (i = 0; i < pool->headers_num; i++)
-      mmal_queue_get(pool->queue);
-
-   /* Start by freeing the current payloads */
-   private->payload_size = 0;
-   mmal_pool_initialise_buffer_headers(pool, pool->headers_num, 0);
-   pool->headers_num = 0;
-
-   /* Check if we need to reallocate the buffer headers themselves */
-   if (headers > private->headers_alloc_num)
-   {
-      private->headers_alloc_num = 0;
-      if (pool->header)
-         vcos_free(pool->header);
-      pool->header =
-         vcos_calloc(private->header_size * headers + ROUND_UP(sizeof(void *)*headers,ALIGN),
-                     1, "MMAL buffer headers");
-      if (!pool->header)
-         return MMAL_ENOMEM;
-      private->headers_alloc_num = headers;
-   }
-
-   /* Allocate the new payloads */
-   private->payload_size = payload_size;
-   mmal_pool_initialise_buffer_headers(pool, headers, 1);
-
-   /* Add all the headers to the queue */
-   for (i = 0; i < pool->headers_num; i++)
-      mmal_queue_put(pool->queue, pool->header[i]);
-
-   return MMAL_SUCCESS;
-}
-
-/** Buffer header release callback.
- * Call out to a further client callback and put the buffer back in the queue
- * so it can be reused, unless the client callback prevents it. */
-static void mmal_pool_buffer_header_release(MMAL_BUFFER_HEADER_T *header)
-{
-   MMAL_POOL_T *pool = (MMAL_POOL_T *)header->priv->owner;
-   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
-   MMAL_BOOL_T queue_buffer = 1;
-
-   header->priv->refcount = 1;
-   if(private->cb)
-      queue_buffer = private->cb(pool, header, private->userdata);
-   if (queue_buffer)
-      mmal_queue_put(pool->queue, header);
-}
-
-/** Set a buffer header release callback to the pool */
-void mmal_pool_callback_set(MMAL_POOL_T *pool, MMAL_POOL_BH_CB_T cb, void *userdata)
-{
-   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
-   private->cb = cb;
-   private->userdata = userdata;
-}
-
-/* Set a pre-release callback for all buffer headers in the pool */
-void mmal_pool_pre_release_callback_set(MMAL_POOL_T *pool, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata)
-{
-   unsigned int i;
-   MMAL_POOL_PRIVATE_T *private = (MMAL_POOL_PRIVATE_T *)pool;
-   MMAL_BUFFER_HEADER_T *header =
-         (MMAL_BUFFER_HEADER_T*)((uint8_t*)pool->header + ROUND_UP(sizeof(void*)*pool->headers_num,ALIGN));
-
-   for (i = 0; i < pool->headers_num; ++i)
-   {
-      mmal_buffer_header_pre_release_cb_set(header, cb, userdata);
-      header = (MMAL_BUFFER_HEADER_T *)((uint8_t*)header + private->header_size);
-   }
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port.c
deleted file mode 100644
index 539ac8e..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port.c
+++ /dev/null
@@ -1,1490 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "util/mmal_util.h"
-#include "core/mmal_component_private.h"
-#include "core/mmal_port_private.h"
-#include "interface/vcos/vcos.h"
-#include "mmal_logging.h"
-#include "interface/mmal/util/mmal_util.h"
-#include "interface/mmal/mmal_parameters.h"
-#include <stdio.h>
-
-#ifdef _VIDEOCORE
-#include "vcfw/rtos/common/rtos_common_mem.h" /* mem_alloc */
-#endif
-
-/** Only collect port stats if enabled in build. Performance could be
- * affected on an ARM since gettimeofday() involves a system call.
- */
-#if defined(MMAL_COLLECT_PORT_STATS)
-# define MMAL_COLLECT_PORT_STATS_ENABLED 1
-#else
-# define MMAL_COLLECT_PORT_STATS_ENABLED 0
-#endif
-
-static MMAL_STATUS_T mmal_port_private_parameter_get(MMAL_PORT_T *port,
-                                                     MMAL_PARAMETER_HEADER_T *param);
-
-static MMAL_STATUS_T mmal_port_private_parameter_set(MMAL_PORT_T *port,
-                                                     const MMAL_PARAMETER_HEADER_T *param);
-
-/* Define this if you want to log all buffer transfers */
-//#define ENABLE_MMAL_EXTRA_LOGGING
-
-/** Definition of the core's private structure for a port. */
-typedef struct MMAL_PORT_PRIVATE_CORE_T
-{
-   VCOS_MUTEX_T lock; /**< Used to lock access to the port */
-   VCOS_MUTEX_T send_lock; /**< Used to lock access while sending buffer to the port */
-   VCOS_MUTEX_T stats_lock; /**< Used to lock access to the stats */
-   VCOS_MUTEX_T connection_lock; /**< Used to lock access to a connection */
-
-   /** Callback set by client to call when buffer headers need to be returned */
-   MMAL_PORT_BH_CB_T buffer_header_callback;
-
-   /** Keeps track of the number of buffer headers currently in transit in this port */
-   int32_t transit_buffer_headers;
-   VCOS_MUTEX_T transit_lock;
-   VCOS_SEMAPHORE_T transit_sema;
-
-   /** Copy of the public port format pointer, to detect accidental overwrites */
-   MMAL_ES_FORMAT_T* format_ptr_copy;
-
-   /** Port to which this port is connected, or NULL if disconnected */
-   MMAL_PORT_T* connected_port;
-
-   MMAL_BOOL_T core_owns_connection; /**< Connection is handled by the core */
-
-   /** Pool of buffers used between connected ports - output port only */
-   MMAL_POOL_T* pool_for_connection;
-
-   /** Indicates whether the port is paused or not. Buffers received on
-    * a paused port will be queued instead of being sent to the component. */
-   MMAL_BOOL_T is_paused;
-   /** Queue for buffers received from the client when in paused state */
-   MMAL_BUFFER_HEADER_T* queue_first;
-   /** Queue for buffers received from the client when in paused state */
-   MMAL_BUFFER_HEADER_T** queue_last;
-
-   /** Per-port statistics collected directly by the MMAL core */
-   MMAL_CORE_PORT_STATISTICS_T stats;
-
-   char *name; /**< Port name */
-   unsigned int name_size; /** Size of the memory area reserved for the name string */
-} MMAL_PORT_PRIVATE_CORE_T;
-
-/*****************************************************************************
- * Static declarations
- *****************************************************************************/
-static MMAL_STATUS_T mmal_port_enable_internal(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb);
-static MMAL_STATUS_T mmal_port_disable_internal(MMAL_PORT_T *port);
-
-static MMAL_STATUS_T mmal_port_connection_enable(MMAL_PORT_T *port, MMAL_PORT_T *connected_port);
-static MMAL_STATUS_T mmal_port_connection_disable(MMAL_PORT_T *port, MMAL_PORT_T *connected_port);
-static MMAL_STATUS_T mmal_port_connection_start(MMAL_PORT_T *port, MMAL_PORT_T *connected_port);
-static MMAL_STATUS_T mmal_port_populate_from_pool(MMAL_PORT_T* port, MMAL_POOL_T* pool);
-static MMAL_STATUS_T mmal_port_populate_clock_ports(MMAL_PORT_T* output, MMAL_PORT_T* input, MMAL_POOL_T* pool);
-static MMAL_STATUS_T mmal_port_connect_default(MMAL_PORT_T *port, MMAL_PORT_T *other_port);
-static void mmal_port_connected_input_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
-static void mmal_port_connected_output_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
-static MMAL_BOOL_T mmal_port_connected_pool_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata);
-
-static void mmal_port_name_update(MMAL_PORT_T *port);
-static void mmal_port_update_port_stats(MMAL_PORT_T *port, MMAL_CORE_STATS_DIR direction);
-
-/*****************************************************************************/
-
-/* Macros used to make the port API thread safe */
-#define LOCK_PORT(a) vcos_mutex_lock(&(a)->priv->core->lock);
-#define UNLOCK_PORT(a) vcos_mutex_unlock(&(a)->priv->core->lock);
-
-/* Macros used to make the buffer sending / flushing thread safe */
-#define LOCK_SENDING(a) vcos_mutex_lock(&(a)->priv->core->send_lock);
-#define UNLOCK_SENDING(a) vcos_mutex_unlock(&(a)->priv->core->send_lock);
-
-/* Macros used to make the port connection API thread safe */
-#define LOCK_CONNECTION(a) vcos_mutex_lock(&(a)->priv->core->connection_lock);
-#define UNLOCK_CONNECTION(a) vcos_mutex_unlock(&(a)->priv->core->connection_lock);
-
-/* Macros used to make mmal_port_disable() blocking until all
- * the buffers have been sent back to the client */
-#define IN_TRANSIT_INCREMENT(a) \
-   vcos_mutex_lock(&(a)->priv->core->transit_lock); \
-   if (!(a)->priv->core->transit_buffer_headers++) \
-      vcos_semaphore_wait(&(a)->priv->core->transit_sema); \
-   vcos_mutex_unlock(&(a)->priv->core->transit_lock)
-#define IN_TRANSIT_DECREMENT(a) \
-   vcos_mutex_lock(&(a)->priv->core->transit_lock); \
-   if (!--(a)->priv->core->transit_buffer_headers) \
-      vcos_semaphore_post(&(a)->priv->core->transit_sema); \
-   vcos_mutex_unlock(&(a)->priv->core->transit_lock)
-#define IN_TRANSIT_WAIT(a) \
-   vcos_semaphore_wait(&(a)->priv->core->transit_sema); \
-   vcos_semaphore_post(&(a)->priv->core->transit_sema)
-#define IN_TRANSIT_COUNT(a) \
-   (a)->priv->core->transit_buffer_headers
-
-#define PORT_NAME_FORMAT "%s:%.2222s:%i%c%4.4s)"
-
-/*****************************************************************************/
-
-/** Allocate a port structure */
-MMAL_PORT_T *mmal_port_alloc(MMAL_COMPONENT_T *component, MMAL_PORT_TYPE_T type, unsigned int extra_size)
-{
-   MMAL_PORT_T *port;
-   MMAL_PORT_PRIVATE_CORE_T *core;
-   unsigned int name_size = strlen(component->name) + sizeof(PORT_NAME_FORMAT);
-   unsigned int size = sizeof(*port) + sizeof(MMAL_PORT_PRIVATE_T) +
-      sizeof(MMAL_PORT_PRIVATE_CORE_T) + name_size + extra_size;
-   MMAL_BOOL_T lock = 0, lock_send = 0, lock_transit = 0, sema_transit = 0;
-   MMAL_BOOL_T lock_stats = 0, lock_connection = 0;
-
-   LOG_TRACE("component:%s type:%u extra:%u", component->name, type, extra_size);
-
-   port = vcos_calloc(1, size, "mmal port");
-   if (!port)
-   {
-      LOG_ERROR("failed to allocate port, size %u", size);
-      return 0;
-   }
-   port->type = type;
-
-   port->priv = (MMAL_PORT_PRIVATE_T *)(port+1);
-   port->priv->core = core = (MMAL_PORT_PRIVATE_CORE_T *)(port->priv+1);
-   if (extra_size)
-      port->priv->module = (struct MMAL_PORT_MODULE_T *)(port->priv->core+1);
-   port->component = component;
-   port->name = core->name = ((char *)(port->priv->core+1)) + extra_size;
-   core->name_size = name_size;
-   mmal_port_name_update(port);
-   core->queue_last = &core->queue_first;
-
-   port->priv->pf_connect = mmal_port_connect_default;
-
-   lock = vcos_mutex_create(&port->priv->core->lock, "mmal port lock") == VCOS_SUCCESS;
-   lock_send = vcos_mutex_create(&port->priv->core->send_lock, "mmal port send lock") == VCOS_SUCCESS;
-   lock_transit = vcos_mutex_create(&port->priv->core->transit_lock, "mmal port transit lock") == VCOS_SUCCESS;
-   sema_transit = vcos_semaphore_create(&port->priv->core->transit_sema, "mmal port transit sema", 1) == VCOS_SUCCESS;
-   lock_stats = vcos_mutex_create(&port->priv->core->stats_lock, "mmal stats lock") == VCOS_SUCCESS;
-   lock_connection = vcos_mutex_create(&port->priv->core->connection_lock, "mmal connection lock") == VCOS_SUCCESS;
-
-   if (!lock || !lock_send || !lock_transit || !sema_transit || !lock_stats || !lock_connection)
-   {
-      LOG_ERROR("%s: failed to create sync objects (%u,%u,%u,%u,%u,%u)",
-            port->name, lock, lock_send, lock_transit, sema_transit, lock_stats, lock_connection);
-      goto error;
-   }
-
-   port->format = mmal_format_alloc();
-   if (!port->format)
-   {
-      LOG_ERROR("%s: failed to allocate format object", port->name);
-      goto error;
-   }
-   port->priv->core->format_ptr_copy = port->format;
-
-   LOG_TRACE("%s: created at %p", port->name, port);
-   return port;
-
- error:
-   if (lock) vcos_mutex_delete(&port->priv->core->lock);
-   if (lock_send) vcos_mutex_delete(&port->priv->core->send_lock);
-   if (lock_transit) vcos_mutex_delete(&port->priv->core->transit_lock);
-   if (sema_transit) vcos_semaphore_delete(&port->priv->core->transit_sema);
-   if (lock_stats) vcos_mutex_delete(&port->priv->core->stats_lock);
-   if (lock_connection) vcos_mutex_delete(&port->priv->core->connection_lock);
-   if (port->format) mmal_format_free(port->format);
-   vcos_free(port);
-   return 0;
-}
-
-/** Free a port structure */
-void mmal_port_free(MMAL_PORT_T *port)
-{
-   LOG_TRACE("%s at %p", port ? port->name : "<invalid>", port);
-
-   if (!port)
-      return;
-
-   vcos_assert(port->format == port->priv->core->format_ptr_copy);
-   mmal_format_free(port->priv->core->format_ptr_copy);
-   vcos_mutex_delete(&port->priv->core->connection_lock);
-   vcos_mutex_delete(&port->priv->core->stats_lock);
-   vcos_semaphore_delete(&port->priv->core->transit_sema);
-   vcos_mutex_delete(&port->priv->core->transit_lock);
-   vcos_mutex_delete(&port->priv->core->send_lock);
-   vcos_mutex_delete(&port->priv->core->lock);
-   vcos_free(port);
-}
-
-/** Allocate an array of ports */
-MMAL_PORT_T **mmal_ports_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num,
-   MMAL_PORT_TYPE_T type, unsigned int extra_size)
-{
-   MMAL_PORT_T **ports;
-   unsigned int i;
-
-   ports = vcos_malloc(sizeof(MMAL_PORT_T *) * ports_num, "mmal ports");
-   if (!ports)
-      return 0;
-
-   for (i = 0; i < ports_num; i++)
-   {
-      ports[i] = mmal_port_alloc(component, type, extra_size);
-      if (!ports[i])
-         break;
-      ports[i]->index = i;
-      mmal_port_name_update(ports[i]);
-   }
-
-   if (i != ports_num)
-   {
-      for (ports_num = i, i = 0; i < ports_num; i++)
-         mmal_port_free(ports[i]);
-      vcos_free(ports);
-      return 0;
-   }
-
-   return ports;
-}
-
-/** Free an array of ports */
-void mmal_ports_free(MMAL_PORT_T **ports, unsigned int ports_num)
-{
-   unsigned int i;
-
-   for (i = 0; i < ports_num; i++)
-      mmal_port_free(ports[i]);
-   vcos_free(ports);
-}
-
-/** Set format of a port */
-MMAL_STATUS_T mmal_port_format_commit(MMAL_PORT_T *port)
-{
-   MMAL_STATUS_T status;
-   char encoding_string[16];
-
-   if (!port || !port->priv)
-   {
-      LOG_ERROR("invalid port (%p/%p)", port, port ? port->priv : NULL);
-      return MMAL_EINVAL;
-   }
-
-   if (port->format != port->priv->core->format_ptr_copy)
-   {
-      LOG_ERROR("%s: port format has been overwritten, resetting %p to %p",
-            port->name, port->format, port->priv->core->format_ptr_copy);
-      port->format = port->priv->core->format_ptr_copy;
-      return MMAL_EFAULT;
-   }
-
-   if (port->format->encoding == 0)
-      snprintf(encoding_string, sizeof(encoding_string), "<NO-FORMAT>");
-   else
-      snprintf(encoding_string, sizeof(encoding_string), "%4.4s", (char*)&port->format->encoding);
-
-   LOG_TRACE("%s(%i:%i) port %p format %i:%s",
-             port->component->name, (int)port->type, (int)port->index, port,
-             (int)port->format->type, encoding_string);
-
-   if (!port->priv->pf_set_format)
-   {
-      LOG_ERROR("%s: no component implementation", port->name);
-      return MMAL_ENOSYS;
-   }
-
-   LOCK_PORT(port);
-   status = port->priv->pf_set_format(port);
-   mmal_port_name_update(port);
-
-   /* Make sure the buffer size / num are sensible */
-   if (port->buffer_size < port->buffer_size_min)
-      port->buffer_size = port->buffer_size_min;
-   if (port->buffer_num < port->buffer_num_min)
-      port->buffer_num = port->buffer_num_min;
-   /* The output port settings might have changed */
-   if (port->type == MMAL_PORT_TYPE_INPUT)
-   {
-      MMAL_PORT_T **ports = port->component->output;
-      unsigned int i;
-
-      for (i = 0; i < port->component->output_num; i++)
-      {
-         if (ports[i]->buffer_size < ports[i]->buffer_size_min)
-            ports[i]->buffer_size = ports[i]->buffer_size_min;
-         if (ports[i]->buffer_num < ports[i]->buffer_num_min)
-            ports[i]->buffer_num = ports[i]->buffer_num_min;
-      }
-   }
-
-   UNLOCK_PORT(port);
-   return status;
-}
-
-/** Enable processing on a port */
-MMAL_STATUS_T mmal_port_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
-{
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *connected_port;
-   MMAL_PORT_PRIVATE_CORE_T *core;
-
-   if (!port || !port->priv)
-      return MMAL_EINVAL;
-
-   LOG_TRACE("%s port %p, cb %p, buffers (%i/%i/%i,%i/%i/%i)",
-             port->name, port, cb,
-             (int)port->buffer_num, (int)port->buffer_num_recommended, (int)port->buffer_num_min,
-             (int)port->buffer_size, (int)port->buffer_size_recommended, (int)port->buffer_size_min);
-
-   if (!port->priv->pf_enable)
-      return MMAL_ENOSYS;
-
-   core = port->priv->core;
-   LOCK_CONNECTION(port);
-   connected_port = core->connected_port;
-
-   /* Sanity checking */
-   if (port->is_enabled)
-   {
-      UNLOCK_CONNECTION(port);
-      LOG_ERROR("%s(%p) already enabled", port->name, port);
-      return MMAL_EINVAL;
-   }
-   if (connected_port && cb) /* Callback must be NULL for connected ports */
-   {
-      UNLOCK_CONNECTION(port);
-      LOG_ERROR("callback (%p) not allowed for connected port (%s)%p",
-         cb, port->name, connected_port);
-      return MMAL_EINVAL;
-   }
-
-   /* Start by preparing the port connection so that everything is ready for when
-    * both ports are enabled */
-   if (connected_port)
-   {
-      LOCK_CONNECTION(connected_port);
-      status = mmal_port_connection_enable(port, connected_port);
-      if (status != MMAL_SUCCESS)
-      {
-         UNLOCK_CONNECTION(connected_port);
-         UNLOCK_CONNECTION(port);
-         return status;
-      }
-
-      cb = connected_port->type == MMAL_PORT_TYPE_INPUT ?
-         mmal_port_connected_output_cb : mmal_port_connected_input_cb;
-   }
-
-   /* Enable the input port of a connection first */
-   if (connected_port && connected_port->type == MMAL_PORT_TYPE_INPUT)
-   {
-      status = mmal_port_enable_internal(connected_port, mmal_port_connected_input_cb);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("failed to enable connected port (%s)%p (%s)", connected_port->name,
-            connected_port, mmal_status_to_string(status));
-         goto error;
-      }
-   }
-
-   status = mmal_port_enable_internal(port, cb);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to enable port %s(%p) (%s)", port->name, port,
-         mmal_status_to_string(status));
-      goto error;
-   }
-
-   /* Enable the output port of a connection last */
-   if (connected_port && connected_port->type != MMAL_PORT_TYPE_INPUT)
-   {
-      status = mmal_port_enable_internal(connected_port, mmal_port_connected_output_cb);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("failed to enable connected port (%s)%p (%s)", connected_port->name,
-            connected_port, mmal_status_to_string(status));
-         goto error;
-      }
-   }
-
-   /* Kick off the connection */
-   if (connected_port && core->core_owns_connection)
-   {
-      status = mmal_port_connection_start(port, connected_port);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("failed to start connection (%s)%p (%s)", port->name,
-            port, mmal_status_to_string(status));
-         goto error;
-      }
-   }
-
-   if (connected_port)
-      UNLOCK_CONNECTION(connected_port);
-   UNLOCK_CONNECTION(port);
-   return MMAL_SUCCESS;
-
-error:
-   if (connected_port && connected_port->is_enabled)
-      mmal_port_disable_internal(connected_port);
-   if (port->is_enabled)
-      mmal_port_disable_internal(port);
-   if (connected_port)
-      mmal_port_connection_disable(port, connected_port);
-
-   if (connected_port)
-      UNLOCK_CONNECTION(connected_port);
-   UNLOCK_CONNECTION(port);
-   return status;
-}
-
-static MMAL_STATUS_T mmal_port_enable_internal(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
-{
-   MMAL_PORT_PRIVATE_CORE_T* core = port->priv->core;
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-
-   LOCK_PORT(port);
-
-   if (port->is_enabled)
-      goto end;
-
-   /* Sanity check the buffer requirements */
-   if (port->buffer_num < port->buffer_num_min)
-   {
-      LOG_ERROR("buffer_num too small (%i/%i)", (int)port->buffer_num, (int)port->buffer_num_min);
-      status = MMAL_EINVAL;
-      goto end;
-   }
-   if (port->buffer_size < port->buffer_size_min)
-   {
-      LOG_ERROR("buffer_size too small (%i/%i)", (int)port->buffer_size, (int)port->buffer_size_min);
-      status = MMAL_EINVAL;
-      goto end;
-   }
-
-   core->buffer_header_callback = cb;
-   status = port->priv->pf_enable(port, cb);
-   if (status != MMAL_SUCCESS)
-      goto end;
-
-   LOCK_SENDING(port);
-   port->is_enabled = 1;
-   UNLOCK_SENDING(port);
-
-end:
-   UNLOCK_PORT(port);
-   return status;
-}
-
-static MMAL_STATUS_T mmal_port_connection_enable(MMAL_PORT_T *port, MMAL_PORT_T *connected_port)
-{
-   MMAL_PORT_T *output = port->type == MMAL_PORT_TYPE_OUTPUT ? port : connected_port;
-   MMAL_PORT_T *input = connected_port->type == MMAL_PORT_TYPE_INPUT ? connected_port : port;
-   MMAL_PORT_T *pool_port = (output->capabilities & MMAL_PORT_CAPABILITY_ALLOCATION) ? output : input;
-   MMAL_PORT_PRIVATE_CORE_T *pool_core = pool_port->priv->core;
-   uint32_t buffer_size, buffer_num;
-   MMAL_POOL_T *pool;
-
-   /* At this point both ports hold the connection lock */
-
-   /* Ensure that the buffer numbers and sizes used are the maxima between connected ports. */
-   buffer_num  = MMAL_MAX(port->buffer_num,  connected_port->buffer_num);
-   buffer_size = MMAL_MAX(port->buffer_size, connected_port->buffer_size);
-   port->buffer_num  = connected_port->buffer_num  = buffer_num;
-   port->buffer_size = connected_port->buffer_size = buffer_size;
-
-   if (output->capabilities & MMAL_PORT_CAPABILITY_PASSTHROUGH)
-      buffer_size = 0;
-
-   if (!port->priv->core->core_owns_connection)
-      return MMAL_SUCCESS;
-
-   pool = mmal_port_pool_create(pool_port, buffer_num, buffer_size);
-   if (!pool)
-   {
-      LOG_ERROR("failed to create pool for connection");
-      return MMAL_ENOMEM;
-   }
-
-   pool_core->pool_for_connection = pool;
-   mmal_pool_callback_set(pool, mmal_port_connected_pool_cb, output);
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_port_connection_disable(MMAL_PORT_T *port, MMAL_PORT_T *connected_port)
-{
-   MMAL_POOL_T *pool = port->priv->core->pool_for_connection ?
-      port->priv->core->pool_for_connection : connected_port->priv->core->pool_for_connection;
-
-   mmal_pool_destroy(pool);
-   port->priv->core->pool_for_connection =
-      connected_port->priv->core->pool_for_connection = NULL;
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_port_connection_start(MMAL_PORT_T *port, MMAL_PORT_T *connected_port)
-{
-   MMAL_PORT_T *output = port->type == MMAL_PORT_TYPE_OUTPUT ? port : connected_port;
-   MMAL_PORT_T *input = connected_port->type == MMAL_PORT_TYPE_INPUT ? connected_port : port;
-   MMAL_POOL_T *pool = port->priv->core->pool_for_connection ?
-      port->priv->core->pool_for_connection : connected_port->priv->core->pool_for_connection;
-   MMAL_STATUS_T status;
-
-   if (output->type == MMAL_PORT_TYPE_CLOCK && input->type == MMAL_PORT_TYPE_CLOCK)
-   {
-      /* Clock ports need buffers to send clock updates, so
-       * populate both clock ports */
-      status = mmal_port_populate_clock_ports(output, input, pool);
-   }
-   else
-   {
-      /* Put the buffers into the output port */
-      status = mmal_port_populate_from_pool(output, pool);
-   }
-
-   return status;
-}
-
-/** Disable processing on a port */
-MMAL_STATUS_T mmal_port_disable(MMAL_PORT_T *port)
-{
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *connected_port;
-   MMAL_PORT_PRIVATE_CORE_T *core;
-
-   if (!port || !port->priv)
-      return MMAL_EINVAL;
-
-   LOG_TRACE("%s(%i:%i) port %p", port->component->name,
-             (int)port->type, (int)port->index, port);
-
-   if (!port->priv->pf_disable)
-      return MMAL_ENOSYS;
-
-   core = port->priv->core;
-   LOCK_CONNECTION(port);
-   connected_port = core->connected_port;
-
-   /* Sanity checking */
-   if (!port->is_enabled)
-   {
-      UNLOCK_CONNECTION(port);
-      LOG_ERROR("port %s(%p) is not enabled", port->name, port);
-      return MMAL_EINVAL;
-   }
-
-   if (connected_port)
-      LOCK_CONNECTION(connected_port);
-
-   /* Disable the output port of a connection first */
-   if (connected_port && connected_port->type != MMAL_PORT_TYPE_INPUT)
-   {
-      status = mmal_port_disable_internal(connected_port);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("failed to disable connected port (%s)%p (%s)", connected_port->name,
-            connected_port, mmal_status_to_string(status));
-         goto end;
-      }
-   }
-
-   status = mmal_port_disable_internal(port);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to disable port (%s)%p", port->name, port);
-      goto end;
-   }
-
-   /* Disable the input port of a connection last */
-   if (connected_port && connected_port->type == MMAL_PORT_TYPE_INPUT)
-   {
-      status = mmal_port_disable_internal(connected_port);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("failed to disable connected port (%s)%p (%s)", connected_port->name,
-            connected_port, mmal_status_to_string(status));
-         goto end;
-      }
-   }
-
-   if (connected_port)
-   {
-      status = mmal_port_connection_disable(port, connected_port);
-      if (status != MMAL_SUCCESS)
-         LOG_ERROR("failed to disable connection (%s)%p (%s)", port->name,
-            port, mmal_status_to_string(status));
-   }
-
-end:
-   if (connected_port)
-      UNLOCK_CONNECTION(connected_port);
-   UNLOCK_CONNECTION(port);
-
-   return status;
-}
-
-static MMAL_STATUS_T mmal_port_disable_internal(MMAL_PORT_T *port)
-{
-   MMAL_PORT_PRIVATE_CORE_T* core = port->priv->core;
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   MMAL_BUFFER_HEADER_T *buffer;
-
-   LOCK_PORT(port);
-
-   if (!port->is_enabled)
-      goto end;
-
-   LOCK_SENDING(port);
-   port->is_enabled = 0;
-   UNLOCK_SENDING(port);
-
-   mmal_component_action_lock(port->component);
-
-   if (core->pool_for_connection)
-      mmal_pool_callback_set(core->pool_for_connection, NULL, NULL);
-
-   status = port->priv->pf_disable(port);
-
-   mmal_component_action_unlock(port->component);
-
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("port %p could not be disabled (%s)", port->name, mmal_status_to_string(status));
-      LOCK_SENDING(port);
-      port->is_enabled = 1;
-      UNLOCK_SENDING(port);
-      goto end;
-   }
-
-   /* Flush our internal queue */
-   buffer = port->priv->core->queue_first;
-   while (buffer)
-   {
-      MMAL_BUFFER_HEADER_T *next = buffer->next;
-      mmal_port_buffer_header_callback(port, buffer);
-      buffer = next;
-   }
-   port->priv->core->queue_first = 0;
-   port->priv->core->queue_last = &port->priv->core->queue_first;
-
-   /* Wait for all the buffers to have come back from the component */
-   LOG_DEBUG("%s waiting for %i buffers left in transit", port->name, (int)IN_TRANSIT_COUNT(port));
-   IN_TRANSIT_WAIT(port);
-   LOG_DEBUG("%s has no buffers left in transit", port->name);
-
-   port->priv->core->buffer_header_callback = NULL;
-
- end:
-   UNLOCK_PORT(port);
-   return status;
-}
-
-/** Send a buffer header to a port */
-MMAL_STATUS_T mmal_port_send_buffer(MMAL_PORT_T *port,
-   MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-
-   if (!port || !port->priv)
-   {
-      LOG_ERROR("invalid port");
-      return MMAL_EINVAL;
-   }
-
-#ifdef ENABLE_MMAL_EXTRA_LOGGING
-   LOG_TRACE("%s(%i:%i) port %p, buffer %p (%p,%i,%i)",
-             port->component->name, (int)port->type, (int)port->index, port, buffer,
-             buffer ? buffer->data: 0, buffer ? (int)buffer->offset : 0,
-             buffer ? (int)buffer->length : 0);
-#endif
-
-   if (!buffer->data && !(port->capabilities & MMAL_PORT_CAPABILITY_PASSTHROUGH))
-   {
-      LOG_ERROR("%s(%p) received invalid buffer header", port->name, port);
-      return MMAL_EINVAL;
-   }
-
-   if (!port->priv->pf_send)
-      return MMAL_ENOSYS;
-
-   LOCK_SENDING(port);
-
-   if (!port->is_enabled)
-   {
-      UNLOCK_SENDING(port);
-      return MMAL_EINVAL;
-   }
-
-   if (port->type == MMAL_PORT_TYPE_OUTPUT && buffer->length)
-   {
-      LOG_DEBUG("given an output buffer with length != 0");
-      buffer->length = 0;
-   }
-
-   IN_TRANSIT_INCREMENT(port);
-
-   if (port->priv->core->is_paused)
-   {
-      /* Add buffer to our internal queue */
-      *port->priv->core->queue_last = buffer;
-      port->priv->core->queue_last = &buffer->next;
-   }
-   else
-   {
-      /* Send buffer to component */
-      status = port->priv->pf_send(port, buffer);
-   }
-
-   if (status != MMAL_SUCCESS)
-   {
-      IN_TRANSIT_DECREMENT(port);
-      LOG_ERROR("%s: send failed: %s", port->name, mmal_status_to_string(status));
-   }
-   else
-   {
-      mmal_port_update_port_stats(port, MMAL_CORE_STATS_RX);
-   }
-
-   UNLOCK_SENDING(port);
-   return status;
-}
-
-/** Flush a port */
-MMAL_STATUS_T mmal_port_flush(MMAL_PORT_T *port)
-{
-   MMAL_BUFFER_HEADER_T *buffer = 0;
-   MMAL_STATUS_T status;
-
-   if (!port || !port->priv)
-      return MMAL_EINVAL;
-
-   LOG_TRACE("%s(%i:%i) port %p", port->component->name,
-             (int)port->type, (int)port->index, port);
-
-   if (!port->priv->pf_flush)
-      return MMAL_ENOSYS;
-
-   mmal_component_action_lock(port->component);
-   LOCK_SENDING(port);
-   status = port->priv->pf_flush(port);
-   if (status == MMAL_SUCCESS)
-   {
-      /* Flush our internal queue */
-      buffer = port->priv->core->queue_first;
-      port->priv->core->queue_first = 0;
-      port->priv->core->queue_last = &port->priv->core->queue_first;
-   }
-   UNLOCK_SENDING(port);
-   mmal_component_action_unlock(port->component);
-
-   while (buffer)
-   {
-      MMAL_BUFFER_HEADER_T *next = buffer->next;
-      mmal_port_buffer_header_callback(port, buffer);
-      buffer = next;
-   }
-   return status;
-}
-
-/* Set a parameter on a port. */
-MMAL_STATUS_T mmal_port_parameter_set(MMAL_PORT_T *port,
-   const MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_STATUS_T status = MMAL_ENOSYS;
-
-   if (!port)
-   {
-      LOG_ERROR("no port");
-      return MMAL_EINVAL;
-   }
-   if (!param)
-   {
-      LOG_ERROR("param not supplied");
-      return MMAL_EINVAL;
-   }
-   if (!port->priv)
-   {
-      LOG_ERROR("port not configured");
-      return MMAL_EINVAL;
-   }
-
-   LOG_TRACE("%s(%i:%i) port %p, param %p (%x,%i)", port->component->name,
-             (int)port->type, (int)port->index, port,
-             param, param ? param->id : 0, param ? (int)param->size : 0);
-
-   LOCK_PORT(port);
-   if (port->priv->pf_parameter_set)
-      status = port->priv->pf_parameter_set(port, param);
-   if (status == MMAL_ENOSYS)
-   {
-      /* is this a core parameter? */
-      status = mmal_port_private_parameter_set(port, param);
-   }
-   UNLOCK_PORT(port);
-   return status;
-}
-
-/* Get a port parameter */
-MMAL_STATUS_T mmal_port_parameter_get(MMAL_PORT_T *port,
-   MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_STATUS_T status = MMAL_ENOSYS;
-
-   if (!port || !port->priv)
-      return MMAL_EINVAL;
-
-   LOG_TRACE("%s(%i:%i) port %p, param %p (%x,%i)", port->component->name,
-             (int)port->type, (int)port->index, port,
-             param, param ? param->id : 0, param ? (int)param->size : 0);
-
-   if (!param)
-      return MMAL_EINVAL;
-
-   LOCK_PORT(port);
-   if (port->priv->pf_parameter_get)
-      status = port->priv->pf_parameter_get(port, param);
-   if (status == MMAL_ENOSYS)
-   {
-      /* is this a core parameter? */
-      status = mmal_port_private_parameter_get(port, param);
-   }
-
-   UNLOCK_PORT(port);
-   return status;
-}
-
-/** Buffer header callback. */
-void mmal_port_buffer_header_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-#ifdef ENABLE_MMAL_EXTRA_LOGGING
-   LOG_TRACE("%s(%i:%i) port %p, buffer %p (%i,%p,%i,%i)",
-             port->component->name, (int)port->type, (int)port->index, port, buffer,
-             buffer ? (int)buffer->cmd : 0, buffer ? buffer->data : 0,
-             buffer ? (int)buffer->offset : 0, buffer ? (int)buffer->length : 0);
-#endif
-
-   if (!vcos_verify(IN_TRANSIT_COUNT(port) >= 0))
-      LOG_ERROR("%s: buffer headers in transit < 0 (%d)", port->name, (int)IN_TRANSIT_COUNT(port));
-
-   if (MMAL_COLLECT_PORT_STATS_ENABLED)
-   {
-      mmal_port_update_port_stats(port, MMAL_CORE_STATS_TX);
-   }
-
-   port->priv->core->buffer_header_callback(port, buffer);
-
-   IN_TRANSIT_DECREMENT(port);
-}
-
-/** Event callback */
-void mmal_port_event_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   if (port->priv->core->buffer_header_callback)
-   {
-      port->priv->core->buffer_header_callback(port, buffer);
-   }
-   else
-   {
-      LOG_ERROR("event lost on port %i,%i (buffer header callback not defined)",
-                (int)port->type, (int)port->index);
-      mmal_buffer_header_release(buffer);
-   }
-}
-
-/** Connect an output port to an input port. */
-MMAL_STATUS_T mmal_port_connect(MMAL_PORT_T *port, MMAL_PORT_T *other_port)
-{
-   MMAL_PORT_PRIVATE_CORE_T* core;
-   MMAL_PORT_PRIVATE_CORE_T* other_core;
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   MMAL_PORT_T* output_port = NULL;
-
-   if (!port || !port->priv || !other_port || !other_port->priv)
-   {
-      LOG_ERROR("invalid port");
-      return MMAL_EINVAL;
-   }
-
-   if ((port->type == MMAL_PORT_TYPE_CLOCK) && (port->type != other_port->type))
-   {
-      LOG_ERROR("invalid port connection");
-      return MMAL_EINVAL;
-   }
-
-   LOG_TRACE("connecting %s(%p) to %s(%p)", port->name, port, other_port->name, other_port);
-
-   if (!port->priv->pf_connect || !other_port->priv->pf_connect)
-   {
-      LOG_ERROR("at least one pf_connect is NULL");
-      return MMAL_ENOSYS;
-   }
-
-   core = port->priv->core;
-   other_core = other_port->priv->core;
-
-   LOCK_CONNECTION(port);
-   if (core->connected_port)
-   {
-      LOG_ERROR("port %p is already connected", port);
-      UNLOCK_CONNECTION(port);
-      return MMAL_EISCONN;
-   }
-   if (port->is_enabled)
-   {
-      LOG_ERROR("port %p should not be enabled", port);
-      UNLOCK_CONNECTION(port);
-      return MMAL_EINVAL;
-   }
-
-   LOCK_CONNECTION(other_port);
-   if (other_core->connected_port)
-   {
-      LOG_ERROR("port %p is already connected", other_port);
-      status = MMAL_EISCONN;
-      goto finish;
-   }
-   if (other_port->is_enabled)
-   {
-      LOG_ERROR("port %p should not be enabled", other_port);
-      status = MMAL_EINVAL;
-      goto finish;
-   }
-
-   core->connected_port = other_port;
-   other_core->connected_port = port;
-
-   core->core_owns_connection = 0;
-   other_core->core_owns_connection = 0;
-
-   /* Check to see if the port will manage the connection on its own. If not then the core
-    * will manage it. */
-   output_port = port->type == MMAL_PORT_TYPE_OUTPUT ? port : other_port;
-   if (output_port->priv->pf_connect(port, other_port) == MMAL_SUCCESS)
-      goto finish;
-
-   core->core_owns_connection = 1;
-   other_core->core_owns_connection = 1;
-
-
-finish:
-   UNLOCK_CONNECTION(other_port);
-   UNLOCK_CONNECTION(port);
-   return status;
-}
-
-/** Disconnect a connected port. */
-MMAL_STATUS_T mmal_port_disconnect(MMAL_PORT_T *port)
-{
-   MMAL_PORT_PRIVATE_CORE_T* core;
-   MMAL_PORT_T* other_port;
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-
-   if (!port || !port->priv)
-   {
-      LOG_ERROR("invalid port");
-      return MMAL_EINVAL;
-   }
-
-   LOG_TRACE("%s(%p)", port->name, port);
-
-   LOCK_CONNECTION(port);
-
-   core = port->priv->core;
-   other_port = core->connected_port;
-
-   if (!other_port)
-   {
-      UNLOCK_CONNECTION(port);
-      LOG_DEBUG("%s(%p) is not connected", port->name, port);
-      return MMAL_ENOTCONN;
-   }
-
-   LOCK_CONNECTION(other_port);
-
-   /* Make sure the connection is disabled first */
-   if (port->is_enabled)
-   {
-      MMAL_PORT_T *output = port->type == MMAL_PORT_TYPE_OUTPUT ? port : other_port;
-      MMAL_PORT_T *input = other_port->type == MMAL_PORT_TYPE_INPUT ? other_port : port;
-
-      status = mmal_port_disable_internal(output);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("failed to disable port (%s)%p", port->name, port);
-         goto end;
-      }
-      status = mmal_port_disable_internal(input);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("failed to disable port (%s)%p", port->name, port);
-         goto end;
-      }
-      status = mmal_port_connection_disable(port, other_port);
-   }
-
-   if (!core->core_owns_connection)
-   {
-      status = port->priv->pf_connect(port, NULL);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("disconnection of %s(%p) failed (%i)", port->name, port, status);
-         goto end;
-      }
-   }
-
-   core->connected_port = NULL;
-   other_port->priv->core->connected_port = NULL;
-
-end:
-   UNLOCK_CONNECTION(other_port);
-   UNLOCK_CONNECTION(port);
-   return status;
-}
-
-/** Allocate a payload buffer */
-uint8_t *mmal_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_size)
-{
-   uint8_t *mem;
-
-   if (!port || !port->priv)
-      return NULL;
-
-   LOG_TRACE("%s(%i:%i) port %p, size %i", port->component->name,
-             (int)port->type, (int)port->index, port, (int)payload_size);
-
-   if (!payload_size)
-      return NULL;
-
-   /* TODO: keep track of the allocs so we can free them when the component is destroyed */
-
-   if (!port->priv->pf_payload_alloc)
-   {
-      /* Revert to using the heap */
-#ifdef _VIDEOCORE
-      mem = (void *)mem_alloc(payload_size, 32, MEM_FLAG_DIRECT, port->name);
-#else
-      mem = vcos_malloc(payload_size, "mmal payload");
-#endif
-      goto end;
-   }
-
-   LOCK_PORT(port);
-   mem = port->priv->pf_payload_alloc(port, payload_size);
-   UNLOCK_PORT(port);
-
- end:
-   /* Acquire the port if the allocation was successful.
-    * This will ensure that the component is not destroyed until the payload has been freed. */
-   if (mem)
-      mmal_port_acquire(port);
-   return mem;
-}
-
-/** Free a payload buffer */
-void mmal_port_payload_free(MMAL_PORT_T *port, uint8_t *payload)
-{
-   if (!port || !port->priv)
-      return;
-
-   LOG_TRACE("%s(%i:%i) port %p, payload %p", port->component->name,
-             (int)port->type, (int)port->index, port, payload);
-
-   if (!port->priv->pf_payload_alloc)
-   {
-      /* Revert to using the heap */
-#ifdef _VIDEOCORE
-      mem_release((MEM_HANDLE_T)payload);
-#else
-      vcos_free(payload);
-#endif
-      mmal_port_release(port);
-      return;
-   }
-
-   LOCK_PORT(port);
-   port->priv->pf_payload_free(port, payload);
-   UNLOCK_PORT(port);
-   mmal_port_release(port);
-}
-
-MMAL_STATUS_T mmal_port_event_get(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t event)
-{
-   if (!port || !port->priv || !buffer)
-      return MMAL_EINVAL;
-
-   LOG_TRACE("%s(%i:%i) port %p, event %4.4s", port->component->name,
-             (int)port->type, (int)port->index, port, (char *)&event);
-
-   /* Get an event buffer from our event pool */
-   *buffer = mmal_queue_get(port->component->priv->event_pool->queue);
-   if (!*buffer)
-   {
-      LOG_ERROR("%s(%i:%i) port %p, no event buffer left for %4.4s", port->component->name,
-                (int)port->type, (int)port->index, port, (char *)&event);
-      return MMAL_ENOSPC;
-   }
-
-   (*buffer)->cmd = event;
-   (*buffer)->length = 0;
-
-   /* Special case for the FORMAT_CHANGED event. We need to properly initialise the event
-    * buffer so that it contains an initialised MMAL_ES_FORMAT_T structure. */
-   if (event == MMAL_EVENT_FORMAT_CHANGED)
-   {
-      uint32_t size = sizeof(MMAL_EVENT_FORMAT_CHANGED_T);
-      size += sizeof(MMAL_ES_FORMAT_T) + sizeof(MMAL_ES_SPECIFIC_FORMAT_T);
-
-      if ((*buffer)->alloc_size < size)
-      {
-         LOG_ERROR("%s(%i:%i) port %p, event buffer for %4.4s is too small (%i/%i)",
-                   port->component->name, (int)port->type, (int)port->index, port,
-                   (char *)&event, (int)(*buffer)->alloc_size, (int)size);
-         goto error;
-      }
-
-      memset((*buffer)->data, 0, size);
-      (*buffer)->length = size;
-   }
-
-   return MMAL_SUCCESS;
-
-error:
-   if (*buffer)
-      mmal_buffer_header_release(*buffer);
-   *buffer = NULL;
-   return MMAL_ENOSPC;
-}
-
-/** Populate clock ports from the given pool */
-static MMAL_STATUS_T mmal_port_populate_clock_ports(MMAL_PORT_T* output, MMAL_PORT_T* input, MMAL_POOL_T* pool)
-{
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   MMAL_BUFFER_HEADER_T *buffer;
-
-   if (!output->priv->pf_send || !input->priv->pf_send)
-      return MMAL_ENOSYS;
-
-   LOG_TRACE("output %s %p, input %s %p, pool: %p", output->name, output, input->name, input, pool);
-
-   buffer = mmal_queue_get(pool->queue);
-   while (buffer)
-   {
-      status = mmal_port_send_buffer(output, buffer);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("failed to send buffer to clock port %s", output->name);
-         mmal_buffer_header_release(buffer);
-         break;
-      }
-
-      buffer = mmal_queue_get(pool->queue);
-      if (buffer)
-      {
-         status = mmal_port_send_buffer(input, buffer);
-         if (status != MMAL_SUCCESS)
-         {
-            LOG_ERROR("failed to send buffer to clock port %s", output->name);
-            mmal_buffer_header_release(buffer);
-            break;
-         }
-         buffer = mmal_queue_get(pool->queue);
-      }
-   }
-
-   return status;
-}
-
-/** Populate an output port with a pool of buffers */
-static MMAL_STATUS_T mmal_port_populate_from_pool(MMAL_PORT_T* port, MMAL_POOL_T* pool)
-{
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   uint32_t buffer_idx;
-   MMAL_BUFFER_HEADER_T *buffer;
-
-   if (!port->priv->pf_send)
-      return MMAL_ENOSYS;
-
-   LOG_TRACE("%s port %p, pool: %p", port->name, port, pool);
-
-   /* Populate port from pool */
-   for (buffer_idx = 0; buffer_idx < port->buffer_num; buffer_idx++)
-   {
-      buffer = mmal_queue_get(pool->queue);
-      if (!buffer)
-      {
-         LOG_ERROR("too few buffers in the pool");
-         status = MMAL_ENOMEM;
-         break;
-      }
-
-      status = mmal_port_send_buffer(port, buffer);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("failed to send buffer to port");
-         mmal_buffer_header_release(buffer);
-         break;
-      }
-   }
-
-   return status;
-}
-
-/** Default behaviour when setting up or tearing down a connection to another port */
-static MMAL_STATUS_T mmal_port_connect_default(MMAL_PORT_T *port, MMAL_PORT_T *other_port)
-{
-   MMAL_PARAM_UNUSED(port);
-   MMAL_PARAM_UNUSED(other_port);
-
-   LOG_TRACE("port %p, other_port %p", port, other_port);
-   return MMAL_ENOSYS;
-}
-
-/** Connected input port buffer callback */
-static void mmal_port_connected_input_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_PARAM_UNUSED(port);
-
-   LOG_TRACE("buffer %p from connected input port %p: data %p, alloc_size %u, length %u",
-             buffer, port, buffer->data, buffer->alloc_size, buffer->length);
-
-   /* Simply release buffer back into pool for re-use */
-   mmal_buffer_header_release(buffer);
-}
-
-/** Connected output port buffer callback */
-static void mmal_port_connected_output_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_PORT_T* connected_port = port->priv->core->connected_port;
-   MMAL_STATUS_T status;
-
-   LOG_TRACE("buffer %p from connected output port %p: data %p, alloc_size %u, length %u",
-             buffer, port, buffer->data, buffer->alloc_size, buffer->length);
-
-   if (buffer->cmd)
-   {
-      MMAL_EVENT_FORMAT_CHANGED_T *event = mmal_event_format_changed_get(buffer);
-
-      /* Handle format changed events */
-      if (event)
-      {
-         /* Apply the change */
-         status = mmal_format_full_copy(port->format, event->format);
-         if (status == MMAL_SUCCESS)
-            status = mmal_port_format_commit(port);
-         if (status != MMAL_SUCCESS)
-            LOG_ERROR("format commit failed on port %s (%i)", port->name, status);
-
-         /* Forward to the connected port */
-         if (status == MMAL_SUCCESS)
-            status = mmal_port_send_buffer(connected_port, buffer);
-
-         if (status != MMAL_SUCCESS)
-         {
-            mmal_event_error_send(port->component, status);
-            mmal_buffer_header_release(buffer);
-         }
-         return; /* Event handled */
-      }
-
-      /* FIXME Release other event buffers for now, until we can deal with shared memory issues */
-      mmal_buffer_header_release(buffer);
-   }
-   else
-   {
-      if (port->is_enabled)
-      {
-         /* Forward data buffers to the connected input port */
-         status = mmal_port_send_buffer(connected_port, buffer);
-         if (status != MMAL_SUCCESS)
-         {
-            LOG_ERROR("%s could not send buffer on port %s (%s)",
-                      port->name, connected_port->name, mmal_status_to_string(status));
-            mmal_buffer_header_release(buffer);
-         }
-      }
-      else
-      {
-         /* This port is disabled. Buffer will be a flushed buffer, so
-          * return to the pool rather than delivering it.
-          */
-         mmal_buffer_header_release(buffer);
-      }
-   }
-}
-
-/** Callback for when a buffer from a connected input port is finally released */
-static MMAL_BOOL_T mmal_port_connected_pool_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata)
-{
-   MMAL_PORT_T* port = (MMAL_PORT_T*)userdata;
-   MMAL_STATUS_T status;
-   MMAL_PARAM_UNUSED(pool);
-
-   LOG_TRACE("released buffer %p, data %p alloc_size %u length %u",
-             buffer, buffer->data, buffer->alloc_size, buffer->length);
-
-   /* Reset buffer header */
-   buffer->cmd = 0;
-   buffer->length = 0;
-   buffer->offset = 0;
-   buffer->flags = 0;
-   buffer->pts = 0;
-   buffer->dts = 0;
-
-   /* Pipe the buffer back to the output port */
-   status = mmal_port_send_buffer(port, buffer);
-
-   /* Put the buffer back in the pool if we were successful */
-   return status != MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-static void mmal_port_name_update(MMAL_PORT_T *port)
-{
-   MMAL_PORT_PRIVATE_CORE_T* core = port->priv->core;
-
-   vcos_snprintf(core->name, core->name_size - 1, PORT_NAME_FORMAT,
-            port->component->name, mmal_port_type_to_string(port->type), (int)port->index,
-            port->format && port->format->encoding ? '(' : '\0',
-            port->format && port->format->encoding ? (char *)&port->format->encoding : "");
-}
-
-static MMAL_STATUS_T mmal_port_get_core_stats(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_PARAMETER_CORE_STATISTICS_T *stats_param = (MMAL_PARAMETER_CORE_STATISTICS_T*)param;
-   MMAL_CORE_STATISTICS_T *stats = &stats_param->stats;
-   MMAL_CORE_STATISTICS_T *src_stats;
-   MMAL_PORT_PRIVATE_CORE_T *core = port->priv->core;
-   vcos_mutex_lock(&core->stats_lock);
-   switch (stats_param->dir)
-   {
-   case MMAL_CORE_STATS_RX:
-      src_stats = &port->priv->core->stats.rx;
-      break;
-   default:
-      src_stats = &port->priv->core->stats.tx;
-      break;
-   }
-   *stats = *src_stats;
-   if (stats_param->reset)
-      memset(src_stats, 0, sizeof(*src_stats));
-   vcos_mutex_unlock(&core->stats_lock);
-   return MMAL_SUCCESS;
-}
-
-/** Update the port stats, called per buffer.
- *
- */
-static void mmal_port_update_port_stats(MMAL_PORT_T *port, MMAL_CORE_STATS_DIR direction)
-{
-   MMAL_PORT_PRIVATE_CORE_T *core = port->priv->core;
-   MMAL_CORE_STATISTICS_T *stats;
-   unsigned stc = vcos_getmicrosecs();
-
-   vcos_mutex_lock(&core->stats_lock);
-
-   stats = direction == MMAL_CORE_STATS_RX ? &core->stats.rx : &core->stats.tx;
-
-   stats->buffer_count++;
-
-   if (!stats->first_buffer_time)
-   {
-      stats->last_buffer_time = stats->first_buffer_time = stc;
-   }
-   else
-   {
-      stats->max_delay = vcos_max(stats->max_delay, stc-stats->last_buffer_time);
-      stats->last_buffer_time = stc;
-   }
-   vcos_mutex_unlock(&core->stats_lock);
-}
-
-static MMAL_STATUS_T mmal_port_private_parameter_get(MMAL_PORT_T *port,
-                                                     MMAL_PARAMETER_HEADER_T *param)
-{
-   switch (param->id)
-   {
-   case MMAL_PARAMETER_CORE_STATISTICS:
-      return mmal_port_get_core_stats(port, param);
-   default:
-      return MMAL_ENOSYS;
-   }
-}
-
-static MMAL_STATUS_T mmal_port_private_parameter_set(MMAL_PORT_T *port,
-                                                     const MMAL_PARAMETER_HEADER_T *param)
-{
-   (void)port;
-   switch (param->id)
-   {
-   default:
-      return MMAL_ENOSYS;
-   }
-}
-
-MMAL_STATUS_T mmal_port_pause(MMAL_PORT_T *port, MMAL_BOOL_T pause)
-{
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-
-   LOCK_SENDING(port);
-
-   /* When resuming from pause, we send all our queued buffers to the port */
-   if (!pause && port->is_enabled)
-   {
-      MMAL_BUFFER_HEADER_T *buffer = port->priv->core->queue_first;
-      while (buffer)
-      {
-         MMAL_BUFFER_HEADER_T *next = buffer->next;
-         status = port->priv->pf_send(port, buffer);
-         if (status != MMAL_SUCCESS)
-         {
-            buffer->next = next;
-            break;
-         }
-         buffer = next;
-      }
-
-      /* If for some reason we could not send one of the buffers, we just
-       * leave all the buffers in our internal queue and return an error. */
-      if (status != MMAL_SUCCESS)
-      {
-         port->priv->core->queue_first = buffer;
-      }
-      else
-      {
-         port->priv->core->queue_first = 0;
-         port->priv->core->queue_last = &port->priv->core->queue_first;
-      }
-   }
-
-   if (status == MMAL_SUCCESS)
-      port->priv->core->is_paused = pause;
-
-   UNLOCK_SENDING(port);
-   return status;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_clock.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_clock.c
deleted file mode 100644
index 8f71513..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_clock.c
+++ /dev/null
@@ -1,597 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal_clock.h"
-#include "mmal_logging.h"
-#include "core/mmal_clock_private.h"
-#include "core/mmal_port_private.h"
-#include "util/mmal_util.h"
-
-#ifdef __VIDEOCORE__
-# include "vcfw/rtos/common/rtos_common_mem.h"
-#endif
-
-/** Minimum number of buffers required on a clock port */
-#define MMAL_PORT_CLOCK_BUFFERS_MIN  8
-
-/** Private clock port context */
-typedef struct MMAL_PORT_MODULE_T
-{
-   MMAL_PORT_CLOCK_EVENT_CB event_cb; /**< callback for notifying the component of clock events */
-   MMAL_QUEUE_T *queue;               /**< queue for empty buffers sent to the port */
-   MMAL_CLOCK_T *clock;               /**< clock module for scheduling requests */
-   MMAL_BOOL_T is_reference;          /**< TRUE -> clock port is a reference, therefore
-                                           will forward time updates */
-} MMAL_PORT_MODULE_T;
-
-/*****************************************************************************
- * Private functions
- *****************************************************************************/
-#ifdef __VIDEOCORE__
-/* FIXME: mmal_buffer_header_mem_lock() assumes that payload memory is on the
- * relocatable heap when on VC. However that is not always the case. The MMAL
- * framework will allocate memory from the normal heap when ports are connected.
- * To work around this, override the default behaviour by providing a payload
- * allocator for clock ports which always allocates from the relocatable heap. */
-static uint8_t* mmal_port_clock_payload_alloc(MMAL_PORT_T *port, uint32_t payload_size)
-{
-   int alignment = port->buffer_alignment_min;
-   uint8_t *mem;
-
-   if (!alignment)
-      alignment = 32;
-   vcos_assert((alignment & (alignment-1)) == 0);
-
-   mem = (uint8_t*)mem_alloc(payload_size, alignment, MEM_FLAG_DIRECT, port->name);
-   if (!mem)
-   {
-      LOG_ERROR("could not allocate %u bytes", payload_size);
-      return NULL;
-   }
-   return mem;
-}
-
-static void mmal_port_clock_payload_free(MMAL_PORT_T *port, uint8_t *payload)
-{
-   MMAL_PARAM_UNUSED(port);
-   mem_release((MEM_HANDLE_T)payload);
-}
-#endif
-
-
-/* Callback invoked by the clock module in response to a client request */
-static void mmal_port_clock_request_cb(MMAL_CLOCK_T* clock, int64_t media_time, void *cb_data, MMAL_CLOCK_VOID_FP cb)
-{
-   MMAL_PORT_CLOCK_REQUEST_CB cb_client = (MMAL_PORT_CLOCK_REQUEST_CB)cb;
-
-   /* Forward to the client */
-   cb_client((MMAL_PORT_T*)clock->user_data, media_time, cb_data);
-}
-
-/* Process buffers received from other clock ports */
-static MMAL_STATUS_T mmal_port_clock_process_buffer(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   MMAL_CLOCK_PAYLOAD_T payload;
-
-   if (buffer->length != sizeof(MMAL_CLOCK_PAYLOAD_T))
-   {
-      LOG_ERROR("invalid buffer length %d", buffer->length);
-      return MMAL_EINVAL;
-   }
-
-   mmal_buffer_header_mem_lock(buffer);
-   memcpy(&payload, buffer->data, sizeof(MMAL_CLOCK_PAYLOAD_T));
-   mmal_buffer_header_mem_unlock(buffer);
-
-   if (payload.magic != MMAL_CLOCK_PAYLOAD_MAGIC)
-   {
-      LOG_ERROR("buffer corrupt (magic %4.4s)", (char*)&payload.magic);
-      return MMAL_EINVAL;
-   }
-
-   LOG_TRACE("port %s length %d id %4.4s time %"PRIi64,
-         port->name, buffer->length, (char*)&payload.id, payload.time);
-
-   switch (payload.id)
-   {
-   case MMAL_CLOCK_PAYLOAD_TIME:
-      mmal_clock_media_time_set(port->priv->module->clock, payload.time);
-      break;
-   case MMAL_CLOCK_PAYLOAD_SCALE:
-      mmal_clock_scale_set(port->priv->module->clock, payload.data.scale);
-      break;
-   default:
-      LOG_ERROR("invalid id %4.4s", (char*)&payload.id);
-      status = MMAL_EINVAL;
-      break;
-   }
-
-   /* Finished with the buffer, so return it */
-   buffer->length = 0;
-   mmal_port_buffer_header_callback(port, buffer);
-
-   return status;
-}
-
-static MMAL_STATUS_T mmal_port_clock_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-
-   if (buffer->length)
-      return mmal_port_clock_process_buffer(port, buffer);
-
-   /* Queue empty buffers to be used later when forwarding clock updates */
-   mmal_queue_put(module->queue, buffer);
-
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_port_clock_flush(MMAL_PORT_T *port)
-{
-   MMAL_BUFFER_HEADER_T *buffer;
-
-   /* Flush empty buffers */
-   buffer = mmal_queue_get(port->priv->module->queue);
-   while (buffer)
-   {
-      mmal_port_buffer_header_callback(port, buffer);
-      buffer = mmal_queue_get(port->priv->module->queue);
-   }
-
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_port_clock_parameter_set(MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_CLOCK_PAYLOAD_T event;
-
-   switch (param->id)
-   {
-      case MMAL_PARAMETER_CLOCK_REFERENCE:
-      {
-         const MMAL_PARAMETER_BOOLEAN_T *p = (const MMAL_PARAMETER_BOOLEAN_T*)param;
-         module->is_reference = p->enable;
-         event.id = MMAL_CLOCK_PAYLOAD_REFERENCE;
-         event.time = mmal_clock_media_time_get(module->clock);
-         event.data.enable = p->enable;
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_ACTIVE:
-      {
-         const MMAL_PARAMETER_BOOLEAN_T *p = (const MMAL_PARAMETER_BOOLEAN_T*)param;
-         status = mmal_clock_active_set(module->clock, p->enable);
-         event.id = MMAL_CLOCK_PAYLOAD_ACTIVE;
-         event.time = mmal_clock_media_time_get(module->clock);
-         event.data.enable = p->enable;
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_SCALE:
-      {
-         const MMAL_PARAMETER_RATIONAL_T *p = (const MMAL_PARAMETER_RATIONAL_T*)param;
-         status = mmal_port_clock_scale_set(port, p->value);
-         event.id = MMAL_CLOCK_PAYLOAD_SCALE;
-         event.time = mmal_clock_media_time_get(module->clock);
-         event.data.scale = p->value;
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_TIME:
-      {
-         const MMAL_PARAMETER_INT64_T *p = (const MMAL_PARAMETER_INT64_T*)param;
-         status = mmal_port_clock_media_time_set(port, p->value);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_TIME_OFFSET:
-      {
-         const MMAL_PARAMETER_INT64_T *p = (const MMAL_PARAMETER_INT64_T*)param;
-         status = mmal_port_clock_media_time_offset_set(port, p->value);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD:
-      {
-         const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *)param;
-         status = mmal_clock_update_threshold_set(module->clock, p);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD:
-      {
-         const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *)param;
-         status = mmal_clock_discont_threshold_set(module->clock, p);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD:
-      {
-         const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *)param;
-         status = mmal_clock_request_threshold_set(module->clock, p);
-         event.id = MMAL_CLOCK_PAYLOAD_INVALID;
-      }
-      break;
-      default:
-         return MMAL_ENOSYS;
-   }
-
-   /* Notify the component */
-   if (module->event_cb && status == MMAL_SUCCESS && event.id != MMAL_CLOCK_PAYLOAD_INVALID)
-      module->event_cb(port, &event);
-
-   return status;
-}
-
-static MMAL_STATUS_T mmal_port_clock_parameter_get(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-
-   switch (param->id)
-   {
-      case MMAL_PARAMETER_CLOCK_REFERENCE:
-      {
-         MMAL_PARAMETER_BOOLEAN_T *p = (MMAL_PARAMETER_BOOLEAN_T*)param;
-         p->enable = module->is_reference;
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_ACTIVE:
-      {
-         MMAL_PARAMETER_BOOLEAN_T *p = (MMAL_PARAMETER_BOOLEAN_T*)param;
-         p->enable = mmal_clock_is_active(module->clock);
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_SCALE:
-      {
-         MMAL_PARAMETER_RATIONAL_T *p = (MMAL_PARAMETER_RATIONAL_T*)param;
-         p->value = mmal_clock_scale_get(module->clock);
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_TIME:
-      {
-         MMAL_PARAMETER_INT64_T *p = (MMAL_PARAMETER_INT64_T*)param;
-         p->value = mmal_clock_media_time_get(module->clock);
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_TIME_OFFSET:
-      {
-         MMAL_PARAMETER_INT64_T *p = (MMAL_PARAMETER_INT64_T*)param;
-         p->value = mmal_clock_media_time_offset_get(module->clock);
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD:
-      {
-         MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T *)param;
-         mmal_clock_update_threshold_get(module->clock, p);
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD:
-      {
-         MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T *)param;
-         mmal_clock_discont_threshold_get(module->clock, p);
-      }
-      break;
-      case MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD:
-      {
-         MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *p = (MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T *)param;
-         mmal_clock_request_threshold_get(module->clock, p);
-      }
-      break;
-      default:
-         return MMAL_ENOSYS;
-   }
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_port_clock_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
-{
-   MMAL_PARAM_UNUSED(port);
-   MMAL_PARAM_UNUSED(cb);
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_port_clock_disable(MMAL_PORT_T *port)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-
-   if (mmal_clock_is_active(module->clock))
-      mmal_clock_active_set(module->clock, MMAL_FALSE);
-
-   mmal_port_clock_flush(port);
-
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_port_clock_set_format(MMAL_PORT_T *port)
-{
-   MMAL_PARAM_UNUSED(port);
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_port_clock_connect(MMAL_PORT_T *port, MMAL_PORT_T *other_port)
-{
-   MMAL_PARAM_UNUSED(port);
-   MMAL_PARAM_UNUSED(other_port);
-   return MMAL_ENOSYS;
-}
-
-/* Send a payload buffer to a connected port/client */
-static MMAL_STATUS_T mmal_port_clock_forward_payload(MMAL_PORT_T *port, const MMAL_CLOCK_PAYLOAD_T *payload)
-{
-   MMAL_STATUS_T status;
-   MMAL_BUFFER_HEADER_T *buffer;
-
-   buffer = mmal_queue_get(port->priv->module->queue);
-   if (!buffer)
-   {
-      LOG_ERROR("no free buffers available");
-      return MMAL_ENOSPC;
-   }
-
-   status = mmal_buffer_header_mem_lock(buffer);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to lock buffer %s", mmal_status_to_string(status));
-      mmal_queue_put_back(port->priv->module->queue, buffer);
-      goto end;
-   }
-   buffer->length = sizeof(MMAL_CLOCK_PAYLOAD_T);
-   memcpy(buffer->data, payload, buffer->length);
-   mmal_buffer_header_mem_unlock(buffer);
-
-   mmal_port_buffer_header_callback(port, buffer);
-
-end:
-   return status;
-}
-
-/* Send a clock time update to a connected port/client */
-static MMAL_STATUS_T mmal_port_clock_forward_media_time(MMAL_PORT_T *port, int64_t media_time)
-{
-   MMAL_CLOCK_PAYLOAD_T payload;
-
-   payload.id = MMAL_CLOCK_PAYLOAD_TIME;
-   payload.magic = MMAL_CLOCK_PAYLOAD_MAGIC;
-   payload.time = media_time;
-
-   return mmal_port_clock_forward_payload(port, &payload);
-}
-
-/* Send a clock scale update to a connected port/client */
-static MMAL_STATUS_T mmal_port_clock_forward_scale(MMAL_PORT_T *port, MMAL_RATIONAL_T scale)
-{
-   MMAL_CLOCK_PAYLOAD_T payload;
-
-   payload.id = MMAL_CLOCK_PAYLOAD_SCALE;
-   payload.magic = MMAL_CLOCK_PAYLOAD_MAGIC;
-   payload.time = mmal_clock_media_time_get(port->priv->module->clock);
-   payload.data.scale = scale;
-
-   return mmal_port_clock_forward_payload(port, &payload);
-}
-
-/* Initialise all callbacks and setup internal resources */
-static MMAL_STATUS_T mmal_port_clock_setup(MMAL_PORT_T *port, MMAL_PORT_CLOCK_EVENT_CB event_cb)
-{
-   MMAL_STATUS_T status;
-
-   status = mmal_clock_create(&port->priv->module->clock);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to create clock module on port %s (%s)", port->name, mmal_status_to_string(status));
-      return status;
-   }
-   port->priv->module->clock->user_data = port;
-
-   port->buffer_size = sizeof(MMAL_CLOCK_PAYLOAD_T);
-   port->buffer_size_min = sizeof(MMAL_CLOCK_PAYLOAD_T);
-   port->buffer_num_min = MMAL_PORT_CLOCK_BUFFERS_MIN;
-   port->buffer_num_recommended = MMAL_PORT_CLOCK_BUFFERS_MIN;
-
-   port->priv->module->event_cb = event_cb;
-   port->priv->module->queue = mmal_queue_create();
-   if (!port->priv->module->queue)
-   {
-      mmal_clock_destroy(port->priv->module->clock);
-      return MMAL_ENOMEM;
-   }
-
-   port->priv->pf_set_format = mmal_port_clock_set_format;
-   port->priv->pf_enable = mmal_port_clock_enable;
-   port->priv->pf_disable = mmal_port_clock_disable;
-   port->priv->pf_send = mmal_port_clock_send;
-   port->priv->pf_flush = mmal_port_clock_flush;
-   port->priv->pf_parameter_set = mmal_port_clock_parameter_set;
-   port->priv->pf_parameter_get = mmal_port_clock_parameter_get;
-   port->priv->pf_connect = mmal_port_clock_connect;
-#ifdef __VIDEOCORE__
-   port->priv->pf_payload_alloc = mmal_port_clock_payload_alloc;
-   port->priv->pf_payload_free = mmal_port_clock_payload_free;
-   port->capabilities = MMAL_PORT_CAPABILITY_ALLOCATION;
-#endif
-
-   return status;
-}
-
-/* Release all internal resources */
-static void mmal_port_clock_teardown(MMAL_PORT_T *port)
-{
-   if (!port)
-      return;
-   mmal_queue_destroy(port->priv->module->queue);
-   mmal_clock_destroy(port->priv->module->clock);
-}
-
-/*****************************************************************************
- * Public functions
- *****************************************************************************/
-/* Allocate a clock port */
-MMAL_PORT_T* mmal_port_clock_alloc(MMAL_COMPONENT_T *component, MMAL_PORT_CLOCK_EVENT_CB event_cb)
-{
-   MMAL_PORT_T *port;
-
-   port = mmal_port_alloc(component, MMAL_PORT_TYPE_CLOCK, sizeof(MMAL_PORT_MODULE_T));
-   if (!port)
-      return NULL;
-
-   if (mmal_port_clock_setup(port, event_cb) != MMAL_SUCCESS)
-   {
-      mmal_port_free(port);
-      return NULL;
-   }
-
-   return port;
-}
-
-/* Free a clock port */
-void mmal_port_clock_free(MMAL_PORT_T *port)
-{
-   mmal_port_clock_teardown(port);
-   mmal_port_free(port);
-}
-
-/* Allocate an array of clock ports */
-MMAL_PORT_T **mmal_ports_clock_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num, MMAL_PORT_CLOCK_EVENT_CB event_cb)
-{
-   unsigned int i;
-   MMAL_PORT_T **ports;
-
-   ports = mmal_ports_alloc(component, ports_num, MMAL_PORT_TYPE_CLOCK, sizeof(MMAL_PORT_MODULE_T));
-   if (!ports)
-      return NULL;
-
-   for (i = 0; i < ports_num; i++)
-   {
-      if (mmal_port_clock_setup(ports[i], event_cb) != MMAL_SUCCESS)
-         break;
-   }
-
-   if (i != ports_num)
-   {
-      for (ports_num = i, i = 0; i < ports_num; i++)
-         mmal_port_clock_free(ports[i]);
-      vcos_free(ports);
-      return NULL;
-   }
-
-   return ports;
-}
-
-/* Free an array of clock ports */
-void mmal_ports_clock_free(MMAL_PORT_T **ports, unsigned int ports_num)
-{
-   unsigned int i;
-
-   for (i = 0; i < ports_num; i++)
-      mmal_port_clock_free(ports[i]);
-   vcos_free(ports);
-}
-
-/* Register a callback request */
-MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time, int64_t offset,
-      MMAL_PORT_CLOCK_REQUEST_CB cb, void *cb_data)
-{
-   return mmal_clock_request_add(port->priv->module->clock, media_time, offset,
-                                 mmal_port_clock_request_cb, cb_data, (MMAL_CLOCK_VOID_FP)cb);
-}
-
-/* Flush all pending clock requests */
-MMAL_STATUS_T mmal_port_clock_request_flush(MMAL_PORT_T *port)
-{
-   return mmal_clock_request_flush(port->priv->module->clock);
-}
-
-/* Set the media-time on the clock port */
-MMAL_STATUS_T mmal_port_clock_media_time_set(MMAL_PORT_T *port, int64_t media_time)
-{
-   MMAL_STATUS_T status;
-
-   status = mmal_clock_media_time_set(port->priv->module->clock, media_time);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_DEBUG("clock update ignored");
-      return status;
-   }
-
-   /* Only forward time updates if this port is set as a reference clock port */
-   if (port->priv->module->is_reference)
-      mmal_port_clock_forward_media_time(port, mmal_clock_media_time_get(port->priv->module->clock));
-
-   return status;
-}
-
-/* Set the media-time offset on the clock port */
-MMAL_STATUS_T mmal_port_clock_media_time_offset_set(MMAL_PORT_T *port, int64_t offset)
-{
-   MMAL_STATUS_T status;
-
-   status = mmal_clock_media_time_offset_set(port->priv->module->clock, offset);
-
-   /* The media-time has effectively changed, so need to inform connected clock ports */
-   if (port->priv->module->is_reference)
-      mmal_port_clock_forward_media_time(port, mmal_clock_media_time_get(port->priv->module->clock));
-
-   return status;
-}
-
-/* Return the current media-time */
-int64_t mmal_port_clock_media_time_get(MMAL_PORT_T *port)
-{
-   return mmal_clock_media_time_get(port->priv->module->clock);
-}
-
-/* Return the media-time offset */
-int64_t mmal_port_clock_media_time_offset_get(MMAL_PORT_T *port)
-{
-   return mmal_clock_media_time_offset_get(port->priv->module->clock);
-}
-
-/* Set the clock scale factor */
-MMAL_STATUS_T mmal_port_clock_scale_set(MMAL_PORT_T *port, MMAL_RATIONAL_T scale)
-{
-   MMAL_STATUS_T status;
-
-   status = mmal_clock_scale_set(port->priv->module->clock, scale);
-
-   if (port->priv->module->is_reference)
-      mmal_port_clock_forward_scale(port, scale);
-
-   return status;
-}
-
-/* Return the clock scale factor */
-MMAL_RATIONAL_T mmal_port_clock_scale_get(MMAL_PORT_T *port)
-{
-   return mmal_clock_scale_get(port->priv->module->clock);
-}
-
-/* Return TRUE if clock is running (media-time is advancing) */
-MMAL_BOOL_T mmal_port_clock_is_active(MMAL_PORT_T *port)
-{
-   return mmal_clock_is_active(port->priv->module->clock);
-}
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_private.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_private.h
deleted file mode 100644
index 61b1df3..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_port_private.h
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_PORT_PRIVATE_H
-#define MMAL_PORT_PRIVATE_H
-
-#include "interface/mmal/mmal.h"
-#include "interface/mmal/mmal_clock.h"
-
-/** Definition of a port. */
-typedef struct MMAL_PORT_PRIVATE_T
-{
-   /** Pointer to the private data of the core */
-   struct MMAL_PORT_PRIVATE_CORE_T *core;
-   /** Pointer to the private data of the module in use */
-   struct MMAL_PORT_MODULE_T *module;
-
-   MMAL_STATUS_T (*pf_set_format)(MMAL_PORT_T *port);
-   MMAL_STATUS_T (*pf_enable)(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T);
-   MMAL_STATUS_T (*pf_disable)(MMAL_PORT_T *port);
-   MMAL_STATUS_T (*pf_send)(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *);
-   MMAL_STATUS_T (*pf_flush)(MMAL_PORT_T *port);
-   MMAL_STATUS_T (*pf_parameter_set)(MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param);
-   MMAL_STATUS_T (*pf_parameter_get)(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param);
-   MMAL_STATUS_T (*pf_connect)(MMAL_PORT_T *port, MMAL_PORT_T *other_port);
-
-   uint8_t *(*pf_payload_alloc)(MMAL_PORT_T *port, uint32_t payload_size);
-   void     (*pf_payload_free)(MMAL_PORT_T *port, uint8_t *payload);
-
-} MMAL_PORT_PRIVATE_T;
-
-/** Callback called by components when a \ref MMAL_BUFFER_HEADER_T needs to be sent back to the
- * user */
-void mmal_port_buffer_header_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
-
-/** Callback called by components when an event \ref MMAL_BUFFER_HEADER_T needs to be sent to the
- * user. Events differ from ordinary buffer headers because they originate from the component
- * and do not return data from the client to the component. */
-void mmal_port_event_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
-
-/** Allocate a port structure */
-MMAL_PORT_T *mmal_port_alloc(MMAL_COMPONENT_T *, MMAL_PORT_TYPE_T type, unsigned int extra_size);
-/** Free a port structure */
-void mmal_port_free(MMAL_PORT_T *port);
-/** Allocate an array of ports */
-MMAL_PORT_T **mmal_ports_alloc(MMAL_COMPONENT_T *, unsigned int ports_num, MMAL_PORT_TYPE_T type,
-                               unsigned int extra_size);
-/** Free an array of ports */
-void mmal_ports_free(MMAL_PORT_T **ports, unsigned int ports_num);
-
-/** Acquire a reference on a port */
-void mmal_port_acquire(MMAL_PORT_T *port);
-
-/** Release a reference on a port */
-MMAL_STATUS_T mmal_port_release(MMAL_PORT_T *port);
-
-/** Pause processing on a port */
-MMAL_STATUS_T mmal_port_pause(MMAL_PORT_T *port, MMAL_BOOL_T pause);
-
-/*****************************************************************************
- * Clock Port API
- *****************************************************************************/
-/** Definition of a clock port event callback.
- * Used to inform the client of a clock event that has occurred.
- *
- * @param port       The clock port where the event occurred
- * @param event      The event that has occurred
- */
-typedef void (*MMAL_PORT_CLOCK_EVENT_CB)(MMAL_PORT_T *port, const MMAL_CLOCK_PAYLOAD_T *event);
-
-/** Allocate a clock port.
- *
- * @param component  The component requesting the alloc
- * @param event_cb   Clock event callback
- *
- * @return Pointer to new clock port or NULL on failure.
- */
-MMAL_PORT_T* mmal_port_clock_alloc(MMAL_COMPONENT_T *component, MMAL_PORT_CLOCK_EVENT_CB event_cb);
-
-/** Free a clock port.
- *
- * @param port       The clock port to free
- */
-void mmal_port_clock_free(MMAL_PORT_T *port);
-
-/** Allocate an array of clock ports.
- *
- * @param component  The component requesting the alloc
- * @param ports_num  Number of ports to allocate
- * @param event_cb   Clock event callback
- *
- * @return Pointer to a new array of clock ports or NULL on failure.
- */
-MMAL_PORT_T **mmal_ports_clock_alloc(MMAL_COMPONENT_T *component, unsigned int ports_num, MMAL_PORT_CLOCK_EVENT_CB event_cb);
-
-/** Free an array of clock ports.
- *
- * @param ports      The clock ports to free
- * @param ports_num  Number of ports to free
- */
-void mmal_ports_clock_free(MMAL_PORT_T **ports, unsigned int ports_num);
-
-/** Definition of a clock port request callback.
- * This is invoked when the media-time requested by the client is reached.
- *
- * @param port       The clock port which serviced the request
- * @param media_time The current media-time
- * @param cb_data    Client-supplied data
- */
-typedef void (*MMAL_PORT_CLOCK_REQUEST_CB)(MMAL_PORT_T *port, int64_t media_time, void *cb_data);
-
-/** Register a request with the clock port.
- * When the specified media-time is reached, the clock port will invoke the supplied callback.
- *
- * @param port       The clock port
- * @param media_time The media-time at which the callback should be invoked (microseconds)
- * @param offset     Time offset (in microseconds) applied to the media-time. This can be used
- *                   to schedule the request slightly in advance of the media-time.
- * @param cb         Callback to invoke
- * @param cb_data    Client-supplied callback data
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_clock_request_add(MMAL_PORT_T *port, int64_t media_time, int64_t offset,
-                                          MMAL_PORT_CLOCK_REQUEST_CB cb, void *cb_data);
-
-/** Remove all previously registered clock port requests.
- *
- * @param port       The clock port
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_clock_request_flush(MMAL_PORT_T *port);
-
-/** Update the clock port's media-time.
- *
- * @param port       The clock port to update
- * @param media_time New media-time to be applied (microseconds)
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_clock_media_time_set(MMAL_PORT_T *port, int64_t media_time);
-
-/** Set an offset for the port's media-time.
- *
- * @param port       The clock port to update
- * @param offset     Media-time offset (microseconds)
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_clock_media_time_offset_set(MMAL_PORT_T *port, int64_t offset);
-
-/** Get the clock port's current media-time.
- * This takes the clock port's scale and media-time offset into account.
- *
- * @param port       The clock port to query
- *
- * @return Current media-time in microseconds
- */
-int64_t mmal_port_clock_media_time_get(MMAL_PORT_T *port);
-
-/** Get the clock port's media-time offset.
- *
- * @param port       The clock port to query
- *
- * @return Media-time offset in microseconds
- */
-int64_t mmal_port_clock_media_time_offset_get(MMAL_PORT_T *port);
-
-/** Set the clock port's scale.
- *
- * @param port       The clock port
- * @param scale      Scale factor in Q16 format
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_clock_scale_set(MMAL_PORT_T *port, MMAL_RATIONAL_T scale);
-
-/** Get the clock port's scale.
- *
- * @param port       The clock port
- *
- * @return Current clock port scale factor
- */
-MMAL_RATIONAL_T mmal_port_clock_scale_get(MMAL_PORT_T *port);
-
-/** Get the clock port's state.
- *
- * @param port       The clock port to query
- *
- * @return TRUE if clock port is active (i.e. local media-time is advancing)
- */
-MMAL_BOOL_T mmal_port_clock_is_active(MMAL_PORT_T *port);
-
-#endif /* MMAL_PORT_PRIVATE_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_queue.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_queue.c
deleted file mode 100644
index bffab1c..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/core/mmal_queue.c
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "mmal_queue.h"
-
-/** Definition of the QUEUE */
-struct MMAL_QUEUE_T
-{
-   VCOS_MUTEX_T lock;
-   unsigned int length;
-   MMAL_BUFFER_HEADER_T *first;
-   MMAL_BUFFER_HEADER_T **last;
-   VCOS_SEMAPHORE_T semaphore;
-};
-
-/** Create a QUEUE of MMAL_BUFFER_HEADER_T */
-MMAL_QUEUE_T *mmal_queue_create(void)
-{
-   MMAL_QUEUE_T *queue;
-
-   queue = vcos_malloc(sizeof(*queue), "MMAL queue");
-   if(!queue) return 0;
-
-   if(vcos_mutex_create(&queue->lock, "MMAL queue lock") != VCOS_SUCCESS )
-   {
-      vcos_free(queue);
-      return 0;
-   }
-
-   if(vcos_semaphore_create(&queue->semaphore, "MMAL queue sema", 0) != VCOS_SUCCESS )
-   {
-      vcos_mutex_delete(&queue->lock);
-      vcos_free(queue);
-      return 0;
-   }
-
-   queue->length = 0;
-   queue->first = 0;
-   queue->last = &queue->first;
-   return queue;
-}
-
-/** Put a MMAL_BUFFER_HEADER_T into a QUEUE */
-void mmal_queue_put(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer)
-{
-   if(!queue || !buffer) return;
-
-	vcos_mutex_lock(&queue->lock);
-   queue->length++;
-   *queue->last = buffer;
-   buffer->next = 0;
-   queue->last = &buffer->next;
-   vcos_semaphore_post(&queue->semaphore);
-   vcos_mutex_unlock(&queue->lock);
-}
-
-/** Put a MMAL_BUFFER_HEADER_T back at the start of a QUEUE. */
-void mmal_queue_put_back(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer)
-{
-   if(!queue || !buffer) return;
-
-	vcos_mutex_lock(&queue->lock);
-   queue->length++;
-   buffer->next = queue->first;
-   queue->first = buffer;
-   if(queue->last == &queue->first) queue->last = &buffer->next;
-   vcos_semaphore_post(&queue->semaphore);
-   vcos_mutex_unlock(&queue->lock);
-}
-
-/** Get a MMAL_BUFFER_HEADER_T from a QUEUE. */
-MMAL_BUFFER_HEADER_T *mmal_queue_get(MMAL_QUEUE_T *queue)
-{
-   MMAL_BUFFER_HEADER_T *buffer;
-
-	if(!queue) return 0;
-
-   vcos_mutex_lock(&queue->lock);
-   buffer = queue->first;
-   if(!buffer)
-   {
-      vcos_mutex_unlock(&queue->lock);
-      return 0;
-   }
-
-   /* coverity[lock] This semaphore isn't being used as a mutex */
-   vcos_semaphore_wait(&queue->semaphore); /* Will always succeed */
-
-   queue->first = buffer->next;
-   if(!queue->first) queue->last = &queue->first;
-
-   queue->length--;
-   vcos_mutex_unlock(&queue->lock);
-
-   return buffer;
-}
-
-/** Wait for a MMAL_BUFFER_HEADER_T from a QUEUE. */
-MMAL_BUFFER_HEADER_T *mmal_queue_wait(MMAL_QUEUE_T *queue)
-{
-	if(!queue) return 0;
-
-	vcos_semaphore_wait(&queue->semaphore);
-   vcos_semaphore_post(&queue->semaphore);
-   return mmal_queue_get(queue);
-}
-
-/** Get the number of MMAL_BUFFER_HEADER_T currently in a QUEUE */
-unsigned int mmal_queue_length(MMAL_QUEUE_T *queue)
-{
-	if(!queue) return 0;
-
-	return queue->length;
-}
-
-/** Destroy a queue of MMAL_BUFFER_HEADER_T */
-void mmal_queue_destroy(MMAL_QUEUE_T *queue)
-{
-   if(!queue) return;
-   vcos_mutex_delete(&queue->lock);
-   vcos_semaphore_delete(&queue->semaphore);
-   vcos_free(queue);
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal.h
deleted file mode 100644
index e613f94..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal.h
+++ /dev/null
@@ -1,390 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/** \file
- * Multi-Media Abstraction Layer API
- */
-
-#ifndef MMAL_H
-#define MMAL_H
-
-/**
-  *
-  * \mainpage Multi-Media Abstraction Layer (MMAL). Draft Version 0.1.
-  *
-  * \par Contents
-  * - \ref intro_sec
-  * - \ref features
-  * - \ref concepts
-  * - \ref comp
-  * - \ref create
-  * - \ref port
-  * - \ref buf
-  * - \ref metadata
-  * - \ref queue
-  * - \ref pool
-  * - \ref param
-  * - \ref events
-  * - \ref version
-  * - \ref example
-  *
-  * \section intro_sec Introduction
-  *
-  * MMAL (Multi-Media Abstraction Layer) is a framework which is used to provide a host-side,
-  * simple and relatively low-level interface to multimedia components running on VideoCore.
-  * It also provides a component interface so that new components can be easily created and
-  * integrated into the framework.
-  *
-  * There is no requirement that all the components be running on VideoCore as MMAL doesn't
-  * put any restriction on where components live. The current implementation for instance
-  * provides some components which can be run on both host-side or VideoCore (e.g. the splitter
-  * component).
-  *
-  * \section features Features
-  *
-  * The MMAL API has been designed to support all the following features:
-  * - Sufficiently generic to support different kinds of multimedia component.
-  * - Simple to use from client side (mostly synchronous except where it matters).
-  * - Straightforward API for designing components (e.g. avoids multiple data paths, as found in RIL).
-  * - Allows for fully-optimised implementation of components (e.g. zero-copy buffer passing).
-  * - Portability (API is self-contained).
-  * - Supports multiple instances (e.g. of VideoCore).
-  * - Extensible without breaking source or binary backward compatibility.
-  *
-  * \section concepts API concepts
-  *
-  * The MMAL API is based on the concept of components, ports and buffer headers.
-  * Clients create MMAL components which expose ports for each individual
-  * elementary stream of data they support (e.g. audio/video). Components expose
-  * input ports to receive data from the client, and expose output ports
-  * to return data to the client.
-  *
-  * Data sent to or received from the component needs to be attached to a buffer header.
-  * Buffer headers are necessary because they contain buffer specific ancillary data which is
-  * necessary for the component and client to do their processing (e.g timestamps).
-  *
-  * \section comp Components
-  *
-  * MMAL lets clients create multi-media components (video encoders,
-  * video decoders, camera, and so-on) using a common API. Clients exchange
-  * data with components using buffer headers. A buffer header
-  * has a pointer to the payload data and optional metadata.
-  * Buffer headers are sent to and received from ports that are provided by components.
-  *
-  * A typical decoder component would have a single input port and a
-  * single output port, but the same architecture could also be used
-  * for components with different layouts (e.g. a camera with a
-  * capture and preview port, or a debugging component with just an input port).
-  *
-  * \subsection create Component Creation
-  *
-  * Each component is identified by a unique name. To create a specific component
-  * the client needs to call \ref mmal_component_create with the desired component's
-  * name as an argument.
-  * This call will return a context (\ref MMAL_COMPONENT_T) to the component. This
-  * context will expose the input and output ports (\ref MMAL_PORT_T) supported
-  * by this specific component.
-  *
-  * \note All VideoCore components have a name starting with the "vc." prefix (this prefix
-  * is used to distinguish when a creation request needs to be forwarded to VideoCore).
-  *
-  * \section port Component Ports
-  *
-  * A port (\ref MMAL_PORT_T) is the entity which exposes an elementary stream
-  * (\ref MMAL_ES_FORMAT_T) on a component. It is also the entity to which buffer headers
-  * (\ref MMAL_BUFFER_HEADER_T) are sent or from which they are received.
-  *
-  * Clients do not need to create ports. They are created automatically by
-  * the component when this one is created but the format of a port might need to
-  * be set by the client depending on the type of component the client is using.
-  *
-  * For example, for a video decoding component, one input port and one output port
-  * will be available. The format of the input port must be set by the
-  * client (using \ref mmal_port_format_commit) while the format of the output port
-  * will be automatically set by the component once the component has enough information
-  * to find out what its format should be.
-  *
-  * If the input port format contains enough information for the component to determine
-  * the format of the output port straight away, then the output port will be set to the proper
-  * format when \ref mmal_port_format_commit returns. Otherwise the output format will be set to
-  * \ref MMAL_ENCODING_UNKNOWN until the component is fed enough data to determine the format
-  * of the output port.
-  * When this happens, the client will receive an event on the output port, signalling
-  * that its format has changed.
-  *
-  * \section buf Buffer Headers
-  *
-  * Buffer headers (\ref MMAL_BUFFER_HEADER_T) are used to exchange data with components.
-  * They do not contain the data directly but instead contain a pointer to the data being
-  * transferred.
-  *
-  * Separating the buffer headers from the payload means that the memory for the data can
-  * be allocated outside of MMAL (e.g. if it is supplied by an external library) while still
-  * providing a consistent way to exchange data between clients and components.
-  *
-  * Buffer headers are allocated from pools and are reference counted. The refcount
-  * will drop when \ref mmal_buffer_header_release is called and the buffer header
-  * will be recycled to its pool when it reaches zero.
-  * The client can be notified when the buffer header is recycled so that it can recycle the
-  * associated payload memory as well.
-  *
-  * A pool of buffer headers should be created after committing the format of the port. When
-  * the format is changed, the minimum and recommended size and number of buffers may change.
-  *
-  * \note The current number of buffers and their size (\ref MMAL_PORT_T::buffer_num and \ref
-  * MMAL_PORT_T::buffer_size) are not modified by MMAL, and must be updated by the client as
-  * required after changes to a port's format.
-  *
-  * \subsection metadata Buffer Metadata
-  *
-  * The API provides a way for clients or components to associate metadata with buffer headers.
-  * A camera component could for example store information like exposure time or focal length
-  * as metadata within the buffer header containing the frame just captured.
-  * \note This area needs more work
-  *
-  * \subsection queue Queues of Buffer Headers
-  *
-  * Queues (\ref MMAL_QUEUE_T) are a facility that allows thread-safe processing of buffer headers
-  * from the client. Callbacks triggered by a MMAL component when it sends a buffer header to the
-  * client can simply put the buffer in a queue and let the main processing thread of the client
-  * get its data from the queue.
-  *
-  * \subsection pool Pools of Buffer Headers
-  *
-  * Pools (\ref MMAL_POOL_T) let clients allocate a fixed number of buffer headers, and 
-  * a queue (\ref MMAL_QUEUE_T). They are used for buffer header allocation.
-  * Optionally a pool can also allocate the payload memory for the client.
-  *
-  * Pools can also be resized after creation, for example, if the port format is changed leading
-  * to a new number or size of buffers being required.
-  *
-  * \section param Port Parameters
-  *
-  * Components support setting and getting component specific parameters using
-  * \ref mmal_port_parameter_set and \ref mmal_port_parameter_get. Parameters
-  * are identified using an integer index; parameter data is binary. See the \ref MMAL_PARAMETER_IDS
-  * "Pre-defined MMAL parameter IDs" page for more information on the pre-defined parameters.
-  *
-  * \section events Port Events
-  *
-  * Components can generate events on their ports. Events are sent to clients
-  * as buffer headers and thus when the client receives a buffer header on one
-  * of the component's port it should check if the buffer header is an event
-  * and in which case process it and then release it (\ref mmal_buffer_header_release).
-  * The reason for transmitting events in-band with the actual data is that it
-  * is often very valuable to know exactly when the event happens relative to the
-  * the actual data (e.g. with a focus event, from which video frame are we in focus).\n
-  * Buffer headers used to transmit events are allocated internally by the framework
-  * so it is important to release the buffer headers with \ref mmal_buffer_header_release
-  * so the buffer headers make it back to their actual owner.
-  *
-  * Event buffer headers are allocated when the component is created, based on the
-  * minimum number and size of control port buffers set by the component. Component
-  * wide events (not port specific) are sent to the control port callback when that
-  * port is enabled. Port events are sent to the port callback, the same as data
-  * buffers, but the 'cmd' field is non-zero.
-  *
-  * \section version Versioning
-  *
-  * The API requires that the MMAL core be the same or more recent version
-  * as the components and clients. Clients and components can be older and
-  * the API will still work both at compile-time and run-time.
-  *
-  * \section example Example Code
-  *
-  * The following code is a simple example on how to do video decoding using MMAL. Note that
-  * the code is intended to be clear and illustrate how to use MMAL at its most fundamental
-  * level, not necessarily the most efficient way to achieve the same result. Use of opaque
-  * images, tunneling and zero-copy inter-processor buffers can all improve the performance
-  * or reduce the load.
-  *
-  * The \ref MmalConnectionUtility "Port Connection Utility" functions can also be used to
-  * replace much of the common "boilerplate" code, especially when a pipeline of several
-  * components needs to be processed.
-  *
-  * \code
-  * #include <mmal.h>
-  * ...
-  * static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-  * {
-  *    // The decoder is done with the data, just recycle the buffer header into its pool
-  *    mmal_buffer_header_release(buffer);
-  * }
-  * static void output_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-  * {
-  *    MMAL_QUEUE_T *queue = (MMAL_QUEUE_T *)port->userdata;
-  *    mmal_queue_put(queue, buffer); // Queue the decoded video frame
-  * }
-  * ...
-  *
-  * MMAL_COMPONENT_T *decoder = 0;
-  * MMAL_STATUS_T status;
-  *
-  * // Create the video decoder component on VideoCore
-  * status = mmal_component_create("vc.ril.video_decoder", &decoder);
-  * ABORT_IF_ERROR(status);
-  *
-  * // Set format of video decoder input port
-  * MMAL_ES_FORMAT_T *format_in = decoder->input[0]->format;
-  * format_in->type = MMAL_ES_TYPE_VIDEO;
-  * format_in->encoding = MMAL_ENCODING_H264;
-  * format_in->es->video.width = 1280;
-  * format_in->es->video.height = 720;
-  * format_in->es->video.frame_rate.num = 30;
-  * format_in->es->video.frame_rate.den = 1;
-  * format_in->es->video.par.num = 1;
-  * format_in->es->video.par.den = 1;
-  * format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;
-  * status = mmal_format_extradata_alloc(format_in, YOUR_H264_CODEC_HEADER_BYTES_SIZE);
-  * ABORT_IF_ERROR(status);
-  * format_in->extradata_size = YOUR_H264_CODEC_HEADER_BYTES_SIZE;
-  * memcpy(format_in->extradata, YOUR_H264_CODEC_HEADER_BYTES, format_in->extradata_size);
-  *
-  * status = mmal_port_format_commit(decoder->input[0]);
-  * ABORT_IF_ERROR(status);
-  *
-  * // Once the call to mmal_port_format_commit() on the input port returns, the decoder will
-  * // have set the format of the output port.
-  * // If the decoder still doesn t have enough information to determine the format of the
-  * // output port, the encoding will be set to unknown. As soon as the decoder receives
-  * // enough stream data to determine the format of the output port it will send an event
-  * // to the client to signal that the format of the port has changed.
-  * // However, for the sake of simplicity this example assumes that the decoder was given
-  * // all the necessary information right at the start (i.e. video format and codec header bytes)
-  * MMAL_FORMAT_T *format_out = decoder->output[0]->format;
-  * if (format_out->encoding == MMAL_ENCODING_UNKNOWN)
-  *    ABORT();
-  *
-  * // Now we know the format of both ports and the requirements of the decoder, we can create
-  * // our buffer headers and their associated memory buffers. We use the buffer pool API for this.
-  * decoder->input[0]->buffer_num = decoder->input[0]->buffer_num_min;
-  * decoder->input[0]->buffer_size = decoder->input[0]->buffer_size_min;
-  * MMAL_POOL_T *pool_in = mmal_pool_create(decoder->input[0]->buffer_num,
-  *                                         decoder->input[0]->buffer_size);
-  * decoder->output[0]->buffer_num = decoder->output[0]->buffer_num_min;
-  * decoder->output[0]->buffer_size = decoder->output[0]->buffer_size_min;
-  * MMAL_POOL_T *pool_out = mmal_pool_create(decoder->output[0]->buffer_num,
-  *                                          decoder->output[0]->buffer_size);
-  *
-  * // Create a queue to store our decoded video frames. The callback we will get when
-  * // a frame has been decoded will put the frame into this queue.
-  * MMAL_QUEUE_T *queue_decoded_frames = mmal_queue_create();
-  * decoder->output[0]->userdata = (void)queue_decoded_frames;
-  *
-  * // Enable all the input port and the output port.
-  * // The callback specified here is the function which will be called when the buffer header
-  * // we sent to the component has been processed.
-  * status = mmal_port_enable(decoder->input[0], input_callback);
-  * ABORT_IF_ERROR(status);
-  * status = mmal_port_enable(decoder->output[0], output_callback);
-  * ABORT_IF_ERROR(status);
-  *
-  * // Enable the component. Components will only process data when they are enabled.
-  * status = mmal_component_enable(decoder);
-  * ABORT_IF_ERROR(status);
-  *
-  * // Data processing loop
-  * while (1)
-  * {
-  *    MMAL_BUFFER_HEADER_T *header;
-  *
-  *    // The client needs to implement its own blocking code.
-  *    // (e.g. a semaphore which is posted when a buffer header is put in one of the queues)
-  *    WAIT_FOR_QUEUES_TO_HAVE_BUFFERS();
-  *
-  *    // Send empty buffers to the output port of the decoder to allow the decoder to start
-  *    // producing frames as soon as it gets input data
-  *    while ((buffer = mmal_queue_get(pool_out->queue)) != NULL)
-  *    {
-  *       status = mmal_port_send_buffer(decoder->output[0], buffer);
-  *       ABORT_IF_ERROR(status);
-  *    }
-  *
-  *    // Send data to decode to the input port of the video decoder
-  *    if ((buffer = mmal_queue_get(pool_in->queue)) != NULL)
-  *    {
-  *       READ_DATA_INTO_BUFFER(buffer);
-  *
-  *       status = mmal_port_send_buffer(decoder->input[0], buffer);
-  *       ABORT_IF_ERROR(status);
-  *    }
-  *
-  *    // Get our decoded frames. We also need to cope with events
-  *    // generated from the component here.
-  *    while ((buffer = mmal_queue_get(queue_decoded_frames)) != NULL)
-  *    {
-  *       if (buffer->cmd)
-  *       {
-  *          // This is an event. Do something with it and release the buffer.
-  *          mmal_buffer_header_release(buffer);
-  *          continue;
-  *       }
-  *
-  *       // We have a frame, do something with it (why not display it for instance?).
-  *       // Once we're done with it, we release it. It will magically go back
-  *       // to its original pool so it can be reused for a new video frame.
-  *       mmal_buffer_header_release(buffer);
-  *    }
-  * }
-  *
-  * // Cleanup everything
-  * mmal_component_destroy(decoder);
-  * mmal_pool_destroy(pool_in);
-  * mmal_pool_destroy(pool_out);
-  * mmal_queue_destroy(queue_decode_frames);
-  *
-  * \endcode
-  */
-
-#include "mmal_common.h"
-#include "mmal_types.h"
-#include "mmal_port.h"
-#include "mmal_component.h"
-#include "mmal_parameters.h"
-#include "mmal_metadata.h"
-#include "mmal_queue.h"
-#include "mmal_pool.h"
-#include "mmal_events.h"
-
-/**/
-/** \name API Version
- * The following define the version number of the API */
-/* @{ */
-/** Major version number.
- * This changes when the API breaks in a way which is not backward compatible. */
-#define MMAL_VERSION_MAJOR 0
-/** Minor version number.
- * This changes each time the API is extended in a way which is still source and
- * binary compatible. */
-#define MMAL_VERSION_MINOR 1
-
-#define MMAL_VERSION (MMAL_VERSION_MAJOR << 16 | MMAL_VERSION_MINOR)
-#define MMAL_VERSION_TO_MAJOR(a) (a >> 16)
-#define MMAL_VERSION_TO_MINOR(a) (a & 0xFFFF)
-/* @} */
-
-#endif /* MMAL_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_buffer.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_buffer.h
deleted file mode 100644
index 2d5a972..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_buffer.h
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_BUFFER_H
-#define MMAL_BUFFER_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \defgroup MmalBufferHeader Buffer headers
- * Definition of a buffer header and its associated API.
- * Buffer headers are the basic element used to pass data and information between different
- * parts of the system. They are passed to components via ports and sent back to the client
- * using a callback mechanism.
- */
-/* @{ */
-
-/** Specific data associated with video frames */
-typedef struct {
-   uint32_t planes;     /**< Number of planes composing the video frame */
-   uint32_t offset[4];  /**< Offsets to the different planes. These must point within the
-                             payload buffer */
-   uint32_t pitch[4];   /**< Pitch (size in bytes of a line of a plane) of the different
-                             planes */
-   uint32_t flags;      /**< Flags describing video specific properties of a buffer header
-                             (see \ref videobufferheaderflags "Video buffer header flags") */
-   /* TBD stereoscopic support */
-} MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T;
-
-/** Type specific data that's associated with a payload buffer */
-typedef union
-{
-   /** Specific data associated with video frames */
-   MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T video;
-
-} MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T;
-
-/** Definition of the buffer header structure.
- * A buffer header does not directly carry the data to be passed to a component but instead
- * it references the actual data using a pointer (and an associated length).
- * It also contains an internal area which can be used to store command or metadata to be
- * associated with the external data.
- */
-typedef struct MMAL_BUFFER_HEADER_T
-{
-   struct MMAL_BUFFER_HEADER_T *next; /**< Used to link several buffer headers together */
-
-   struct MMAL_BUFFER_HEADER_PRIVATE_T *priv; /**< Data private to the framework */
-
-   uint32_t cmd;              /**< Defines what the buffer header contains. This is a FourCC
-                                   with 0 as a special value meaning stream data */
-
-   uint8_t  *data;            /**< Pointer to the start of the payload buffer (should not be
-                                   changed by component) */
-   uint32_t alloc_size;       /**< Allocated size in bytes of payload buffer */
-   uint32_t length;           /**< Number of bytes currently used in the payload buffer (starting
-                                   from offset) */
-   uint32_t offset;           /**< Offset in bytes to the start of valid data in the payload buffer */
-
-   uint32_t flags;            /**< Flags describing properties of a buffer header (see
-                                   \ref bufferheaderflags "Buffer header flags") */
-
-   int64_t  pts;              /**< Presentation timestamp in microseconds. \ref MMAL_TIME_UNKNOWN
-                                   is used when the pts is unknown. */
-   int64_t  dts;              /**< Decode timestamp in microseconds (dts = pts, except in the case
-                                   of video streams with B frames). \ref MMAL_TIME_UNKNOWN
-                                   is used when the dts is unknown. */
-
-   /** Type specific data that's associated with a payload buffer */
-   MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T *type;
-
-   void *user_data;           /**< Field reserved for use by the client */
-
-} MMAL_BUFFER_HEADER_T;
-
-/** \name Buffer header flags
- * \anchor bufferheaderflags
- * The following flags describe properties of a buffer header */
-/* @{ */
-/** Signals that the current payload is the end of the stream of data */
-#define MMAL_BUFFER_HEADER_FLAG_EOS                    (1<<0)
-/** Signals that the start of the current payload starts a frame */
-#define MMAL_BUFFER_HEADER_FLAG_FRAME_START            (1<<1)
-/** Signals that the end of the current payload ends a frame */
-#define MMAL_BUFFER_HEADER_FLAG_FRAME_END              (1<<2)
-/** Signals that the current payload contains only complete frames (1 or more) */
-#define MMAL_BUFFER_HEADER_FLAG_FRAME                  (MMAL_BUFFER_HEADER_FLAG_FRAME_START|MMAL_BUFFER_HEADER_FLAG_FRAME_END)
-/** Signals that the current payload is a keyframe (i.e. self decodable) */
-#define MMAL_BUFFER_HEADER_FLAG_KEYFRAME               (1<<3)
-/** Signals a discontinuity in the stream of data (e.g. after a seek).
- * Can be used for instance by a decoder to reset its state */
-#define MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY          (1<<4)
-/** Signals a buffer containing some kind of config data for the component
- * (e.g. codec config data) */
-#define MMAL_BUFFER_HEADER_FLAG_CONFIG                 (1<<5)
-/** Signals an encrypted payload */
-#define MMAL_BUFFER_HEADER_FLAG_ENCRYPTED              (1<<6)
-/** Signals a buffer containing side information */
-#define MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO          (1<<7)
-/** Signals a buffer which is the snapshot/postview image from a stills capture */
-#define MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT              (1<<8)
-/** Signals a buffer which contains data known to be corrupted */
-#define MMAL_BUFFER_HEADER_FLAG_CORRUPTED              (1<<9)
-/** Signals that a buffer failed to be transmitted */
-#define MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED    (1<<10)
-/* @} */
-
-/** \name Video buffer header flags
- * \anchor videobufferheaderflags
- * The following flags describe properties of a video buffer header */
-/* @{ */
-/** Signals an interlaced video frame */
-#define MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED       (1<<0)
-/** Signals that the top field of the current interlaced frame should be displayed first */
-#define MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST  (1<<2)
-/** Signals that the buffer should be displayed on external display if attached. */
-#define MMAL_BUFFER_HEADER_VIDEO_FLAG_DISPLAY_EXTERNAL (1<<3)
-/** Signals that contents of the buffer requires copy protection. */
-#define MMAL_BUFFER_HEADER_VIDEO_FLAG_PROTECTED        (1<<4)
-/* @} */
-
-/** Acquire a buffer header.
- * Acquiring a buffer header increases a reference counter on it and makes sure that the
- * buffer header won't be recycled until all the references to it are gone.
- * This is useful for instance if a component needs to return a buffer header but still needs
- * access to it for some internal processing (e.g. reference frames in video codecs).
- *
- * @param header buffer header to acquire
- */
-void mmal_buffer_header_acquire(MMAL_BUFFER_HEADER_T *header);
-
-/** Reset a buffer header.
- * Resets all header variables to default values.
- *
- * @param header buffer header to reset
- */
-void mmal_buffer_header_reset(MMAL_BUFFER_HEADER_T *header);
-
-/** Release a buffer header.
- * Releasing a buffer header will decrease its reference counter and when no more references
- * are left, the buffer header will be recycled by calling its 'release' callback function.
- *
- * If a pre-release callback is set (\ref MMAL_BH_PRE_RELEASE_CB_T), this will be invoked
- * before calling the buffer's release callback and potentially postpone buffer recycling.
- * Once pre-release is complete the buffer header is recycled with
- * \ref mmal_buffer_header_release_continue.
- *
- * @param header buffer header to release
- */
-void mmal_buffer_header_release(MMAL_BUFFER_HEADER_T *header);
-
-/** Continue the buffer header release process.
- * This should be called to complete buffer header recycling once all pre-release activity
- * has been completed.
- *
- * @param header buffer header to release
- */
-void mmal_buffer_header_release_continue(MMAL_BUFFER_HEADER_T *header);
-
-/** Buffer header pre-release callback.
- * The callback is invoked just before a buffer is released back into a
- * pool. This is used by clients who need to trigger additional actions
- * before the buffer can finally be released (e.g. wait for a bulk transfer
- * to complete).
- *
- * The callback should return TRUE if the buffer release need to be post-poned.
- *
- * @param header   buffer header about to be released
- * @param userdata user-specific data
- *
- * @return TRUE if the buffer should not be released
- */
-typedef MMAL_BOOL_T (*MMAL_BH_PRE_RELEASE_CB_T)(MMAL_BUFFER_HEADER_T *header, void *userdata);
-
-/** Set a buffer header pre-release callback.
- * If the callback is NULL, the buffer will be released back into the pool
- * immediately as usual.
- *
- * @param header   buffer header to associate callback with
- * @param cb       pre-release callback to invoke
- * @param userdata user-specific data
- */
-void mmal_buffer_header_pre_release_cb_set(MMAL_BUFFER_HEADER_T *header, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata);
-
-/** Replicate a buffer header into another one.
- * Replicating a buffer header will not only do an exact copy of all the public fields of the
- * buffer header (including data and alloc_size), but it will also acquire a reference to the
- * source buffer header which will only be released once the replicate has been released.
- *
- * @param dest buffer header into which to replicate
- * @param src buffer header to use as the source for the replication
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_buffer_header_replicate(MMAL_BUFFER_HEADER_T *dest, MMAL_BUFFER_HEADER_T *src);
-
-/** Lock the data buffer contained in the buffer header in memory.
- * This call does nothing on all platforms except VideoCore where it is needed to pin a
- * buffer in memory before any access to it.
- *
- * @param header buffer header to lock
- */
-MMAL_STATUS_T mmal_buffer_header_mem_lock(MMAL_BUFFER_HEADER_T *header);
-
-/** Unlock the data buffer contained in the buffer header.
- * This call does nothing on all platforms except VideoCore where it is needed to un-pin a
- * buffer in memory after any access to it.
- *
- * @param header buffer header to unlock
- */
-void mmal_buffer_header_mem_unlock(MMAL_BUFFER_HEADER_T *header);
-
-/* @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_BUFFER_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_clock.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_clock.h
deleted file mode 100644
index e88d2dc..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_clock.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-#ifndef MMAL_CLOCK_H
-#define MMAL_CLOCK_H
-
-#include "mmal_types.h"
-#include "mmal_common.h"
-
-/** \defgroup MmalClock Clock Framework
- * The MMAL clock framework provides scheduling facilities to the rest of
- * MMAL.
- *
- * The framework consists mainly of clock ports and a clock module. Client
- * applications and components interact directly with clock ports, while
- * the clock module is only used internally by clock ports.
- *
- * Clock ports ensure that the local media-time for each component is
- * synchronised across all components. This is done by passing buffers between
- * clock ports which contain clock-specific data.
- *
- * One clock port will normally act as the reference clock for the rest of the
- * system. This is usually chosen to be the clock port of the audio render
- * component, but is configurable by the client and could potentially be any
- * other clock port (or even the client application itself).
- *
- * Components that are responsible for timed delivery of frames, do so by
- * registering callback requests for a particular time-stamp with the clock
- * port. These requests are scheduled using the clock module which maintains
- * an internal media-time.
- *
- * The clock framework also provides the ability to perform playback at different
- * speeds. This is achieved with a clock scale factor which determines the speed
- * at which the media-time advances relative to real-time, with:
- *   scale = 1.0 -> normal playback speed
- *   scale = 0   -> playback paused
- *   scale > 1.0 -> fast-forward
- *   scale < 1.0 -> slow motion
- */
-
-/** Clock payload magic */
-#define MMAL_CLOCK_PAYLOAD_MAGIC     MMAL_FOURCC('C','K','L','M')
-
-/** Clock reference update */
-#define MMAL_CLOCK_PAYLOAD_REFERENCE MMAL_FOURCC('C','R','E','F')
-
-/** Clock state update */
-#define MMAL_CLOCK_PAYLOAD_ACTIVE    MMAL_FOURCC('C','A','C','T')
-
-/** Clock scale update */
-#define MMAL_CLOCK_PAYLOAD_SCALE     MMAL_FOURCC('C','S','C','A')
-
-/** Clock media-time update */
-#define MMAL_CLOCK_PAYLOAD_TIME      MMAL_FOURCC('C','T','I','M')
-
-/** Clock payload not valid */
-#define MMAL_CLOCK_PAYLOAD_INVALID   0
-
-/** Clock buffer payload type used to pass data between clock ports
- * and for signalling a clock event to a client. */
-typedef struct MMAL_CLOCK_PAYLOAD_T
-{
-   uint32_t id;                 /**< 4cc payload id */
-   uint32_t magic;              /**< 4cc payload magic */
-   int64_t time;                /**< media-time at which the event ocurred */
-   union
-   {
-      MMAL_BOOL_T enable;       /**< clock reference or clock active */
-      MMAL_RATIONAL_T scale;    /**< new clock scale */
-   } data;
-} MMAL_CLOCK_PAYLOAD_T;
-
-#endif /* MMAL_CLOCK_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_common.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_common.h
deleted file mode 100644
index c1b186b..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_common.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/** \file mmal_common.h
- * Multi-Media Abstraction Layer - Common definitions
- */
-
-#ifndef MMAL_COMMON_H
-#define MMAL_COMMON_H
-
-#include <stdlib.h>
-#include <string.h>
-#include <stddef.h>
-#include <assert.h>
-
-#include <interface/vcos/vcos.h>
-
-/* C99 64bits integers */
-#ifndef INT64_C
-# define INT64_C(value) value##LL
-# define UINT64_C(value) value##ULL
-#endif
-
-#define MMAL_TSRING(s) #s
-#define MMAL_TO_STRING(s) MMAL_TSRING(s)
-
-#define MMAL_COUNTOF(x) (sizeof((x))/sizeof((x)[0]))
-#define MMAL_MIN(a,b) ((a)<(b)?(a):(b))
-#define MMAL_MAX(a,b) ((a)<(b)?(b):(a))
-
-/* FIXME: should be different for big endian */
-#define MMAL_FOURCC(a,b,c,d) ((a) | (b << 8) | (c << 16) | (d << 24))
-#define MMAL_PARAM_UNUSED(a) (void)(a)
-#define MMAL_MAGIC MMAL_FOURCC('m','m','a','l')
-
-typedef int32_t MMAL_BOOL_T;
-#define MMAL_FALSE   0
-#define MMAL_TRUE    1
-
-typedef struct MMAL_CORE_STATISTICS_T
-{
-   uint32_t buffer_count;        /**< Total buffer count on this port */
-   uint32_t first_buffer_time;   /**< Time (us) of first buffer seen on this port */
-   uint32_t last_buffer_time;    /**< Time (us) of most recently buffer on this port */
-   uint32_t max_delay;           /**< Max delay (us) between buffers, ignoring first few frames */
-} MMAL_CORE_STATISTICS_T;
-
-/** Statistics collected by the core on all ports, if enabled in the build.
- */
-typedef struct MMAL_CORE_PORT_STATISTICS_T
-{
-   MMAL_CORE_STATISTICS_T rx;
-   MMAL_CORE_STATISTICS_T tx;
-} MMAL_CORE_PORT_STATISTICS_T;
-
-/** Unsigned 16.16 fixed point value, also known as Q16.16 */
-typedef uint32_t MMAL_FIXED_16_16_T;
-
-#endif /* MMAL_COMMON_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_component.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_component.h
deleted file mode 100644
index 6c9d104..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_component.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_COMPONENT_H
-#define MMAL_COMPONENT_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \defgroup MmalComponent Components
- * Definition of a MMAL component and its associated API. A component will always expose ports
- * which it uses to send and receive data in the form of buffer headers
- * (\ref MMAL_BUFFER_HEADER_T) */
-/* @{ */
-
-#include "mmal_types.h"
-#include "mmal_port.h"
-
-struct MMAL_COMPONENT_PRIVATE_T;
-typedef struct MMAL_COMPONENT_PRIVATE_T MMAL_COMPONENT_PRIVATE_T;
-
-/** Definition of a component. */
-typedef struct MMAL_COMPONENT_T
-{
-   /** Pointer to the private data of the module in use */
-   struct MMAL_COMPONENT_PRIVATE_T *priv;
-
-   /** Pointer to private data of the client */
-   struct MMAL_COMPONENT_USERDATA_T *userdata;
-
-   /** Component name */
-   const char *name;
-
-   /** Specifies whether the component is enabled or not */
-   uint32_t is_enabled;
-
-   /** All components expose a control port.
-    * The control port is used by clients to set / get parameters that are global to the
-    * component. It is also used to receive events, which again are global to the component.
-    * To be able to receive events, the client needs to enable and register a callback on the
-    * control port. */
-   MMAL_PORT_T *control;
-
-   uint32_t    input_num;   /**< Number of input ports */
-   MMAL_PORT_T **input;     /**< Array of input ports */
-
-   uint32_t    output_num;  /**< Number of output ports */
-   MMAL_PORT_T **output;    /**< Array of output ports */
-
-   uint32_t    clock_num;   /**< Number of clock ports */
-   MMAL_PORT_T **clock;     /**< Array of clock ports */
-
-   uint32_t    port_num;    /**< Total number of ports */
-   MMAL_PORT_T **port;      /**< Array of all the ports (control/input/output/clock) */
-
-   /** Uniquely identifies the component's instance within the MMAL
-    * context / process. For debugging. */
-   uint32_t id;
-
-} MMAL_COMPONENT_T;
-
-/** Create an instance of a component.
- * The newly created component will expose ports to the client. All the exposed ports are
- * disabled by default.
- * Note that components are reference counted and creating a component automatically
- * acquires a reference to it (released when \ref mmal_component_destroy is called).
- *
- * @param name name of the component to create, e.g. "video_decode"
- * @param component returned component
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_component_create(const char *name,
-                                    MMAL_COMPONENT_T **component);
-
-/** Acquire a reference on a component.
- * Acquiring a reference on a component will prevent a component from being destroyed until
- * the acquired reference is released (by a call to \ref mmal_component_destroy).
- * References are internally counted so all acquired references need a matching call to
- * release them.
- *
- * @param component component to acquire
- */
-void mmal_component_acquire(MMAL_COMPONENT_T *component);
-
-/** Release a reference on a component
- * Release an acquired reference on a component. Triggers the destruction of the component when
- * the last reference is being released.
- * \note This is in fact an alias of \ref mmal_component_destroy which is added to make client
- * code clearer.
- *
- * @param component component to release
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_component_release(MMAL_COMPONENT_T *component);
-
-/** Destroy a previously created component
- * Release an acquired reference on a component. Only actually destroys the component when
- * the last reference is being released.
- *
- * @param component component to destroy
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_component_destroy(MMAL_COMPONENT_T *component);
-
-/** Enable processing on a component
- * @param component component to enable
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_component_enable(MMAL_COMPONENT_T *component);
-
-/** Disable processing on a component
- * @param component component to disable
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_component_disable(MMAL_COMPONENT_T *component);
-
-/* @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_COMPONENT_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_encodings.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_encodings.h
deleted file mode 100644
index 0e09b57..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_encodings.h
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_ENCODINGS_H
-#define MMAL_ENCODINGS_H
-
-#include "mmal_common.h"
-
-/** \defgroup MmalEncodings List of pre-defined encodings
- * This defines a list of common encodings. This list isn't exhaustive and is only
- * provided as a convenience to avoid clients having to use FourCC codes directly.
- * However components are allowed to define and use their own FourCC codes. */
-/* @{ */
-
-/** \name Pre-defined video encodings */
-/* @{ */
-#define MMAL_ENCODING_H264             MMAL_FOURCC('H','2','6','4')
-#define MMAL_ENCODING_H263             MMAL_FOURCC('H','2','6','3')
-#define MMAL_ENCODING_MP4V             MMAL_FOURCC('M','P','4','V')
-#define MMAL_ENCODING_MP2V             MMAL_FOURCC('M','P','2','V')
-#define MMAL_ENCODING_MP1V             MMAL_FOURCC('M','P','1','V')
-#define MMAL_ENCODING_WMV3             MMAL_FOURCC('W','M','V','3')
-#define MMAL_ENCODING_WMV2             MMAL_FOURCC('W','M','V','2')
-#define MMAL_ENCODING_WMV1             MMAL_FOURCC('W','M','V','1')
-#define MMAL_ENCODING_WVC1             MMAL_FOURCC('W','V','C','1')
-#define MMAL_ENCODING_VP8              MMAL_FOURCC('V','P','8',' ')
-#define MMAL_ENCODING_VP7              MMAL_FOURCC('V','P','7',' ')
-#define MMAL_ENCODING_VP6              MMAL_FOURCC('V','P','6',' ')
-#define MMAL_ENCODING_THEORA           MMAL_FOURCC('T','H','E','O')
-#define MMAL_ENCODING_SPARK            MMAL_FOURCC('S','P','R','K')
-
-#define MMAL_ENCODING_JPEG             MMAL_FOURCC('J','P','E','G')
-#define MMAL_ENCODING_GIF              MMAL_FOURCC('G','I','F',' ')
-#define MMAL_ENCODING_PNG              MMAL_FOURCC('P','N','G',' ')
-#define MMAL_ENCODING_PPM              MMAL_FOURCC('P','P','M',' ')
-#define MMAL_ENCODING_TGA              MMAL_FOURCC('T','G','A',' ')
-#define MMAL_ENCODING_BMP              MMAL_FOURCC('B','M','P',' ')
-
-#define MMAL_ENCODING_I420             MMAL_FOURCC('I','4','2','0')
-#define MMAL_ENCODING_I420_SLICE       MMAL_FOURCC('S','4','2','0')
-#define MMAL_ENCODING_YV12             MMAL_FOURCC('Y','V','1','2')
-#define MMAL_ENCODING_I422             MMAL_FOURCC('I','4','2','2')
-#define MMAL_ENCODING_I422_SLICE       MMAL_FOURCC('S','4','2','2')
-#define MMAL_ENCODING_YUYV             MMAL_FOURCC('Y','U','Y','V')
-#define MMAL_ENCODING_YVYU             MMAL_FOURCC('Y','V','Y','U')
-#define MMAL_ENCODING_UYVY             MMAL_FOURCC('U','Y','V','Y')
-#define MMAL_ENCODING_VYUY             MMAL_FOURCC('V','Y','U','Y')
-#define MMAL_ENCODING_NV12             MMAL_FOURCC('N','V','1','2')
-#define MMAL_ENCODING_NV21             MMAL_FOURCC('N','V','2','1')
-#define MMAL_ENCODING_ARGB             MMAL_FOURCC('A','R','G','B')
-#define MMAL_ENCODING_RGBA             MMAL_FOURCC('R','G','B','A')
-#define MMAL_ENCODING_ABGR             MMAL_FOURCC('A','B','G','R')
-#define MMAL_ENCODING_BGRA             MMAL_FOURCC('B','G','R','A')
-#define MMAL_ENCODING_RGB16            MMAL_FOURCC('R','G','B','2')
-#define MMAL_ENCODING_RGB24            MMAL_FOURCC('R','G','B','3')
-#define MMAL_ENCODING_RGB32            MMAL_FOURCC('R','G','B','4')
-#define MMAL_ENCODING_BGR16            MMAL_FOURCC('B','G','R','2')
-#define MMAL_ENCODING_BGR24            MMAL_FOURCC('B','G','R','3')
-#define MMAL_ENCODING_BGR32            MMAL_FOURCC('B','G','R','4')
-
-/** SAND Video (YUVUV128) format, native format understood by VideoCore.
- * This format is *not* opaque - if requested you will receive full frames
- * of YUV_UV video.
- */
-#define MMAL_ENCODING_YUVUV128         MMAL_FOURCC('S','A','N','D')
-
-/** VideoCore opaque image format, image handles are returned to
- * the host but not the actual image data.
- */
-#define MMAL_ENCODING_OPAQUE           MMAL_FOURCC('O','P','Q','V')
-
-/** An EGL image handle
- */
-#define MMAL_ENCODING_EGL_IMAGE        MMAL_FOURCC('E','G','L','I')
-
-/* }@ */
-
-/** \name Pre-defined audio encodings */
-/* @{ */
-#define MMAL_ENCODING_PCM_UNSIGNED_BE  MMAL_FOURCC('P','C','M','U')
-#define MMAL_ENCODING_PCM_UNSIGNED_LE  MMAL_FOURCC('p','c','m','u')
-#define MMAL_ENCODING_PCM_SIGNED_BE    MMAL_FOURCC('P','C','M','S')
-#define MMAL_ENCODING_PCM_SIGNED_LE    MMAL_FOURCC('p','c','m','s')
-#define MMAL_ENCODING_PCM_FLOAT_BE     MMAL_FOURCC('P','C','M','F')
-#define MMAL_ENCODING_PCM_FLOAT_LE     MMAL_FOURCC('p','c','m','f')
-/* Defines for native endianness */
-#ifdef MMAL_IS_BIG_ENDIAN
-#define MMAL_ENCODING_PCM_UNSIGNED     MMAL_ENCODING_PCM_UNSIGNED_BE
-#define MMAL_ENCODING_PCM_SIGNED       MMAL_ENCODING_PCM_SIGNED_BE
-#define MMAL_ENCODING_PCM_FLOAT        MMAL_ENCODING_PCM_FLOAT_BE
-#else
-#define MMAL_ENCODING_PCM_UNSIGNED     MMAL_ENCODING_PCM_UNSIGNED_LE
-#define MMAL_ENCODING_PCM_SIGNED       MMAL_ENCODING_PCM_SIGNED_LE
-#define MMAL_ENCODING_PCM_FLOAT        MMAL_ENCODING_PCM_FLOAT_LE
-#endif
-
-#define MMAL_ENCODING_MP4A             MMAL_FOURCC('M','P','4','A')
-#define MMAL_ENCODING_MPGA             MMAL_FOURCC('M','P','G','A')
-#define MMAL_ENCODING_ALAW             MMAL_FOURCC('A','L','A','W')
-#define MMAL_ENCODING_MULAW            MMAL_FOURCC('U','L','A','W')
-#define MMAL_ENCODING_ADPCM_MS         MMAL_FOURCC('M','S',0x0,0x2)
-#define MMAL_ENCODING_ADPCM_IMA_MS     MMAL_FOURCC('M','S',0x0,0x1)
-#define MMAL_ENCODING_ADPCM_SWF        MMAL_FOURCC('A','S','W','F')
-#define MMAL_ENCODING_WMA1             MMAL_FOURCC('W','M','A','1')
-#define MMAL_ENCODING_WMA2             MMAL_FOURCC('W','M','A','2')
-#define MMAL_ENCODING_WMAP             MMAL_FOURCC('W','M','A','P')
-#define MMAL_ENCODING_WMAL             MMAL_FOURCC('W','M','A','L')
-#define MMAL_ENCODING_AMRNB            MMAL_FOURCC('A','M','R','N')
-#define MMAL_ENCODING_AMRWB            MMAL_FOURCC('A','M','R','W')
-#define MMAL_ENCODING_AMRWBP           MMAL_FOURCC('A','M','R','P')
-#define MMAL_ENCODING_AC3              MMAL_FOURCC('A','C','3',' ')
-#define MMAL_ENCODING_EAC3             MMAL_FOURCC('E','A','C','3')
-#define MMAL_ENCODING_DTS              MMAL_FOURCC('D','T','S',' ')
-#define MMAL_ENCODING_MLP              MMAL_FOURCC('M','L','P',' ')
-#define MMAL_ENCODING_FLAC             MMAL_FOURCC('F','L','A','C')
-#define MMAL_ENCODING_VORBIS           MMAL_FOURCC('V','O','R','B')
-#define MMAL_ENCODING_SPEEX            MMAL_FOURCC('S','P','X',' ')
-#define MMAL_ENCODING_ATRAC3           MMAL_FOURCC('A','T','R','3')
-#define MMAL_ENCODING_ATRACX           MMAL_FOURCC('A','T','R','X')
-#define MMAL_ENCODING_ATRACL           MMAL_FOURCC('A','T','R','L')
-#define MMAL_ENCODING_MIDI             MMAL_FOURCC('M','I','D','I')
-#define MMAL_ENCODING_EVRC             MMAL_FOURCC('E','V','R','C')
-#define MMAL_ENCODING_NELLYMOSER       MMAL_FOURCC('N','E','L','Y')
-#define MMAL_ENCODING_QCELP            MMAL_FOURCC('Q','C','E','L')
-#define MMAL_ENCODING_MP4V_DIVX_DRM    MMAL_FOURCC('M','4','V','D')
-/* @} */
-
-/* @} MmalEncodings List */
-
-/** \defgroup MmalEncodingVariants List of pre-defined encoding variants
- * This defines a list of common encoding variants. This list isn't exhaustive and is only
- * provided as a convenience to avoid clients having to use FourCC codes directly.
- * However components are allowed to define and use their own FourCC codes. */
-/* @{ */
-
-/** \name Pre-defined H264 encoding variants */
-/* @{ */
-/** ISO 14496-10 Annex B byte stream format */
-#define MMAL_ENCODING_VARIANT_H264_DEFAULT   0
-/** ISO 14496-15 AVC stream format */
-#define MMAL_ENCODING_VARIANT_H264_AVC1      MMAL_FOURCC('A','V','C','1')
-/** Implicitly delineated NAL units without emulation prevention */
-#define MMAL_ENCODING_VARIANT_H264_RAW       MMAL_FOURCC('R','A','W',' ')
-/* @} */
-
-/** \name Pre-defined MPEG4 audio encoding variants */
-/* @{ */
-/** Raw stream format */
-#define MMAL_ENCODING_VARIANT_MP4A_DEFAULT   0
-/** ADTS stream format */
-#define MMAL_ENCODING_VARIANT_MP4A_ADTS      MMAL_FOURCC('A','D','T','S')
-/* @} */
-
-/* @} MmalEncodingVariants List */
-
-/** \defgroup MmalColorSpace List of pre-defined video color spaces
- * This defines a list of common color spaces. This list isn't exhaustive and is only
- * provided as a convenience to avoid clients having to use FourCC codes directly.
- * However components are allowed to define and use their own FourCC codes. */
-/* @{ */
-
-/** Unknown color space */
-#define MMAL_COLOR_SPACE_UNKNOWN       0
-/** ITU-R BT.601-5 [SDTV] */
-#define MMAL_COLOR_SPACE_ITUR_BT601    MMAL_FOURCC('Y','6','0','1')
-/** ITU-R BT.709-3 [HDTV] */
-#define MMAL_COLOR_SPACE_ITUR_BT709    MMAL_FOURCC('Y','7','0','9')
-/** JPEG JFIF */
-#define MMAL_COLOR_SPACE_JPEG_JFIF     MMAL_FOURCC('Y','J','F','I')
-/** Title 47 Code of Federal Regulations (2003) 73.682 (a) (20) */
-#define MMAL_COLOR_SPACE_FCC           MMAL_FOURCC('Y','F','C','C')
-/** Society of Motion Picture and Television Engineers 240M (1999) */
-#define MMAL_COLOR_SPACE_SMPTE240M     MMAL_FOURCC('Y','2','4','0')
-/** ITU-R BT.470-2 System M */
-#define MMAL_COLOR_SPACE_BT470_2_M     MMAL_FOURCC('Y','_','_','M')
-/** ITU-R BT.470-2 System BG */
-#define MMAL_COLOR_SPACE_BT470_2_BG    MMAL_FOURCC('Y','_','B','G')
-/** JPEG JFIF, but with 16..255 luma */
-#define MMAL_COLOR_SPACE_JFIF_Y16_255  MMAL_FOURCC('Y','Y','1','6')
-/* @} MmalColorSpace List */
-
-#endif /* MMAL_ENCODINGS_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_events.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_events.h
deleted file mode 100644
index ac82ed0..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_events.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_EVENTS_H
-#define MMAL_EVENTS_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "mmal_common.h"
-#include "mmal_parameters.h"
-#include "mmal_port.h"
-
-/** \defgroup MmalEvents List of pre-defined event types
- * This defines a list of standard event types. Components can still define proprietary
- * event types by using their own FourCC and defining their own event structures. */
-/* @{ */
-
-/** \name Pre-defined event FourCCs */
-/* @{ */
-
-/** Error event. Data contains a \ref MMAL_STATUS_T */
-#define MMAL_EVENT_ERROR                     MMAL_FOURCC('E','R','R','O')
-
-/** End-of-stream event. Data contains a \ref MMAL_EVENT_END_OF_STREAM_T */
-#define MMAL_EVENT_EOS                       MMAL_FOURCC('E','E','O','S')
-
-/** Format changed event. Data contains a \ref MMAL_EVENT_FORMAT_CHANGED_T */
-#define MMAL_EVENT_FORMAT_CHANGED            MMAL_FOURCC('E','F','C','H')
-
-/** Parameter changed event. Data contains the new parameter value, see
- * \ref MMAL_EVENT_PARAMETER_CHANGED_T
- */
-#define MMAL_EVENT_PARAMETER_CHANGED         MMAL_FOURCC('E','P','C','H')
-
-/* @} */
-
-
-/** End-of-stream event. */
-typedef struct MMAL_EVENT_END_OF_STREAM_T
-{
-   MMAL_PORT_TYPE_T port_type;   /**< Type of port that received the end of stream */
-   uint32_t port_index;          /**< Index of port that received the end of stream */
-} MMAL_EVENT_END_OF_STREAM_T;
-
-/** Format changed event data. */
-typedef struct MMAL_EVENT_FORMAT_CHANGED_T
-{
-   uint32_t buffer_size_min;         /**< Minimum size of buffers the port requires */
-   uint32_t buffer_num_min;          /**< Minimum number of buffers the port requires */
-   uint32_t buffer_size_recommended; /**< Size of buffers the port recommends for optimal performance.
-                                          A value of zero means no special recommendation. */
-   uint32_t buffer_num_recommended;  /**< Number of buffers the port recommends for optimal
-                                          performance. A value of zero means no special recommendation. */
-
-   MMAL_ES_FORMAT_T *format;         /**< New elementary stream format */
-} MMAL_EVENT_FORMAT_CHANGED_T;
-
-/** Parameter changed event data.
- * This is a variable sized event. The full parameter is included in the event
- * data, not just the header. Use the \ref MMAL_PARAMETER_HEADER_T::id field to determine how to
- * cast the structure. The \ref MMAL_PARAMETER_HEADER_T::size field can be used to check validity.
- */
-typedef struct MMAL_EVENT_PARAMETER_CHANGED_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-} MMAL_EVENT_PARAMETER_CHANGED_T;
-
-/** Get a pointer to the \ref MMAL_EVENT_FORMAT_CHANGED_T structure contained in the buffer header.
- * Note that the pointer will point inside the data contained in the buffer header
- * so doesn't need to be freed explicitly.
- *
- * @param buffer buffer header containing the MMAL_EVENT_FORMAT_CHANGED event.
- * @return pointer to a MMAL_EVENT_FORMAT_CHANGED_T structure.
- */
-MMAL_EVENT_FORMAT_CHANGED_T *mmal_event_format_changed_get(MMAL_BUFFER_HEADER_T *buffer);
-
-/** Send an error event to the component's control port.
- * The error event data will be the MMAL_STATUS_T passed in.
- *
- * @param component component to receive the error event.
- * @param error_status the error status to be sent.
- * @return MMAL_SUCCESS or an error if the event could not be sent.
- */
-MMAL_STATUS_T mmal_event_error_send(MMAL_COMPONENT_T *component, MMAL_STATUS_T error_status);
-
-/* @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_EVENTS_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_format.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_format.h
deleted file mode 100644
index 78c0844..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_format.h
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_FORMAT_H
-#define MMAL_FORMAT_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \defgroup MmalFormat Elementary stream format
- * Definition of an elementary stream format and its associated API */
-/* @{ */
-
-#include "mmal_types.h"
-#include "mmal_encodings.h"
-
-/** Enumeration of the different types of elementary streams.
- * This divides elementary streams into 4 big categories, plus an invalid type. */
-typedef enum {
-   MMAL_ES_TYPE_UNKNOWN,     /**< Unknown elementary stream type */
-   MMAL_ES_TYPE_CONTROL,     /**< Elementary stream of control commands */
-   MMAL_ES_TYPE_AUDIO,       /**< Audio elementary stream */
-   MMAL_ES_TYPE_VIDEO,       /**< Video elementary stream */
-   MMAL_ES_TYPE_SUBPICTURE   /**< Sub-picture elementary stream (e.g. subtitles, overlays) */
-} MMAL_ES_TYPE_T;
-
-/** Definition of a video format.
- * This describes the properties specific to a video stream */
-typedef struct
-{
-   uint32_t        width;        /**< Width of frame in pixels */
-   uint32_t        height;       /**< Height of frame in rows of pixels */
-   MMAL_RECT_T     crop;         /**< Visible region of the frame */
-   MMAL_RATIONAL_T frame_rate;   /**< Frame rate */
-   MMAL_RATIONAL_T par;          /**< Pixel aspect ratio */
-
-   MMAL_FOURCC_T   color_space;  /**< FourCC specifying the color space of the
-                                   * video stream. See the \ref MmalColorSpace
-                                   * "pre-defined color spaces" for some examples.
-                                   */
-
-} MMAL_VIDEO_FORMAT_T;
-
-/** Definition of an audio format.
- * This describes the properties specific to an audio stream */
-typedef struct MMAL_AUDIO_FORMAT_T
-{
-   uint32_t channels;           /**< Number of audio channels */
-   uint32_t sample_rate;        /**< Sample rate */
-
-   uint32_t bits_per_sample;    /**< Bits per sample */
-   uint32_t block_align;        /**< Size of a block of data */
-
-   /** \todo add channel mapping, gapless and replay-gain support */
-
-} MMAL_AUDIO_FORMAT_T;
-
-/** Definition of a subpicture format.
- * This describes the properties specific to a subpicture stream */
-typedef struct
-{
-   uint32_t x_offset;        /**< Width offset to the start of the subpicture */
-   uint32_t y_offset;        /**< Height offset to the start of the subpicture */
-
-   /** \todo surely more things are needed here */
-
-} MMAL_SUBPICTURE_FORMAT_T;
-
-/** Definition of the type specific format.
- * This describes the type specific information of the elementary stream. */
-typedef union
-{
-   MMAL_AUDIO_FORMAT_T      audio;      /**< Audio specific information */
-   MMAL_VIDEO_FORMAT_T      video;      /**< Video specific information */
-   MMAL_SUBPICTURE_FORMAT_T subpicture; /**< Subpicture specific information */
-} MMAL_ES_SPECIFIC_FORMAT_T;
-
-/** \name Elementary stream flags
- * \anchor elementarystreamflags
- * The following flags describe properties of an elementary stream */
-/* @{ */
-#define MMAL_ES_FORMAT_FLAG_FRAMED       0x1 /**< The elementary stream will already be framed */
-/* @} */
-
-/** \name Undefined encoding value.
- * This value indicates an unknown encoding
- */
-/* @{ */
-#define MMAL_ENCODING_UNKNOWN            0
-/* @} */
-
-/** \name Default encoding variant value.
- * This value indicates the default encoding variant is used
- */
-/* @{ */
-#define MMAL_ENCODING_VARIANT_DEFAULT    0
-/* @} */
-
-/** Definition of an elementary stream format */
-typedef struct MMAL_ES_FORMAT_T
-{
-   MMAL_ES_TYPE_T type;           /**< Type of the elementary stream */
-
-   MMAL_FOURCC_T encoding;        /**< FourCC specifying the encoding of the elementary stream.
-                                    * See the \ref MmalEncodings "pre-defined encodings" for some
-                                    * examples.
-                                    */
-   MMAL_FOURCC_T encoding_variant;/**< FourCC specifying the specific encoding variant of
-                                    * the elementary stream. See the \ref MmalEncodingVariants
-                                    * "pre-defined encoding variants" for some examples.
-                                    */
-
-   MMAL_ES_SPECIFIC_FORMAT_T *es; /**< Type specific information for the elementary stream */
-
-   uint32_t bitrate;              /**< Bitrate in bits per second */
-   uint32_t flags;                /**< Flags describing properties of the elementary stream.
-                                    * See \ref elementarystreamflags "Elementary stream flags".
-                                    */
-
-   uint32_t extradata_size;       /**< Size of the codec specific data */
-   uint8_t  *extradata;           /**< Codec specific data */
-
-} MMAL_ES_FORMAT_T;
-
-/** Allocate and initialise a \ref MMAL_ES_FORMAT_T structure.
- *
- * @return a \ref MMAL_ES_FORMAT_T structure
- */
-MMAL_ES_FORMAT_T *mmal_format_alloc(void);
-
-/** Free a \ref MMAL_ES_FORMAT_T structure allocated by \ref mmal_format_alloc.
- *
- * @param format the \ref MMAL_ES_FORMAT_T structure to free
- */
-void mmal_format_free(MMAL_ES_FORMAT_T *format);
-
-/** Allocate the extradata buffer in \ref MMAL_ES_FORMAT_T.
- * This buffer will be freed automatically when the format is destroyed or
- * another allocation is done.
- *
- * @param format format structure for which the extradata buffer will be allocated
- * @param size size of the extradata buffer to allocate
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_format_extradata_alloc(MMAL_ES_FORMAT_T *format, unsigned int size);
-
-/** Shallow copy a format structure.
- * It is worth noting that the extradata buffer will not be copied in the new format.
- *
- * @param format_dest destination \ref MMAL_ES_FORMAT_T for the copy
- * @param format_src source \ref MMAL_ES_FORMAT_T for the copy
- */
-void mmal_format_copy(MMAL_ES_FORMAT_T *format_dest, MMAL_ES_FORMAT_T *format_src);
-
-/** Fully copy a format structure, including the extradata buffer.
- *
- * @param format_dest destination \ref MMAL_ES_FORMAT_T for the copy
- * @param format_src source \ref MMAL_ES_FORMAT_T for the copy
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_format_full_copy(MMAL_ES_FORMAT_T *format_dest, MMAL_ES_FORMAT_T *format_src);
-
-/** \name Comparison flags
- * \anchor comparisonflags
- * The following flags describe the differences between 2 format structures */
-/* @{ */
-#define MMAL_ES_FORMAT_COMPARE_FLAG_TYPE              0x01 /**< The type is different */
-#define MMAL_ES_FORMAT_COMPARE_FLAG_ENCODING          0x02 /**< The encoding is different */
-#define MMAL_ES_FORMAT_COMPARE_FLAG_BITRATE           0x04 /**< The bitrate is different */
-#define MMAL_ES_FORMAT_COMPARE_FLAG_FLAGS             0x08 /**< The flags are different */
-#define MMAL_ES_FORMAT_COMPARE_FLAG_EXTRADATA         0x10 /**< The extradata is different */
-
-#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_RESOLUTION   0x0100 /**< The video resolution is different */
-#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_CROPPING     0x0200 /**< The video cropping is different */
-#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_FRAME_RATE   0x0400 /**< The video frame rate is different */
-#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_ASPECT_RATIO 0x0800 /**< The video aspect ratio is different */
-#define MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_COLOR_SPACE  0x1000 /**< The video color space is different */
-
-#define MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER  0x10000000 /**< Other ES specific parameters are different */
-/* @} */
-
-/** Compare 2 format structures and returns a set of flags describing the differences.
- * The result will be zero if the structures are the same, or a combination of
- * one or more of the \ref comparisonflags "Comparison flags" if different.
- *
- * @param format_1 first \ref MMAL_ES_FORMAT_T to compare
- * @param format_2 second \ref MMAL_ES_FORMAT_T to compare
- * @return set of flags describing the differences
- */
-uint32_t mmal_format_compare(MMAL_ES_FORMAT_T *format_1, MMAL_ES_FORMAT_T *format_2);
-
-/* @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_FORMAT_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_logging.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_logging.h
deleted file mode 100644
index 2307ab3..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_logging.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_LOGGING_H
-#define MMAL_LOGGING_H
-
-#include "mmal_common.h"
-#include "interface/vcos/vcos_logging.h"
-
-#ifndef VCOS_LOG_CATEGORY
-#define VCOS_LOG_CATEGORY (&mmal_log_category)
-extern VCOS_LOG_CAT_T mmal_log_category;
-#endif
-
-#if defined(__GNUC__) && (( __GNUC__ > 2 ) || (( __GNUC__ == 2 ) && ( __GNUC_MINOR__ >= 3 )))
-#define mmal_log_error(s, ...) vcos_log_error("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
-#define mmal_log_info(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
-#define mmal_log_warn(s, ...) vcos_log_warn("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
-#define mmal_log_debug(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
-#define mmal_log_trace(s, ...) vcos_log_trace("%s: " s, VCOS_FUNCTION, ## __VA_ARGS__)
-#elif defined(_MSC_VER)
-#define mmal_log_error(s, ...) vcos_log_error("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-#define mmal_log_info(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-#define mmal_log_warn(s, ...) vcos_log_warn("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-#define mmal_log_debug(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-#define mmal_log_trace(s, ...) vcos_log_trace("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-#else
-#define mmal_log_error_fun(s, ...) vcos_log_error("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-#define mmal_log_info_fun(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-#define mmal_log_warn_fun(s, ...) vcos_log_warn("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-#define mmal_log_debug_fun(s, ...) vcos_log_info("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-#define mmal_log_trace_fun(s, ...) vcos_log_trace("%s: " s, VCOS_FUNCTION, __VA_ARGS__)
-
-#define mmal_log_error(s...) mmal_log_error_fun(s, 0)
-#define mmal_log_info(s...) mmal_log_info_fun(s, 0)
-#define mmal_log_warn(s...)  mmal_log_warn_fun(s, 0)
-#define mmal_log_debug(s...)  mmal_log_debug_fun(s, 0)
-#define mmal_log_trace(s...) mmal_log_trace_fun(s, 0)
-#endif
-
-#define LOG_ERROR mmal_log_error
-#define LOG_INFO mmal_log_info
-#define LOG_WARN mmal_log_warn
-#define LOG_DEBUG mmal_log_debug
-#define LOG_TRACE mmal_log_trace
-
-#endif /* MMAL_LOGGING_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_metadata.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_metadata.h
deleted file mode 100644
index 5d21dd0..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_metadata.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_METADATA_H
-#define MMAL_METADATA_H
-
-#include "mmal_common.h"
-
-/** \defgroup MmalMetadata List of pre-defined metadata types
- * This defines a list of standard metadata types. Components can still define proprietary
- * metadata types by using their own FourCC and defining their own metadata structures. */
-/* @{ */
-
-/** \name Pre-defined metadata FourCCs */
-/* @{ */
-#define MMAL_METADATA_HELLO_WORLD             MMAL_FOURCC('H','E','L','O')
-/* @} */
-
-/** Generic metadata type. All metadata structures need to begin with these fields. */
-typedef struct MMAL_METATDATA_T
-{
-   uint32_t id;    /**< Metadata id. This is a FourCC */
-   uint32_t size;  /**< Size in bytes of the following metadata (not including id and size) */
-} MMAL_METADATA_T;
-
-/** Hello World metadata. */
-typedef struct MMAL_METATDATA_HELLO_WORLD_T
-{
-   uint32_t id;    /**< Metadata id. This is a FourCC */
-   uint32_t size;  /**< Size in bytes of the following metadata (not including id and size) */
-
-   uint32_t myvalue; /**< Metadata value */
-} MMAL_METADATA_HELLO_WORLD_T;
-
-/** Get metadata item from buffer header.
- * This will search through all the metadata in the buffer header and return a pointer to the
- * first instance of the requested metadata id.
- *
- * @param header buffer header containing the metadata
- * @param id     requested metadata id
- *
- * @return Pointer to metadata requested or NULL if not found.
- */
-MMAL_METADATA_T *mmal_metadata_get(MMAL_BUFFER_HEADER_T *header, uint32_t id);
-
-/** Set metadata item in buffer header.
- * This will store the metadata item into the buffer header. This operation can fail if not
- * enough memory is available in the data section of the buffer header.
- *
- * @param header   buffer header to store the metadata into
- * @param metadata metadata item to store in buffer header
- *
- * @return MMAL_SUCCESS on success or MMAL_ENOMEM if not enough memory is available for storing
- * the metadata
- */
-MMAL_STATUS_T mmal_metadata_set(MMAL_BUFFER_HEADER_T *header, MMAL_METADATA_T *metadata);
-
-/* @} */
-
-#endif /* MMAL_METADATA_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters.h
deleted file mode 100644
index 67ffbda..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters.h
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_PARAMETERS_H
-#define MMAL_PARAMETERS_H
-
-#include "mmal_common.h"
-#include "mmal_parameters_camera.h"
-#include "mmal_parameters_video.h"
-#include "mmal_parameters_audio.h"
-#include "mmal_parameters_clock.h"
-
-/** \defgroup MmalParameters List of pre-defined parameters
- * This defines a list of standard parameters. Components can define proprietary
- * parameters by creating a new group and defining their own structures. */
-/* @{ */
-
-/** Generic unsigned 64-bit integer parameter type. */
-typedef struct MMAL_PARAMETER_UINT64_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint64_t value; /**< Parameter value */
-} MMAL_PARAMETER_UINT64_T;
-
-/** Generic signed 64-bit integer parameter type. */
-typedef struct MMAL_PARAMETER_INT64_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   int64_t value; /**< Parameter value */
-} MMAL_PARAMETER_INT64_T;
-
-/** Generic unsigned 32-bit integer parameter type. */
-typedef struct MMAL_PARAMETER_UINT32_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t value; /**< Parameter value */
-} MMAL_PARAMETER_UINT32_T;
-
-/** Generic signed 32-bit integer parameter type. */
-typedef struct MMAL_PARAMETER_INT32_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   int32_t value; /**< Parameter value */
-} MMAL_PARAMETER_INT32_T;
-
-/** Generic rational parameter type. */
-typedef struct MMAL_PARAMETER_RATIONAL_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_RATIONAL_T value; /**< Parameter value */
-} MMAL_PARAMETER_RATIONAL_T;
-
-/** Generic boolean parameter type. */
-typedef struct MMAL_PARAMETER_BOOLEAN_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_BOOL_T enable; /**< Parameter value */
-} MMAL_PARAMETER_BOOLEAN_T;
-
-/** Generic string parameter type. */
-typedef struct MMAL_PARAMETER_STRING_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   char str[1];        /**< Null-terminated string */
-} MMAL_PARAMETER_STRING_T;
-
-/** Generic array of bytes parameter type. */
-typedef struct MMAL_PARAMETER_BYTES_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint8_t data[1];   /**< Array of bytes */
-} MMAL_PARAMETER_BYTES_T;
-
-/** The value 1 in 16.16 fixed point form */
-#define MMAL_FIXED_16_16_ONE  (1 << 16)
-
-/** Generic two-dimensional scaling factor type. */
-typedef struct MMAL_PARAMETER_SCALEFACTOR_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_FIXED_16_16_T scale_x;  /**< Scaling factor in X-axis */
-   MMAL_FIXED_16_16_T scale_y;  /**< Scaling factor in Y-axis */
-} MMAL_PARAMETER_SCALEFACTOR_T;
-
-/** Valid mirror modes */
-typedef enum MMAL_PARAM_MIRROR_T
-{
-   MMAL_PARAM_MIRROR_NONE,
-   MMAL_PARAM_MIRROR_VERTICAL,
-   MMAL_PARAM_MIRROR_HORIZONTAL,
-   MMAL_PARAM_MIRROR_BOTH,
-} MMAL_PARAM_MIRROR_T;
-
-/** Generic mirror parameter type */
-typedef struct MMAL_PARAMETER_MIRROR_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_MIRROR_T value;   /**< Mirror mode */
-} MMAL_PARAMETER_MIRROR_T;
-
-/** URI parameter type.
- * The parameter may hold an arbitrary length, nul-terminated string as long
- * as the size is set appropriately.
- */
-typedef struct MMAL_PARAMETER_URI_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   char uri[1];    /**< URI string (null-terminated) */
-} MMAL_PARAMETER_URI_T;
-
-/** Generic encoding parameter type.
- * The parameter may hold more than one encoding by overriding the size to
- * include a bigger array.
- */
-typedef struct MMAL_PARAMETER_ENCODING_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t encoding[1];   /**< Array of FourCC encodings, see \ref MmalEncodings */
-} MMAL_PARAMETER_ENCODING_T;
-
-/** Generic frame-rate parameter type.
- * Frame rates are specified as a rational number, using a pair of integers.
- * Since there can be many valid pairs for the same ratio, a frame-rate may
- * not contain exactly the same pairs of values when read back as it was
- * when set.
- */
-typedef struct MMAL_PARAMETER_FRAME_RATE_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_RATIONAL_T frame_rate;   /**< Frame-rate value */
-} MMAL_PARAMETER_FRAME_RATE_T;
-
-/** Generic configuration-file setup type.
- * Configuration files are transferred in small chunks. The component can
- * save all the chunks into a buffer, then process the entire file later.
- * This parameter initialises a config file to have the given size.
- */
-typedef struct MMAL_PARAMETER_CONFIGFILE_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t file_size;           /**< Size of complete file data */
-} MMAL_PARAMETER_CONFIGFILE_T;
-
-/** Generic configuration-file chunk data type.
- * Once a config file has been initialised, this parameter can be used to
- * write an arbitrary chunk of the file data (limited by the maximum MMAL
- * message size).
- */
-typedef struct MMAL_PARAMETER_CONFIGFILE_CHUNK_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t size;                /**< Number of bytes being transferred in this chunk */
-   uint32_t offset;              /**< Offset of this chunk in the file */
-   char data[1];                 /**< Chunk data */
-} MMAL_PARAMETER_CONFIGFILE_CHUNK_T;
-
-/* @} */
-
-#endif /* MMAL_PARAMETERS_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_audio.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_audio.h
deleted file mode 100644
index 2afc5f5..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_audio.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_PARAMETERS_AUDIO_H
-#define MMAL_PARAMETERS_AUDIO_H
-
-#include "mmal_parameters_common.h"
-
-/*************************************************
- * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
- ************************************************/
-
-/** Audio-specific MMAL parameter IDs.
- * @ingroup MMAL_PARAMETER_IDS
- */
-enum
-{
-   MMAL_PARAMETER_AUDIO_DESTINATION      /**< Takes a MMAL_PARAMETER_STRING_T */
-         = MMAL_PARAMETER_GROUP_AUDIO,
-   MMAL_PARAMETER_AUDIO_LATENCY_TARGET,  /**< Takes a MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T */
-};
-
-/** Audio latency target to maintain.
- * These settings are used to adjust the clock speed in order
- * to match the measured audio latency to a specified value. */
-typedef struct MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_BOOL_T enable;   /**< whether this mode is enabled */
-   uint32_t filter;      /**< number of latency samples to filter on, good value: 1 */
-   uint32_t target;      /**< target latency (microseconds) */
-   uint32_t shift;       /**< shift for storing latency values, good value: 7 */
-   int32_t speed_factor; /**< multiplier for speed changes, in 24.8 format, good value: 256-512 */
-   int32_t inter_factor; /**< divider for comparing latency versus gradiant, good value: 300 */
-   int32_t adj_cap;      /**< limit for speed change before nSpeedFactor is applied, good value: 100 */
-} MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T;
-
-#endif /* MMAL_PARAMETERS_AUDIO_H */
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_camera.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_camera.h
deleted file mode 100644
index 4dd080c..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_camera.h
+++ /dev/null
@@ -1,657 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*=============================================================================
-Copyright (c) 2011 Broadcom Europe Limited.
-All rights reserved.
-=============================================================================*/
-/** \file
- * Multi-Media Abstraction Layer - Definition of some standard parameters.
- */
-
-#ifndef MMAL_PARAMETERS_CAMERA_H
-#define MMAL_PARAMETERS_CAMERA_H
-
-#include "mmal_parameters_common.h"
-
-/*************************************************
- * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
- ************************************************/
-
-/** Camera-specific MMAL parameter IDs.
- * @ingroup MMAL_PARAMETER_IDS
- */
-enum {
-   /* 0 */
-   MMAL_PARAMETER_THUMBNAIL_CONFIGURATION    /**< Takes a @ref MMAL_PARAMETER_THUMBNAIL_CONFIG_T */
-         = MMAL_PARAMETER_GROUP_CAMERA,
-   MMAL_PARAMETER_CAPTURE_QUALITY,           /**< Unused? */
-   MMAL_PARAMETER_ROTATION,                  /**< Takes a @ref MMAL_PARAMETER_INT32_T */
-   MMAL_PARAMETER_EXIF_DISABLE,              /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_EXIF,                      /**< Takes a @ref MMAL_PARAMETER_EXIF_T */
-   MMAL_PARAMETER_AWB_MODE,                  /**< Takes a @ref MMAL_PARAM_AWBMODE_T */
-   MMAL_PARAMETER_IMAGE_EFFECT,              /**< Takes a @ref MMAL_PARAMETER_IMAGEFX_T */
-   MMAL_PARAMETER_COLOUR_EFFECT,             /**< Takes a @ref MMAL_PARAMETER_COLOURFX_T */
-   MMAL_PARAMETER_FLICKER_AVOID,             /**< Takes a @ref MMAL_PARAMETER_FLICKERAVOID_T */
-   MMAL_PARAMETER_FLASH,                     /**< Takes a @ref MMAL_PARAMETER_FLASH_T */
-   MMAL_PARAMETER_REDEYE,                    /**< Takes a @ref MMAL_PARAMETER_REDEYE_T */
-   MMAL_PARAMETER_FOCUS,                     /**< Takes a @ref MMAL_PARAMETER_FOCUS_T */
-   MMAL_PARAMETER_FOCAL_LENGTHS,             /**< Unused? */
-   MMAL_PARAMETER_EXPOSURE_COMP,             /**< Takes a @ref MMAL_PARAMETER_INT32_T */
-   MMAL_PARAMETER_ZOOM,                      /**< Takes a @ref MMAL_PARAMETER_SCALEFACTOR_T */
-   MMAL_PARAMETER_MIRROR,                    /**< Takes a @ref MMAL_PARAMETER_MIRROR_T */
-
-   /* 0x10 */
-   MMAL_PARAMETER_CAMERA_NUM,                /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
-   MMAL_PARAMETER_CAPTURE,                   /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_EXPOSURE_MODE,             /**< Takes a @ref MMAL_PARAMETER_EXPOSUREMODE_T */
-   MMAL_PARAMETER_EXP_METERING_MODE,         /**< Takes a @ref MMAL_PARAMETER_EXPOSUREMETERINGMODE_T */
-   MMAL_PARAMETER_FOCUS_STATUS,              /**< Takes a @ref MMAL_PARAMETER_FOCUS_STATUS_T */
-   MMAL_PARAMETER_CAMERA_CONFIG,             /**< Takes a @ref MMAL_PARAMETER_CAMERA_CONFIG_T */
-   MMAL_PARAMETER_CAPTURE_STATUS,            /**< Takes a @ref MMAL_PARAMETER_CAPTURE_STATUS_T */
-   MMAL_PARAMETER_FACE_TRACK,                /**< Takes a @ref MMAL_PARAMETER_FACE_TRACK_T */
-   MMAL_PARAMETER_DRAW_BOX_FACES_AND_FOCUS,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_JPEG_Q_FACTOR,             /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
-   MMAL_PARAMETER_FRAME_RATE,                /**< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T */
-   MMAL_PARAMETER_USE_STC,                   /**< Takes a @ref MMAL_PARAMETER_CAMERA_STC_MODE_T */
-   MMAL_PARAMETER_CAMERA_INFO,               /**< Takes a @ref MMAL_PARAMETER_CAMERA_INFO_T */
-   MMAL_PARAMETER_VIDEO_STABILISATION,       /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_FACE_TRACK_RESULTS,        /**< Takes a @ref MMAL_PARAMETER_FACE_TRACK_RESULTS_T */
-   MMAL_PARAMETER_ENABLE_RAW_CAPTURE,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-
-   /* 0x20 */
-   MMAL_PARAMETER_DPF_FILE,                  /**< Takes a @ref MMAL_PARAMETER_URI_T */
-   MMAL_PARAMETER_ENABLE_DPF_FILE,           /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_DPF_FAIL_IS_FATAL,         /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_CAPTURE_MODE,              /**< Takes a @ref MMAL_PARAMETER_CAPTUREMODE_T */
-   MMAL_PARAMETER_FOCUS_REGIONS,             /**< Takes a @ref MMAL_PARAMETER_FOCUS_REGIONS_T */
-   MMAL_PARAMETER_INPUT_CROP,                /**< Takes a @ref MMAL_PARAMETER_INPUT_CROP_T */
-   MMAL_PARAMETER_SENSOR_INFORMATION,        /**< Takes a @ref MMAL_PARAMETER_SENSOR_INFORMATION_T */
-   MMAL_PARAMETER_FLASH_SELECT,              /**< Takes a @ref MMAL_PARAMETER_FLASH_SELECT_T */
-   MMAL_PARAMETER_FIELD_OF_VIEW,             /**< Takes a @ref MMAL_PARAMETER_FIELD_OF_VIEW_T */
-   MMAL_PARAMETER_HIGH_DYNAMIC_RANGE,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_DYNAMIC_RANGE_COMPRESSION, /**< Takes a @ref MMAL_PARAMETER_DRC_T */
-   MMAL_PARAMETER_ALGORITHM_CONTROL,         /**< Takes a @ref MMAL_PARAMETER_ALGORITHM_CONTROL_T */
-   MMAL_PARAMETER_SHARPNESS,                 /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
-   MMAL_PARAMETER_CONTRAST,                  /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
-   MMAL_PARAMETER_BRIGHTNESS,                /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
-   MMAL_PARAMETER_SATURATION,                /**< Takes a @ref MMAL_PARAMETER_RATIONAL_T */
-
-   /* 0x30 */
-   MMAL_PARAMETER_ISO,                       /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
-   MMAL_PARAMETER_ANTISHAKE,                 /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS,   /**< Takes a @ref MMAL_PARAMETER_IMAGEFX_PARAMETERS_T */
-   MMAL_PARAMETER_CAMERA_BURST_CAPTURE,      /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_CAMERA_MIN_ISO,            /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
-   MMAL_PARAMETER_CAMERA_USE_CASE,           /**< Takes a @ref MMAL_PARAMETER_CAMERA_USE_CASE_T */
-   MMAL_PARAMETER_CAPTURE_STATS_PASS,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_CAMERA_CUSTOM_SENSOR_CONFIG, /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
-   MMAL_PARAMETER_ENABLE_REGISTER_FILE,      /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_REGISTER_FAIL_IS_FATAL,    /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_CONFIGFILE_REGISTERS,      /**< Takes a @ref MMAL_PARAMETER_CONFIGFILE_T */
-   MMAL_PARAMETER_CONFIGFILE_CHUNK_REGISTERS,/**< Takes a @ref MMAL_PARAMETER_CONFIGFILE_CHUNK_T */
-   MMAL_PARAMETER_JPEG_ATTACH_LOG,           /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_ZERO_SHUTTER_LAG,          /**< Takes a @ref MMAL_PARAMETER_ZEROSHUTTERLAG_T */
-   MMAL_PARAMETER_FPS_RANGE,                 /**< Takes a @ref MMAL_PARAMETER_FPS_RANGE_T */
-   MMAL_PARAMETER_CAPTURE_EXPOSURE_COMP,     /**< Takes a @ref MMAL_PARAMETER_INT32_T */
-
-   /* 0x40 */
-   MMAL_PARAMETER_SW_SHARPEN_DISABLE,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_FLASH_REQUIRED,            /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_SW_SATURATION_DISABLE,     /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-};
-
-/** Thumbnail configuration parameter type */
-typedef struct MMAL_PARAMETER_THUMBNAIL_CONFIG_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t enable;                  /**< Enable generation of thumbnails during still capture */
-   uint32_t width;                   /**< Desired width of the thumbnail */
-   uint32_t height;                  /**< Desired height of the thumbnail */
-   uint32_t quality;                 /**< Desired compression quality of the thumbnail */
-} MMAL_PARAMETER_THUMBNAIL_CONFIG_T;
-
-/** EXIF parameter type. */
-typedef struct MMAL_PARAMETER_EXIF_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t keylen;                            /**< If 0, assume key is terminated by '=', otherwise length of key and treat data as binary */
-   uint32_t value_offset;                      /**< Offset within data buffer of the start of the value. If 0, look for a "key=value" string */
-   uint32_t valuelen;                          /**< If 0, assume value is null-terminated, otherwise length of value and treat data as binary */
-   uint8_t data[1];                            /**< EXIF key/value string. Variable length */
-} MMAL_PARAMETER_EXIF_T;
-
-/** Exposure modes. */
-typedef enum
-{
-   MMAL_PARAM_EXPOSUREMODE_OFF,
-   MMAL_PARAM_EXPOSUREMODE_AUTO,
-   MMAL_PARAM_EXPOSUREMODE_NIGHT,
-   MMAL_PARAM_EXPOSUREMODE_NIGHTPREVIEW,
-   MMAL_PARAM_EXPOSUREMODE_BACKLIGHT,
-   MMAL_PARAM_EXPOSUREMODE_SPOTLIGHT,
-   MMAL_PARAM_EXPOSUREMODE_SPORTS,
-   MMAL_PARAM_EXPOSUREMODE_SNOW,
-   MMAL_PARAM_EXPOSUREMODE_BEACH,
-   MMAL_PARAM_EXPOSUREMODE_VERYLONG,
-   MMAL_PARAM_EXPOSUREMODE_FIXEDFPS,
-   MMAL_PARAM_EXPOSUREMODE_ANTISHAKE,
-   MMAL_PARAM_EXPOSUREMODE_FIREWORKS,
-   MMAL_PARAM_EXPOSUREMODE_MAX = 0x7fffffff
-} MMAL_PARAM_EXPOSUREMODE_T;
-
-typedef struct MMAL_PARAMETER_EXPOSUREMODE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_EXPOSUREMODE_T value;   /**< exposure mode */
-} MMAL_PARAMETER_EXPOSUREMODE_T;
-
-typedef enum
-{
-   MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE,
-   MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT,
-   MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT,
-   MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX,
-   MMAL_PARAM_EXPOSUREMETERINGMODE_MAX = 0x7fffffff
-} MMAL_PARAM_EXPOSUREMETERINGMODE_T;
-
-typedef struct MMAL_PARAMETER_EXPOSUREMETERINGMODE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_EXPOSUREMETERINGMODE_T value;   /**< metering mode */
-} MMAL_PARAMETER_EXPOSUREMETERINGMODE_T;
-
-/** AWB parameter modes. */
-typedef enum MMAL_PARAM_AWBMODE_T
-{
-   MMAL_PARAM_AWBMODE_OFF,
-   MMAL_PARAM_AWBMODE_AUTO,
-   MMAL_PARAM_AWBMODE_SUNLIGHT,
-   MMAL_PARAM_AWBMODE_CLOUDY,
-   MMAL_PARAM_AWBMODE_SHADE,
-   MMAL_PARAM_AWBMODE_TUNGSTEN,
-   MMAL_PARAM_AWBMODE_FLUORESCENT,
-   MMAL_PARAM_AWBMODE_INCANDESCENT,
-   MMAL_PARAM_AWBMODE_FLASH,
-   MMAL_PARAM_AWBMODE_HORIZON,
-   MMAL_PARAM_AWBMODE_MAX = 0x7fffffff
-} MMAL_PARAM_AWBMODE_T;
-
-/** AWB parameter type. */
-typedef struct MMAL_PARAMETER_AWBMODE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_AWBMODE_T value;   /**< AWB mode */
-} MMAL_PARAMETER_AWBMODE_T;
-
-/** Image effect */
-typedef enum MMAL_PARAM_IMAGEFX_T
-{
-   MMAL_PARAM_IMAGEFX_NONE,
-   MMAL_PARAM_IMAGEFX_NEGATIVE,
-   MMAL_PARAM_IMAGEFX_SOLARIZE,
-   MMAL_PARAM_IMAGEFX_POSTERIZE,
-   MMAL_PARAM_IMAGEFX_WHITEBOARD,
-   MMAL_PARAM_IMAGEFX_BLACKBOARD,
-   MMAL_PARAM_IMAGEFX_SKETCH,
-   MMAL_PARAM_IMAGEFX_DENOISE,
-   MMAL_PARAM_IMAGEFX_EMBOSS,
-   MMAL_PARAM_IMAGEFX_OILPAINT,
-   MMAL_PARAM_IMAGEFX_HATCH,
-   MMAL_PARAM_IMAGEFX_GPEN,
-   MMAL_PARAM_IMAGEFX_PASTEL,
-   MMAL_PARAM_IMAGEFX_WATERCOLOUR,
-   MMAL_PARAM_IMAGEFX_FILM,
-   MMAL_PARAM_IMAGEFX_BLUR,
-   MMAL_PARAM_IMAGEFX_SATURATION,
-   MMAL_PARAM_IMAGEFX_COLOURSWAP,
-   MMAL_PARAM_IMAGEFX_WASHEDOUT,
-   MMAL_PARAM_IMAGEFX_POSTERISE,
-   MMAL_PARAM_IMAGEFX_COLOURPOINT,
-   MMAL_PARAM_IMAGEFX_COLOURBALANCE,
-   MMAL_PARAM_IMAGEFX_CARTOON,
-   MMAL_PARAM_IMAGEFX_MAX = 0x7fffffff
-} MMAL_PARAM_IMAGEFX_T;
-
-typedef struct MMAL_PARAMETER_IMAGEFX_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_IMAGEFX_T value;   /**< Image effect mode */
-} MMAL_PARAMETER_IMAGEFX_T;
-
-#define MMAL_MAX_IMAGEFX_PARAMETERS 5  /* Image effects library currently uses a maximum of 5 parameters per effect */
-
-typedef struct MMAL_PARAMETER_IMAGEFX_PARAMETERS_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_IMAGEFX_T effect;   /**< Image effect mode */
-   uint32_t num_effect_params;     /**< Number of used elements in */
-   uint32_t effect_parameter[MMAL_MAX_IMAGEFX_PARAMETERS]; /**< Array of parameters */
-} MMAL_PARAMETER_IMAGEFX_PARAMETERS_T;
-
-/** Colour effect parameter type*/
-typedef struct MMAL_PARAMETER_COLOURFX_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   int32_t enable;
-   uint32_t u;
-   uint32_t v;
-} MMAL_PARAMETER_COLOURFX_T;
-
-typedef enum MMAL_CAMERA_STC_MODE_T
-{
-   MMAL_PARAM_STC_MODE_OFF,         /**< Frames do not have STCs, as needed in OpenMAX/IL */
-   MMAL_PARAM_STC_MODE_RAW,         /**< Use raw clock STC, needed for true pause/resume support */
-   MMAL_PARAM_STC_MODE_COOKED,      /**< Start the STC from the start of capture, only for quick demo code */
-   MMAL_PARAM_STC_MODE_MAX = 0x7fffffff
-} MMAL_CAMERA_STC_MODE_T;
-
-typedef struct MMAL_PARAMETER_CAMERA_STC_MODE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-   MMAL_CAMERA_STC_MODE_T value;
-} MMAL_PARAMETER_CAMERA_STC_MODE_T;
-
-typedef enum MMAL_PARAM_FLICKERAVOID_T
-{
-   MMAL_PARAM_FLICKERAVOID_OFF,
-   MMAL_PARAM_FLICKERAVOID_AUTO,
-   MMAL_PARAM_FLICKERAVOID_50HZ,
-   MMAL_PARAM_FLICKERAVOID_60HZ,
-   MMAL_PARAM_FLICKERAVOID_MAX = 0x7FFFFFFF
-} MMAL_PARAM_FLICKERAVOID_T;
-
-typedef struct MMAL_PARAMETER_FLICKERAVOID_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_FLICKERAVOID_T value;   /**< Flicker avoidance mode */
-} MMAL_PARAMETER_FLICKERAVOID_T;
-
-typedef enum MMAL_PARAM_FLASH_T
-{
-   MMAL_PARAM_FLASH_OFF,
-   MMAL_PARAM_FLASH_AUTO,
-   MMAL_PARAM_FLASH_ON,
-   MMAL_PARAM_FLASH_REDEYE,
-   MMAL_PARAM_FLASH_FILLIN,
-   MMAL_PARAM_FLASH_TORCH,
-   MMAL_PARAM_FLASH_MAX = 0x7FFFFFFF
-} MMAL_PARAM_FLASH_T;
-
-typedef struct MMAL_PARAMETER_FLASH_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_FLASH_T value;   /**< Flash mode */
-} MMAL_PARAMETER_FLASH_T;
-
-typedef enum MMAL_PARAM_REDEYE_T
-{
-   MMAL_PARAM_REDEYE_OFF,
-   MMAL_PARAM_REDEYE_ON,
-   MMAL_PARAM_REDEYE_SIMPLE,
-   MMAL_PARAM_REDEYE_MAX = 0x7FFFFFFF
-} MMAL_PARAM_REDEYE_T;
-
-typedef struct MMAL_PARAMETER_REDEYE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_REDEYE_T value;   /**< Red eye reduction mode */
-} MMAL_PARAMETER_REDEYE_T;
-
-typedef enum MMAL_PARAM_FOCUS_T
-{
-   MMAL_PARAM_FOCUS_AUTO,
-   MMAL_PARAM_FOCUS_AUTO_NEAR,
-   MMAL_PARAM_FOCUS_AUTO_MACRO,
-   MMAL_PARAM_FOCUS_CAF,
-   MMAL_PARAM_FOCUS_CAF_NEAR,
-   MMAL_PARAM_FOCUS_FIXED_INFINITY,
-   MMAL_PARAM_FOCUS_FIXED_HYPERFOCAL,
-   MMAL_PARAM_FOCUS_FIXED_NEAR,
-   MMAL_PARAM_FOCUS_FIXED_MACRO,
-   MMAL_PARAM_FOCUS_EDOF,
-   MMAL_PARAM_FOCUS_CAF_MACRO,
-   MMAL_PARAM_FOCUS_CAF_FAST,
-   MMAL_PARAM_FOCUS_CAF_NEAR_FAST,
-   MMAL_PARAM_FOCUS_CAF_MACRO_FAST,
-   MMAL_PARAM_FOCUS_FIXED_CURRENT,
-   MMAL_PARAM_FOCUS_MAX = 0x7FFFFFFF
-} MMAL_PARAM_FOCUS_T;
-
-typedef struct MMAL_PARAMETER_FOCUS_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_FOCUS_T value;   /**< Focus mode */
-} MMAL_PARAMETER_FOCUS_T;
-
-typedef enum MMAL_PARAM_CAPTURE_STATUS_T
-{
-   MMAL_PARAM_CAPTURE_STATUS_NOT_CAPTURING,
-   MMAL_PARAM_CAPTURE_STATUS_CAPTURE_STARTED,
-   MMAL_PARAM_CAPTURE_STATUS_CAPTURE_ENDED,
-
-   MMAL_PARAM_CAPTURE_STATUS_MAX = 0x7FFFFFFF
-} MMAL_PARAM_CAPTURE_STATUS_T;
-
-typedef struct MMAL_PARAMETER_CAPTURE_STATUS_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_CAPTURE_STATUS_T status;   /**< Capture status */
-} MMAL_PARAMETER_CAPTURE_STATUS_T;
-
-typedef enum MMAL_PARAM_FOCUS_STATUS_T
-{
-   MMAL_PARAM_FOCUS_STATUS_OFF,
-   MMAL_PARAM_FOCUS_STATUS_REQUEST,
-   MMAL_PARAM_FOCUS_STATUS_REACHED,
-   MMAL_PARAM_FOCUS_STATUS_UNABLE_TO_REACH,
-   MMAL_PARAM_FOCUS_STATUS_LOST,
-   MMAL_PARAM_FOCUS_STATUS_CAF_MOVING,
-   MMAL_PARAM_FOCUS_STATUS_CAF_SUCCESS,
-   MMAL_PARAM_FOCUS_STATUS_CAF_FAILED,
-   MMAL_PARAM_FOCUS_STATUS_MANUAL_MOVING,
-   MMAL_PARAM_FOCUS_STATUS_MANUAL_REACHED,
-   MMAL_PARAM_FOCUS_STATUS_CAF_WATCHING,
-   MMAL_PARAM_FOCUS_STATUS_CAF_SCENE_CHANGED,
-
-   MMAL_PARAM_FOCUS_STATUS_MAX = 0x7FFFFFFF
-} MMAL_PARAM_FOCUS_STATUS_T;
-
-typedef struct MMAL_PARAMETER_FOCUS_STATUS_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_FOCUS_STATUS_T status;   /**< Focus status */
-} MMAL_PARAMETER_FOCUS_STATUS_T;
-
-typedef enum MMAL_PARAM_FACE_TRACK_MODE_T
-{
-   MMAL_PARAM_FACE_DETECT_NONE,                           /**< Disables face detection */
-   MMAL_PARAM_FACE_DETECT_ON,                             /**< Enables face detection */
-   MMAL_PARAM_FACE_DETECT_MAX = 0x7FFFFFFF
-} MMAL_PARAM_FACE_TRACK_MODE_T;
-
-typedef struct MMAL_PARAMETER_FACE_TRACK_T /* face tracking control */
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-   MMAL_PARAM_FACE_TRACK_MODE_T mode;
-   uint32_t maxRegions;
-   uint32_t frames;
-   uint32_t quality;
-} MMAL_PARAMETER_FACE_TRACK_T;
-
-typedef struct MMAL_PARAMETER_FACE_TRACK_FACE_T /* face tracking face information */
-{
-   int32_t     face_id;             /**< Face ID. Should remain the same whilst the face is detected to remain in the scene */
-   int32_t     score;               /**< Confidence of the face detection. Range 1-100 (1=unsure, 100=positive). */
-   MMAL_RECT_T face_rect;           /**< Rectangle around the whole face */
-
-   MMAL_RECT_T eye_rect[2];         /**< Rectangle around the eyes ([0] = left eye, [1] = right eye) */
-   MMAL_RECT_T mouth_rect;          /**< Rectangle around the mouth */
-} MMAL_PARAMETER_FACE_TRACK_FACE_T;
-
-typedef struct MMAL_PARAMETER_FACE_TRACK_RESULTS_T /* face tracking results */
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t num_faces;        /**< Number of faces detected */
-   uint32_t frame_width;      /**< Width of the frame on which the faces were detected (allows scaling) */
-   uint32_t frame_height;     /**< Height of the frame on which the faces were detected (allows scaling) */
-
-   MMAL_PARAMETER_FACE_TRACK_FACE_T faces[1];   /**< Face information (variable length array */
-} MMAL_PARAMETER_FACE_TRACK_RESULTS_T;
-
-typedef enum MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T
-{
-   MMAL_PARAM_TIMESTAMP_MODE_ZERO,           /**< Always timestamp frames as 0 */
-   MMAL_PARAM_TIMESTAMP_MODE_RAW_STC,        /**< Use the raw STC value for the frame timestamp */
-   MMAL_PARAM_TIMESTAMP_MODE_RESET_STC,      /**< Use the STC timestamp but subtract the timestamp
-                                              * of the first frame sent to give a zero based timestamp.
-                                              */
-   MMAL_PARAM_TIMESTAMP_MODE_MAX = 0x7FFFFFFF
-} MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T;
-
-typedef struct MMAL_PARAMETER_CAMERA_CONFIG_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   /* Parameters for setting up the image pools */
-   uint32_t max_stills_w;        /**< Max size of stills capture */
-   uint32_t max_stills_h;
-   uint32_t stills_yuv422;       /**< Allow YUV422 stills capture */
-   uint32_t one_shot_stills;     /**< Continuous or one shot stills captures. */
-
-   uint32_t max_preview_video_w; /**< Max size of the preview or video capture frames */
-   uint32_t max_preview_video_h;
-   uint32_t num_preview_video_frames;
-
-   uint32_t stills_capture_circular_buffer_height; /**< Sets the height of the circular buffer for stills capture. */
-
-   uint32_t fast_preview_resume;    /**< Allows preview/encode to resume as fast as possible after the stills input frame
-                                     * has been received, and then processes the still frame in the background
-                                     * whilst preview/encode has resumed.
-                                     * Actual mode is controlled by MMAL_PARAMETER_CAPTURE_MODE.
-                                     */
-
-   MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T use_stc_timestamp;
-                                    /**< Selects algorithm for timestamping frames if there is no clock component connected.
-                                      */
-
-
-} MMAL_PARAMETER_CAMERA_CONFIG_T;
-
-#define MMAL_PARAMETER_CAMERA_INFO_MAX_CAMERAS 4
-#define MMAL_PARAMETER_CAMERA_INFO_MAX_FLASHES 2
-
-typedef struct MMAL_PARAMETER_CAMERA_INFO_CAMERA_T
-{
-   uint32_t    port_id;
-   uint32_t    max_width;
-   uint32_t    max_height;
-   MMAL_BOOL_T lens_present;
-} MMAL_PARAMETER_CAMERA_INFO_CAMERA_T;
-
-typedef enum MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T
-{
-   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_XENON = 0, /* Make values explicit */
-   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_LED   = 1, /* to ensure they match */
-   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_OTHER = 2, /* values in config ini */
-   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_MAX = 0x7FFFFFFF
-} MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T;
-
-typedef struct MMAL_PARAMETER_CAMERA_INFO_FLASH_T
-{
-   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T flash_type;
-} MMAL_PARAMETER_CAMERA_INFO_FLASH_T;
-
-typedef struct MMAL_PARAMETER_CAMERA_INFO_T
-{
-   MMAL_PARAMETER_HEADER_T             hdr;
-   uint32_t                            num_cameras;
-   uint32_t                            num_flashes;
-   MMAL_PARAMETER_CAMERA_INFO_CAMERA_T cameras[MMAL_PARAMETER_CAMERA_INFO_MAX_CAMERAS];
-   MMAL_PARAMETER_CAMERA_INFO_FLASH_T  flashes[MMAL_PARAMETER_CAMERA_INFO_MAX_FLASHES];
-} MMAL_PARAMETER_CAMERA_INFO_T;
-
-typedef enum MMAL_PARAMETER_CAPTUREMODE_MODE_T
-{
-   MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END,            /**< Resumes preview once capture is completed. */
-   MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END_AND_HOLD,   /**< Resumes preview once capture is completed, and hold the image for subsequent reprocessing. */
-   MMAL_PARAM_CAPTUREMODE_RESUME_VF_IMMEDIATELY,   /**< Resumes preview as soon as possible once capture frame is received from the sensor.
-                                                    *   Requires fast_preview_resume to be set via MMAL_PARAMETER_CAMERA_CONFIG.
-                                                    */
-} MMAL_PARAMETER_CAPTUREMODE_MODE_T;
-
-/** Stills capture mode control. */
-typedef struct MMAL_PARAMETER_CAPTUREMODE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-   MMAL_PARAMETER_CAPTUREMODE_MODE_T mode;
-} MMAL_PARAMETER_CAPTUREMODE_T;
-
-typedef enum MMAL_PARAMETER_FOCUS_REGION_TYPE_T
-{
-   MMAL_PARAMETER_FOCUS_REGION_TYPE_NORMAL,     /**< Region defines a generic region */
-   MMAL_PARAMETER_FOCUS_REGION_TYPE_FACE,       /**< Region defines a face */
-   MMAL_PARAMETER_FOCUS_REGION_TYPE_MAX
-} MMAL_PARAMETER_FOCUS_REGION_TYPE_T;
-
-typedef struct MMAL_PARAMETER_FOCUS_REGION_T
-{
-   MMAL_RECT_T rect;    /**< Focus rectangle as 0P16 fixed point values. */
-   uint32_t weight;     /**< Region weighting. */
-   uint32_t mask;       /**< Mask for multi-stage regions */
-   MMAL_PARAMETER_FOCUS_REGION_TYPE_T type;  /**< Region type */
-} MMAL_PARAMETER_FOCUS_REGION_T;
-
-typedef struct MMAL_PARAMETER_FOCUS_REGIONS_T
-{
-   MMAL_PARAMETER_HEADER_T          hdr;
-   uint32_t                         num_regions;      /**< Number of regions defined */
-   MMAL_BOOL_T                      lock_to_faces;    /**< If region is within tolerance of a face, adopt face rect instead of defined region */
-   MMAL_PARAMETER_FOCUS_REGION_T    regions[1];       /**< Variable number of regions */
-} MMAL_PARAMETER_FOCUS_REGIONS_T;
-
-typedef struct MMAL_PARAMETER_INPUT_CROP_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-   MMAL_RECT_T             rect;    /**< Crop rectangle as 16P16 fixed point values */
-} MMAL_PARAMETER_INPUT_CROP_T;
-
-typedef struct MMAL_PARAMETER_SENSOR_INFORMATION_T
-{
-   MMAL_PARAMETER_HEADER_T          hdr;
-   MMAL_RATIONAL_T                  f_number;         /**< Lens f-number */
-   MMAL_RATIONAL_T                  focal_length;     /**< Lens focal length */
-   uint32_t                         model_id;         /**< Sensor reported model id */
-   uint32_t                         manufacturer_id;  /**< Sensor reported manufacturer id */
-   uint32_t                         revision;         /**< Sensor reported revision */
-} MMAL_PARAMETER_SENSOR_INFORMATION_T;
-
-typedef struct MMAL_PARAMETER_FLASH_SELECT_T
-{
-   MMAL_PARAMETER_HEADER_T          hdr;
-   MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T flash_type;   /**< Flash type to use */
-} MMAL_PARAMETER_FLASH_SELECT_T;
-
-typedef struct MMAL_PARAMETER_FIELD_OF_VIEW_T
-{
-   MMAL_PARAMETER_HEADER_T          hdr;
-   MMAL_RATIONAL_T                  fov_h;         /**< Horizontal field of view */
-   MMAL_RATIONAL_T                  fov_v;         /**< Vertical field of view */
-} MMAL_PARAMETER_FIELD_OF_VIEW_T;
-
-typedef enum MMAL_PARAMETER_DRC_STRENGTH_T
-{
-   MMAL_PARAMETER_DRC_STRENGTH_OFF,
-   MMAL_PARAMETER_DRC_STRENGTH_LOW,
-   MMAL_PARAMETER_DRC_STRENGTH_MEDIUM,
-   MMAL_PARAMETER_DRC_STRENGTH_HIGH,
-   MMAL_PARAMETER_DRC_STRENGTH_MAX = 0x7fffffff
-} MMAL_PARAMETER_DRC_STRENGTH_T;
-
-typedef struct MMAL_PARAMETER_DRC_T
-{
-   MMAL_PARAMETER_HEADER_T          hdr;
-   MMAL_PARAMETER_DRC_STRENGTH_T    strength;      /**< DRC strength */
-} MMAL_PARAMETER_DRC_T;
-
-typedef enum MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T
-{
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACETRACKING,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_REDEYE_REDUCTION,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_STABILISATION,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_WRITE_RAW,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_DENOISE,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_STILLS_DENOISE,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_TEMPORAL_DENOISE,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_ANTISHAKE,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_IMAGE_EFFECTS,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_DYNAMIC_RANGE_COMPRESSION,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_RECOGNITION,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_BEAUTIFICATION,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_SCENE_DETECTION,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_HIGH_DYNAMIC_RANGE,
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_MAX = 0x7fffffff
-} MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T;
-
-typedef struct MMAL_PARAMETER_ALGORITHM_CONTROL_T
-{
-   MMAL_PARAMETER_HEADER_T          hdr;
-   MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T algorithm;
-   MMAL_BOOL_T                      enabled;
-} MMAL_PARAMETER_ALGORITHM_CONTROL_T;
-
-
-typedef enum MMAL_PARAM_CAMERA_USE_CASE_T
-{
-   MMAL_PARAM_CAMERA_USE_CASE_UNKNOWN,             /**< Compromise on behaviour as use case totally unknown */
-   MMAL_PARAM_CAMERA_USE_CASE_STILLS_CAPTURE,      /**< Stills capture use case */
-   MMAL_PARAM_CAMERA_USE_CASE_VIDEO_CAPTURE,       /**< Video encode (camcorder) use case */
-
-   MMAL_PARAM_CAMERA_USE_CASE_MAX = 0x7fffffff
-} MMAL_PARAM_CAMERA_USE_CASE_T;
-
-typedef struct MMAL_PARAMETER_CAMERA_USE_CASE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_PARAM_CAMERA_USE_CASE_T use_case;   /**< Use case */
-} MMAL_PARAMETER_CAMERA_USE_CASE_T;
-
-typedef struct MMAL_PARAMETER_FPS_RANGE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_RATIONAL_T   fps_low;                /**< Low end of the permitted framerate range */
-   MMAL_RATIONAL_T   fps_high;               /**< High end of the permitted framerate range */
-} MMAL_PARAMETER_FPS_RANGE_T;
-
-typedef struct MMAL_PARAMETER_ZEROSHUTTERLAG_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_BOOL_T zero_shutter_lag_mode;        /**< Select zero shutter lag mode from sensor */
-   MMAL_BOOL_T concurrent_capture;           /**< Activate full zero shutter lag mode and
-                                              *  use the last preview raw image for the stills capture
-                                              */
-} MMAL_PARAMETER_ZEROSHUTTERLAG_T;
-
-#endif  /* MMAL_PARAMETERS_CAMERA_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_clock.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_clock.h
deleted file mode 100644
index 1f0b64f..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_clock.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_PARAMETERS_CLOCK_H
-#define MMAL_PARAMETERS_CLOCK_H
-
-#include "mmal_parameters_common.h"
-
-/*************************************************
- * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
- ************************************************/
-
-/** Clock-specific MMAL parameter IDs.
- * @ingroup MMAL_PARAMETER_IDS
- */
-enum
-{
-   MMAL_PARAMETER_CLOCK_REFERENCE           /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
-      = MMAL_PARAMETER_GROUP_CLOCK,
-   MMAL_PARAMETER_CLOCK_ACTIVE,             /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_CLOCK_SCALE,              /**< Takes a MMAL_PARAMETER_RATIONAL_T */
-   MMAL_PARAMETER_CLOCK_TIME,               /**< Takes a MMAL_PARAMETER_INT64_T */
-   MMAL_PARAMETER_CLOCK_TIME_OFFSET,        /**< Takes a MMAL_PARAMETER_INT64_T */
-   MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD,   /**< Takes a MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T */
-   MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD,  /**< Takes a MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T */
-   MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD,   /**< Takes a MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T */
-};
-
-/** Media-time update thresholds */
-typedef struct MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   /** Time differences below this threshold are ignored (microseconds) */
-   int64_t threshold_lower;
-
-   /** Time differences above this threshold reset media time (microseconds) */
-   int64_t threshold_upper;
-} MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T;
-
-/** Media-time discontinuity settings */
-typedef struct MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   /** Threshold after which backward jumps in media-time are treated as a
-    * discontinuity (microseconds) */
-   int64_t threshold;
-
-   /** Duration in microseconds for which a discontinuity applies (wall-time) */
-   int64_t duration;
-} MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T;
-
-/** Media-time future frame drop settings */
-typedef struct MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   /** Threshold after which frames exceeding the media-time are dropped (microseconds) */
-   int64_t threshold;
-
-   /** Request threshold enable */
-   MMAL_BOOL_T threshold_enable;
-} MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T;
-
-#endif /* MMAL_PARAMETERS_CLOCK_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_common.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_common.h
deleted file mode 100644
index 60af5eb..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_common.h
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_PARAMETERS_COMMON_H
-#define MMAL_PARAMETERS_COMMON_H
-
-/** @defgroup MMAL_PARAMETER_IDS Pre-defined MMAL parameter IDs
- * @ingroup MmalParameters
- * @{
- */
-
-/** @name Parameter groups
- * Parameters are divided into groups, and then allocated sequentially within
- * a group using an enum.
- * @{
- */
-
-/** Common parameter ID group, used with many types of component. */
-#define MMAL_PARAMETER_GROUP_COMMON            (0<<16)
-/** Camera-specific parameter ID group. */
-#define MMAL_PARAMETER_GROUP_CAMERA            (1<<16)
-/** Video-specific parameter ID group. */
-#define MMAL_PARAMETER_GROUP_VIDEO             (2<<16)
-/** Audio-specific parameter ID group. */
-#define MMAL_PARAMETER_GROUP_AUDIO             (3<<16)
-/** Clock-specific parameter ID group. */
-#define MMAL_PARAMETER_GROUP_CLOCK             (4<<16)
-/** Miracast-specific parameter ID group. */
-#define MMAL_PARAMETER_GROUP_MIRACAST       (5<<16)
-
-
-/**@}*/
-
-/** Common MMAL parameter IDs.
- */
-enum {
-   MMAL_PARAMETER_UNUSED                  /**< Never a valid parameter ID */
-         = MMAL_PARAMETER_GROUP_COMMON,
-   MMAL_PARAMETER_SUPPORTED_ENCODINGS,    /**< Takes a MMAL_PARAMETER_ENCODING_T */
-   MMAL_PARAMETER_URI,                    /**< Takes a MMAL_PARAMETER_URI_T */
-   MMAL_PARAMETER_CHANGE_EVENT_REQUEST,   /**< Takes a MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T */
-   MMAL_PARAMETER_ZERO_COPY,              /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_BUFFER_REQUIREMENTS,    /**< Takes a MMAL_PARAMETER_BUFFER_REQUIREMENTS_T */
-   MMAL_PARAMETER_STATISTICS,             /**< Takes a MMAL_PARAMETER_STATISTICS_T */
-   MMAL_PARAMETER_CORE_STATISTICS,        /**< Takes a MMAL_PARAMETER_CORE_STATISTICS_T */
-   MMAL_PARAMETER_MEM_USAGE,              /**< Takes a MMAL_PARAMETER_MEM_USAGE_T */
-   MMAL_PARAMETER_BUFFER_FLAG_FILTER,     /**< Takes a MMAL_PARAMETER_UINT32_T */
-   MMAL_PARAMETER_SEEK,                   /**< Takes a MMAL_PARAMETER_SEEK_T */
-   MMAL_PARAMETER_POWERMON_ENABLE,        /**< Takes a MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_LOGGING,                /**< Takes a MMAL_PARAMETER_LOGGING_T */
-};
-
-/**@}*/
-
-/** Parameter header type. All parameter structures need to begin with this type.
- * The \ref id field must be set to a parameter ID, such as one of those listed on
- * the \ref MMAL_PARAMETER_IDS "Pre-defined MMAL parameter IDs" page.
- */
-typedef struct MMAL_PARAMETER_HEADER_T
-{
-   uint32_t id;      /**< Parameter ID. */
-   uint32_t size;    /**< Size in bytes of the parameter (including the header) */
-} MMAL_PARAMETER_HEADER_T;
-
-/** Change event request parameter type.
- * This is used to control whether a \ref MMAL_EVENT_PARAMETER_CHANGED_T event
- * is issued should a given parameter change.
- */
-typedef struct MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t change_id;  /**< ID of parameter that may change, see \ref MMAL_PARAMETER_IDS */
-   MMAL_BOOL_T enable;  /**< True if the event is enabled, false if disabled */
-} MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T;
-
-/** Buffer requirements parameter.
- * This is mainly used to increase the requirements of a component. */
-typedef struct MMAL_PARAMETER_BUFFER_REQUIREMENTS_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t buffer_num_min;          /**< Minimum number of buffers the port requires */
-   uint32_t buffer_size_min;         /**< Minimum size of buffers the port requires */
-   uint32_t buffer_alignment_min;    /**< Minimum alignment requirement for the buffers.
-                                          A value of zero means no special alignment requirements. */
-   uint32_t buffer_num_recommended;  /**< Number of buffers the port recommends for optimal performance.
-                                          A value of zero means no special recommendation. */
-   uint32_t buffer_size_recommended; /**< Size of buffers the port recommends for optimal performance.
-                                          A value of zero means no special recommendation. */
-} MMAL_PARAMETER_BUFFER_REQUIREMENTS_T;
-
-/** Seek request parameter type.
- * This is used to issue a seek request to a source component.
- */
-typedef struct MMAL_PARAMETER_SEEK_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   int64_t offset;  /**< Offset (in microseconds) to seek to */
-   uint32_t flags;  /**< Seeking flags */
-
-#define MMAL_PARAM_SEEK_FLAG_PRECISE 0x1 /**< Choose precise seeking even if slower */
-#define MMAL_PARAM_SEEK_FLAG_FORWARD 0x2 /**< Seek to the next keyframe following the specified offset */
-
-} MMAL_PARAMETER_SEEK_T;
-
-/** Port statistics for debugging/test purposes.
- * Ports may support query of this parameter to return statistics for debugging or
- * test purposes. Not all values may be relevant for a given port.
- */
-typedef struct MMAL_PARAMETER_STATISTICS_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t buffer_count;           /**< Total number of buffers processed */
-   uint32_t frame_count;            /**< Total number of frames processed */
-   uint32_t frames_skipped;         /**< Number of frames without expected PTS based on frame rate */
-   uint32_t frames_discarded;       /**< Number of frames discarded */
-   uint32_t eos_seen;               /**< Set if the end of stream has been reached */
-   uint32_t maximum_frame_bytes;    /**< Maximum frame size in bytes */
-   int64_t  total_bytes;            /**< Total number of bytes processed */
-   uint32_t corrupt_macroblocks;    /**< Number of corrupt macroblocks in the stream */
-} MMAL_PARAMETER_STATISTICS_T;
-
-typedef enum
-{
-   MMAL_CORE_STATS_RX,
-   MMAL_CORE_STATS_TX,
-   MMAL_CORE_STATS_MAX = 0x7fffffff /* Force 32 bit size for this enum */
-} MMAL_CORE_STATS_DIR;
-
-/** MMAL core statistics. These are collected by the core itself.
- */
-typedef struct MMAL_PARAMETER_CORE_STATISTICS_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-   MMAL_CORE_STATS_DIR dir;
-   MMAL_BOOL_T reset;               /**< Reset to zero after reading */
-   MMAL_CORE_STATISTICS_T stats;    /**< The statistics */
-} MMAL_PARAMETER_CORE_STATISTICS_T;
-
-/**
- * Component memory usage statistics.
- */
-typedef struct MMAL_PARAMETER_MEM_USAGE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-   /**< The amount of memory allocated in image pools by the component */
-   uint32_t pool_mem_alloc_size;
-} MMAL_PARAMETER_MEM_USAGE_T;
-
-/**
- * Logging control.
- */
-typedef struct MMAL_PARAMETER_LOGGING_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-   uint32_t set;     /**< Logging bits to set */
-   uint32_t clear;   /**< Logging bits to clear */
-} MMAL_PARAMETER_LOGGING_T;
-
-#endif /* MMAL_PARAMETERS_COMMON_H */
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_video.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_video.h
deleted file mode 100644
index b6cc4ec..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_parameters_video.h
+++ /dev/null
@@ -1,437 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_PARAMETERS_VIDEO_H
-#define MMAL_PARAMETERS_VIDEO_H
-
-#include "mmal_parameters_common.h"
-
-/*************************************************
- * ALWAYS ADD NEW ENUMS AT THE END OF THIS LIST! *
- ************************************************/
-
-/** Video-specific MMAL parameter IDs.
- * @ingroup MMAL_PARAMETER_IDS
- */
-enum {
-   MMAL_PARAMETER_DISPLAYREGION           /**< Takes a @ref MMAL_DISPLAYREGION_T */
-         = MMAL_PARAMETER_GROUP_VIDEO,
-   MMAL_PARAMETER_SUPPORTED_PROFILES,     /**< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T */
-   MMAL_PARAMETER_PROFILE,                /**< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T */
-   MMAL_PARAMETER_INTRAPERIOD,            /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
-   MMAL_PARAMETER_RATECONTROL,            /**< Takes a @ref MMAL_PARAMETER_VIDEO_RATECONTROL_T */
-   MMAL_PARAMETER_NALUNITFORMAT,          /**< Takes a @ref MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T */
-   MMAL_PARAMETER_MINIMISE_FRAGMENTATION, /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_MB_ROWS_PER_SLICE,      /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
-                                           * Setting the value to zero resets to the default (one slice per frame). */
-   MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION,  /**< Takes a @ref MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T */
-   MMAL_PARAMETER_VIDEO_EEDE_ENABLE,      /**< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T */
-   MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE,    /**< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T */
-   MMAL_PARAMETER_VIDEO_REQUEST_I_FRAME,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T.
-                                           * Request an I-frame. */
-   MMAL_PARAMETER_VIDEO_INTRA_REFRESH,    /**< Takes a @ref MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T */
-   MMAL_PARAMETER_VIDEO_IMMUTABLE_INPUT,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T. */
-   MMAL_PARAMETER_VIDEO_BIT_RATE,         /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
-                                           * Run-time bit rate control */
-   MMAL_PARAMETER_VIDEO_FRAME_RATE,       /**< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T */
-   MMAL_PARAMETER_VIDEO_ENCODE_MIN_QUANT, /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_MAX_QUANT, /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL,  /**< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T. */
-   MMAL_PARAMETER_EXTRA_BUFFERS,          /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
-   MMAL_PARAMETER_VIDEO_ALIGN_HORIZ,      /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
-                                               Changing this paramater from the default can reduce frame rate
-                                               because image buffers need to be re-pitched.*/
-   MMAL_PARAMETER_VIDEO_ALIGN_VERT,        /**< Takes a @ref MMAL_PARAMETER_UINT32_T.
-                                               Changing this paramater from the default can reduce frame rate
-                                               because image buffers need to be re-pitched.*/
-   MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAMES,      /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_INITIAL_QUANT,   /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_QP_P,            /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_RC_SLICE_DQUANT, /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_FRAME_LIMIT_BITS,    /**< Takes a @ref MMAL_PARAMETER_UINT32_T */
-   MMAL_PARAMETER_VIDEO_ENCODE_PEAK_RATE,       /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */       
-
-   /*H264 specific parameters*/
-   MMAL_PARAMETER_VIDEO_ENCODE_H264_DISABLE_CABAC,      /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_LATENCY,        /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_H264_AU_DELIMITERS,      /**< Take a @ref MMAL_PARAMETER_BOOLEAN_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_H264_DEBLOCK_IDC,        /**< Takes a @ref MMAL_PARAMETER_UINT32_T. */
-   MMAL_PARAMETER_VIDEO_ENCODE_H264_MB_INTRA_MODE,      /**< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T. */
-
-   MMAL_PARAMETER_VIDEO_ENCODE_HEADER_ON_OPEN,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_VIDEO_ENCODE_PRECODE_FOR_QP,  /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-
-   MMAL_PARAMETER_VIDEO_DRM_INIT_INFO,          /**< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T. */
-   MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO,         /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_VIDEO_DECODE_ERROR_CONCEALMENT,        /**< Takes a @ref MMAL_PARAMETER_BOOLEAN_T */
-   MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER,              /**< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T. */
-
-   MMAL_PARAMETER_VIDEO_DECODE_CONFIG_VD3       /**< Takes a @ref MMAL_PARAMETER_BYTES_T */
-};
-
-/** Display transformations.
- * Although an enumeration, the values correspond to combinations of:
- * \li 1 Reflect in a vertical axis
- * \li 2 180 degree rotation
- * \li 4 Reflect in the leading diagonal
- */
-typedef enum MMAL_DISPLAYTRANSFORM_T {
-   MMAL_DISPLAY_ROT0 = 0,
-   MMAL_DISPLAY_MIRROR_ROT0 = 1,
-   MMAL_DISPLAY_MIRROR_ROT180 = 2,
-   MMAL_DISPLAY_ROT180 = 3,
-   MMAL_DISPLAY_MIRROR_ROT90 = 4,
-   MMAL_DISPLAY_ROT270 = 5,
-   MMAL_DISPLAY_ROT90 = 6,
-   MMAL_DISPLAY_MIRROR_ROT270 = 7,
-   MMAL_DISPLAY_DUMMY = 0x7FFFFFFF
-} MMAL_DISPLAYTRANSFORM_T;
-
-/** Display modes. */
-typedef enum MMAL_DISPLAYMODE_T {
-   MMAL_DISPLAY_MODE_FILL = 0,
-   MMAL_DISPLAY_MODE_LETTERBOX = 1,
-   MMAL_DISPLAY_MODE_DUMMY = 0x7FFFFFFF
-} MMAL_DISPLAYMODE_T;
-
-/** Values used to indicate which fields are used when setting the
- * display configuration */
-typedef enum MMAL_DISPLAYSET_T {
-   MMAL_DISPLAY_SET_NONE = 0,
-   MMAL_DISPLAY_SET_NUM = 1,
-   MMAL_DISPLAY_SET_FULLSCREEN = 2,
-   MMAL_DISPLAY_SET_TRANSFORM = 4,
-   MMAL_DISPLAY_SET_DEST_RECT = 8,
-   MMAL_DISPLAY_SET_SRC_RECT = 0x10,
-   MMAL_DISPLAY_SET_MODE = 0x20,
-   MMAL_DISPLAY_SET_PIXEL = 0x40,
-   MMAL_DISPLAY_SET_NOASPECT = 0x80,
-   MMAL_DISPLAY_SET_LAYER = 0x100,
-   MMAL_DISPLAY_SET_COPYPROTECT = 0x200,
-   MMAL_DISPLAY_SET_ALPHA = 0x400,
-   MMAL_DISPLAY_SET_DUMMY = 0x7FFFFFFF
-} MMAL_DISPLAYSET_T;
-
-/**
-This config sets the output display device, as well as the region used
-on the output display, any display transformation, and some flags to
-indicate how to scale the image.
-*/
-
-typedef struct MMAL_DISPLAYREGION_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-   /** Bitfield that indicates which fields are set and should be used. All
-    * other fields will maintain their current value.
-    * \ref MMAL_DISPLAYSET_T defines the bits that can be combined.
-    */
-   uint32_t set;
-   /** Describes the display output device, with 0 typically being a directly
-    * connected LCD display.  The actual values will depend on the hardware.
-    * Code using hard-wired numbers (e.g. 2) is certain to fail.
-    */
-   uint32_t display_num;
-   /** Indicates that we are using the full device screen area, rather than
-    * a window of the display.  If zero, then dest_rect is used to specify a
-    * region of the display to use.
-    */
-   MMAL_BOOL_T fullscreen;
-   /** Indicates any rotation or flipping used to map frames onto the natural
-    * display orientation.
-    */
-   MMAL_DISPLAYTRANSFORM_T transform;
-   /** Where to display the frame within the screen, if fullscreen is zero.
-    */
-   MMAL_RECT_T dest_rect;
-   /** Indicates which area of the frame to display. If all values are zero,
-    * the whole frame will be used.
-    */
-   MMAL_RECT_T src_rect;
-   /** If set to non-zero, indicates that any display scaling should disregard
-    * the aspect ratio of the frame region being displayed.
-    */
-   MMAL_BOOL_T noaspect;
-   /** Indicates how the image should be scaled to fit the display. \code
-    * MMAL_DISPLAY_MODE_FILL \endcode indicates that the image should fill the
-    * screen by potentially cropping the frames.  Setting \code mode \endcode
-    * to \code MMAL_DISPLAY_MODE_LETTERBOX \endcode indicates that all the source
-    * region should be displayed and black bars added if necessary.
-    */
-   MMAL_DISPLAYMODE_T mode;
-   /** If non-zero, defines the width of a source pixel relative to \code pixel_y
-    * \endcode.  If zero, then pixels default to being square.
-    */
-   uint32_t pixel_x;
-   /** If non-zero, defines the height of a source pixel relative to \code pixel_x
-    * \endcode.  If zero, then pixels default to being square.
-    */
-   uint32_t pixel_y;
-   /** Sets the relative depth of the images, with greater values being in front
-    * of smaller values.
-    */
-   int32_t layer;
-   /** Set to non-zero to ensure copy protection is used on output.
-    */
-   MMAL_BOOL_T copyprotect_required;
-   /** Level of opacity of the layer, where zero is fully transparent and
-    * 255 is fully opaque.
-    */
-   uint32_t alpha;
-} MMAL_DISPLAYREGION_T;
-
-/** Video profiles.
- * Only certain combinations of profile and level will be valid.
- * @ref MMAL_VIDEO_LEVEL_T
- */
-typedef enum MMAL_VIDEO_PROFILE_T {
-    MMAL_VIDEO_PROFILE_H263_BASELINE,
-    MMAL_VIDEO_PROFILE_H263_H320CODING,
-    MMAL_VIDEO_PROFILE_H263_BACKWARDCOMPATIBLE,
-    MMAL_VIDEO_PROFILE_H263_ISWV2,
-    MMAL_VIDEO_PROFILE_H263_ISWV3,
-    MMAL_VIDEO_PROFILE_H263_HIGHCOMPRESSION,
-    MMAL_VIDEO_PROFILE_H263_INTERNET,
-    MMAL_VIDEO_PROFILE_H263_INTERLACE,
-    MMAL_VIDEO_PROFILE_H263_HIGHLATENCY,
-    MMAL_VIDEO_PROFILE_MP4V_SIMPLE,
-    MMAL_VIDEO_PROFILE_MP4V_SIMPLESCALABLE,
-    MMAL_VIDEO_PROFILE_MP4V_CORE,
-    MMAL_VIDEO_PROFILE_MP4V_MAIN,
-    MMAL_VIDEO_PROFILE_MP4V_NBIT,
-    MMAL_VIDEO_PROFILE_MP4V_SCALABLETEXTURE,
-    MMAL_VIDEO_PROFILE_MP4V_SIMPLEFACE,
-    MMAL_VIDEO_PROFILE_MP4V_SIMPLEFBA,
-    MMAL_VIDEO_PROFILE_MP4V_BASICANIMATED,
-    MMAL_VIDEO_PROFILE_MP4V_HYBRID,
-    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDREALTIME,
-    MMAL_VIDEO_PROFILE_MP4V_CORESCALABLE,
-    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCODING,
-    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCORE,
-    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSCALABLE,
-    MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSIMPLE,
-    MMAL_VIDEO_PROFILE_H264_BASELINE,
-    MMAL_VIDEO_PROFILE_H264_MAIN,
-    MMAL_VIDEO_PROFILE_H264_EXTENDED,
-    MMAL_VIDEO_PROFILE_H264_HIGH,
-    MMAL_VIDEO_PROFILE_H264_HIGH10,
-    MMAL_VIDEO_PROFILE_H264_HIGH422,
-    MMAL_VIDEO_PROFILE_H264_HIGH444,
-    MMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE,
-    MMAL_VIDEO_PROFILE_DUMMY = 0x7FFFFFFF
-} MMAL_VIDEO_PROFILE_T;
-
-/** Video levels.
- * Only certain combinations of profile and level will be valid.
- * @ref MMAL_VIDEO_PROFILE_T
- */
-typedef enum MMAL_VIDEO_LEVEL_T {
-    MMAL_VIDEO_LEVEL_H263_10,
-    MMAL_VIDEO_LEVEL_H263_20,
-    MMAL_VIDEO_LEVEL_H263_30,
-    MMAL_VIDEO_LEVEL_H263_40,
-    MMAL_VIDEO_LEVEL_H263_45,
-    MMAL_VIDEO_LEVEL_H263_50,
-    MMAL_VIDEO_LEVEL_H263_60,
-    MMAL_VIDEO_LEVEL_H263_70,
-    MMAL_VIDEO_LEVEL_MP4V_0,
-    MMAL_VIDEO_LEVEL_MP4V_0b,
-    MMAL_VIDEO_LEVEL_MP4V_1,
-    MMAL_VIDEO_LEVEL_MP4V_2,
-    MMAL_VIDEO_LEVEL_MP4V_3,
-    MMAL_VIDEO_LEVEL_MP4V_4,
-    MMAL_VIDEO_LEVEL_MP4V_4a,
-    MMAL_VIDEO_LEVEL_MP4V_5,
-    MMAL_VIDEO_LEVEL_MP4V_6,
-    MMAL_VIDEO_LEVEL_H264_1,
-    MMAL_VIDEO_LEVEL_H264_1b,
-    MMAL_VIDEO_LEVEL_H264_11,
-    MMAL_VIDEO_LEVEL_H264_12,
-    MMAL_VIDEO_LEVEL_H264_13,
-    MMAL_VIDEO_LEVEL_H264_2,
-    MMAL_VIDEO_LEVEL_H264_21,
-    MMAL_VIDEO_LEVEL_H264_22,
-    MMAL_VIDEO_LEVEL_H264_3,
-    MMAL_VIDEO_LEVEL_H264_31,
-    MMAL_VIDEO_LEVEL_H264_32,
-    MMAL_VIDEO_LEVEL_H264_4,
-    MMAL_VIDEO_LEVEL_H264_41,
-    MMAL_VIDEO_LEVEL_H264_42,
-    MMAL_VIDEO_LEVEL_H264_5,
-    MMAL_VIDEO_LEVEL_H264_51,
-    MMAL_VIDEO_LEVEL_DUMMY = 0x7FFFFFFF
-} MMAL_VIDEO_LEVEL_T;
-
-/** Video profile and level setting.
- * This is a variable length structure when querying the supported profiles and
- * levels. To get more than one, pass a structure with more profile/level pairs.
- */
-typedef struct MMAL_PARAMETER_VIDEO_PROFILE_T
-{
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   struct
-   {
-      MMAL_VIDEO_PROFILE_T profile;
-      MMAL_VIDEO_LEVEL_T level;
-   } profile[1];
-} MMAL_PARAMETER_VIDEO_PROFILE_T;
-
-/** Manner of video rate control */
-typedef enum MMAL_VIDEO_RATECONTROL_T {
-    MMAL_VIDEO_RATECONTROL_DEFAULT,
-    MMAL_VIDEO_RATECONTROL_VARIABLE,
-    MMAL_VIDEO_RATECONTROL_CONSTANT,
-    MMAL_VIDEO_RATECONTROL_VARIABLE_SKIP_FRAMES,
-    MMAL_VIDEO_RATECONTROL_CONSTANT_SKIP_FRAMES,
-    MMAL_VIDEO_RATECONTROL_DUMMY = 0x7fffffff
-} MMAL_VIDEO_RATECONTROL_T;
-
-/** Intra refresh modes */
-typedef enum MMAL_VIDEO_INTRA_REFRESH_T {
-    MMAL_VIDEO_INTRA_REFRESH_CYCLIC,
-    MMAL_VIDEO_INTRA_REFRESH_ADAPTIVE,
-    MMAL_VIDEO_INTRA_REFRESH_BOTH,
-    MMAL_VIDEO_INTRA_REFRESH_KHRONOSEXTENSIONS = 0x6F000000,
-    MMAL_VIDEO_INTRA_REFRESH_VENDORSTARTUNUSED = 0x7F000000,
-    MMAL_VIDEO_INTRA_REFRESH_CYCLIC_MROWS,
-    MMAL_VIDEO_INTRA_REFRESH_PSEUDO_RAND,
-    MMAL_VIDEO_INTRA_REFRESH_MAX,
-    MMAL_VIDEO_INTRA_REFRESH_DUMMY         = 0x7FFFFFFF
-} MMAL_VIDEO_INTRA_REFRESH_T;
-
-/*Encode RC Models Supported*/
-typedef enum MMAL_VIDEO_ENCODE_RC_MODEL_T {
-    MMAL_VIDEO_ENCODER_RC_MODEL_DEFAULT    = 0,
-    MMAL_VIDEO_ENCODER_RC_MODEL_JVT = MMAL_VIDEO_ENCODER_RC_MODEL_DEFAULT,
-    MMAL_VIDEO_ENCODER_RC_MODEL_VOWIFI,
-    MMAL_VIDEO_ENCODER_RC_MODEL_CBR,
-    MMAL_VIDEO_ENCODER_RC_MODEL_LAST,
-    MMAL_VIDEO_ENCODER_RC_MODEL_DUMMY      = 0x7FFFFFFF
-} MMAL_VIDEO_ENCODE_RC_MODEL_T;
-
-typedef struct MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T {
-    MMAL_PARAMETER_HEADER_T hdr;
-    MMAL_VIDEO_ENCODE_RC_MODEL_T rc_model;
-}MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T;
-
-/** Video rate control setting */
-typedef struct MMAL_PARAMETER_VIDEO_RATECONTROL_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_VIDEO_RATECONTROL_T control;
-} MMAL_PARAMETER_VIDEO_RATECONTROL_T;
-
-/*H264 INTRA MB MODES*/
-typedef enum MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T {
-    MMAL_VIDEO_ENCODER_H264_MB_4x4_INTRA = 1,
-    MMAL_VIDEO_ENCODER_H264_MB_8x8_INTRA = 2,
-    MMAL_VIDEO_ENCODER_H264_MB_16x16_INTRA = 4,
-    MMAL_VIDEO_ENCODER_H264_MB_INTRA_DUMMY = 0x7fffffff
-} MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T;
-
-typedef struct MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T {
-    MMAL_PARAMETER_HEADER_T hdr;
-    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T mb_mode;
-}MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T;
-
-/** NAL unit formats */
-typedef enum MMAL_VIDEO_NALUNITFORMAT_T {
-    MMAL_VIDEO_NALUNITFORMAT_STARTCODES = 1,
-    MMAL_VIDEO_NALUNITFORMAT_NALUNITPERBUFFER = 2,
-    MMAL_VIDEO_NALUNITFORMAT_ONEBYTEINTERLEAVELENGTH = 4,
-    MMAL_VIDEO_NALUNITFORMAT_TWOBYTEINTERLEAVELENGTH = 8,
-    MMAL_VIDEO_NALUNITFORMAT_FOURBYTEINTERLEAVELENGTH = 16,
-    MMAL_VIDEO_NALUNITFORMAT_DUMMY = 0x7fffffff
-} MMAL_VIDEO_NALUNITFORMAT_T;
-
-/** NAL unit format setting */
-typedef struct MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   MMAL_VIDEO_NALUNITFORMAT_T format;
-} MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T;
-
-/** H264 Only: Overrides for max macro-blocks per second, max framesize, 
- * and max bitrates. This overrides the default maximums for the configured level.
- */
-typedef struct MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t custom_max_mbps;
-   uint32_t custom_max_fs;
-   uint32_t custom_max_br_and_cpb;
-} MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T;
-
-/** H264 Only: Overrides for max macro-blocks per second, max framesize,
- * and max bitrates. This overrides the default maximums for the configured level.
- */
-typedef struct MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-    MMAL_VIDEO_INTRA_REFRESH_T refresh_mode;
-    uint32_t air_mbs;
-    uint32_t air_ref;
-    uint32_t cir_mbs;
-    uint32_t pir_mbs;
-} MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T;
-
-/** Structure for enabling EEDE, we keep it like this for now, there could be extra fields in the future */
-typedef struct MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t enable;
-} MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T;
-
-/** Structure for setting lossrate for EEDE, we keep it like this for now, there could be extra fields in the future */
-typedef struct MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t loss_rate;
-} MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T;
-
-/** Structure for setting inital DRM parameters */
-typedef struct MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t current_time;
-   uint32_t ticks_per_sec;
-   uint8_t  lhs[32];
-} MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T;
-
-/** Structure for requesting a hardware-protected memory buffer **/
-typedef struct MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T {
-   MMAL_PARAMETER_HEADER_T hdr;
-
-   uint32_t size_wanted;     /**< Input. Zero size means internal video decoder buffer,
-                                 mem_handle and phys_addr not returned in this case */
-   uint32_t protect;         /**< Input. 1 = protect, 0 = unprotect */
-
-   uint32_t mem_handle;      /**< Output. Handle for protected buffer */
-   void *   phys_addr;       /**< Output. Physical memory address of protected buffer */
-
-} MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T;
-
-#endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_pool.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_pool.h
deleted file mode 100644
index 4df5853..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_pool.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_POOL_H
-#define MMAL_POOL_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \defgroup MmalPool Pools of buffer headers
- * A pool of buffer headers is composed of a queue (\ref MMAL_QUEUE_T) and a user
- * specified number of buffer headers (\ref MMAL_BUFFER_HEADER_T). */
-/* @{ */
-
-#include "mmal_queue.h"
-
-/** Definition of a pool */
-typedef struct MMAL_POOL_T
-{
-   MMAL_QUEUE_T *queue;             /**< Queue used by the pool */
-   uint32_t headers_num;            /**< Number of buffer headers in the pool */
-   MMAL_BUFFER_HEADER_T **header;   /**< Array of buffer headers belonging to the pool */
-} MMAL_POOL_T;
-
-/** Allocator alloc prototype
- *
- * @param context The context pointer passed in on pool creation.
- * @param size    The size of the allocation required, in bytes.
- * @return The pointer to the newly allocated memory, or NULL on failure.
- */
-typedef void *(*mmal_pool_allocator_alloc_t)(void *context, uint32_t size);
-/** Allocator free prototype
- *
- * @param context The context pointer passed in on pool creation.
- * @param mem     The pointer to the memory to be released.
- */
-typedef void (*mmal_pool_allocator_free_t)(void *context, void *mem);
-
-/** Create a pool of MMAL_BUFFER_HEADER_T.
- * After allocation, all allocated buffer headers will have been added to the queue.
- *
- * It is valid to create a pool with no buffer headers, or with zero size payload buffers.
- * The mmal_pool_resize() function can be used to increase or decrease the number of buffer
- * headers, or the size of the payload buffers, after creation of the pool.
- *
- * The payload buffers may also be allocated independently by the client, and assigned
- * to the buffer headers, but it will be the responsibility of the client to deal with
- * resizing and releasing the memory. It is recommended that mmal_pool_create_with_allocator()
- * is used in this case, supplying allocator function pointers that will be used as
- * necessary by MMAL.
- *
- * @param headers      Number of buffer headers to be allocated with the pool.
- * @param payload_size Size of the payload buffer that will be allocated in 
- *                     each of the buffer headers.
- * @return Pointer to the newly created pool or NULL on failure.
- */
-MMAL_POOL_T *mmal_pool_create(unsigned int headers, uint32_t payload_size);
-
-/** Create a pool of MMAL_BUFFER_HEADER_T.
- * After allocation, all allocated buffer headers will have been added to the queue.
- *
- * It is valid to create a pool with no buffer headers, or with zero size payload buffers.
- * The mmal_pool_resize() function can be used to increase or decrease the number of buffer
- * headers, or the size of the payload buffers, after creation of the pool. The allocators
- * passed during creation shall be used when resizing the payload buffers.
- *
- * @param headers      Number of buffer headers to be allocated with the pool.
- * @param payload_size Size of the payload buffer that will be allocated in
- *                     each of the buffer headers.
- * @param allocator_context Pointer to the context of the allocator.
- * @param allocator_alloc   Function pointer for the alloc call of the allocator.
- * @param allocator_free    Function pointer for the free call of the allocator.
- *
- * @return Pointer to the newly created pool or NULL on failure.
- */
-MMAL_POOL_T *mmal_pool_create_with_allocator(unsigned int headers, uint32_t payload_size,
-                              void *allocator_context, mmal_pool_allocator_alloc_t allocator_alloc,
-                              mmal_pool_allocator_free_t allocator_free);
-
-/** Destroy a pool of MMAL_BUFFER_HEADER_T.
- * This will also deallocate all of the memory which was allocated when creating or
- * resizing the pool.
- *
- * If payload buffers have been allocated independently by the client, they should be
- * released prior to calling this function. If the client provided allocator functions,
- * the allocator_free function shall be called for each payload buffer.
- *
- * @param pool  Pointer to a pool
- */
-void mmal_pool_destroy(MMAL_POOL_T *pool);
-
-/** Resize a pool of MMAL_BUFFER_HEADER_T.
- * This allows modifying either the number of allocated buffers, the payload size or both at the
- * same time.
- *
- * @param pool         Pointer to the pool
- * @param headers      New number of buffer headers to be allocated in the pool.
- *                     It is not valid to pass zero for the number of buffers.
- * @param payload_size Size of the payload buffer that will be allocated in
- *                     each of the buffer headers.
- *                     If this is set to 0, all payload buffers shall be released.
- * @return MMAL_SUCCESS or an error on failure.
- */
-MMAL_STATUS_T mmal_pool_resize(MMAL_POOL_T *pool, unsigned int headers, uint32_t payload_size);
-
-/** Definition of the callback used by a pool to signal back to the user that a buffer header
- * has been released back to the pool.
- *
- * @param pool       Pointer to the pool
- * @param buffer     Buffer header just released
- * @param userdata   User specific data passed in when setting the callback
- * @return True to have the buffer header put back in the pool's queue, false if the buffer
- *          header has been taken within the callback.
- */
-typedef MMAL_BOOL_T (*MMAL_POOL_BH_CB_T)(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata);
-
-/** Set a buffer header release callback to the pool.
- * Each time a buffer header is released to the pool, the callback will be triggered.
- *
- * @param pool     Pointer to a pool
- * @param cb       Callback function
- * @param userdata User specific data which will be passed with each callback
- */
-void mmal_pool_callback_set(MMAL_POOL_T *pool, MMAL_POOL_BH_CB_T cb, void *userdata);
-
-/** Set a pre-release callback for all buffer headers in the pool.
- * Each time a buffer header is about to be released to the pool, the callback
- * will be triggered.
- *
- * @param pool     Pointer to the pool
- * @param cb       Pre-release callback function
- * @param userdata User-specific data passed back with each callback
- */
-void mmal_pool_pre_release_callback_set(MMAL_POOL_T *pool, MMAL_BH_PRE_RELEASE_CB_T cb, void *userdata);
-
-/* @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_POOL_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_port.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_port.h
deleted file mode 100644
index 982c45f..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_port.h
+++ /dev/null
@@ -1,286 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_PORT_H
-#define MMAL_PORT_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \defgroup MmalPort Ports
- * Definition of a MMAL port and its associated API */
-/* @{ */
-
-#include "mmal_types.h"
-#include "mmal_format.h"
-#include "mmal_buffer.h"
-#include "mmal_parameters.h"
-
-/** List of port types */
-typedef enum
-{
-   MMAL_PORT_TYPE_UNKNOWN = 0,          /**< Unknown port type */
-   MMAL_PORT_TYPE_CONTROL,              /**< Control port */
-   MMAL_PORT_TYPE_INPUT,                /**< Input port */
-   MMAL_PORT_TYPE_OUTPUT,               /**< Output port */
-   MMAL_PORT_TYPE_CLOCK,                /**< Clock port */
-   MMAL_PORT_TYPE_INVALID = 0xffffffff  /**< Dummy value to force 32bit enum */
-
-} MMAL_PORT_TYPE_T;
-
-/** \name Port capabilities
- * \anchor portcapabilities
- * The following flags describe the capabilities advertised by a port */
-/* @{ */
-/** The port is pass-through and doesn't need buffer headers allocated */
-#define MMAL_PORT_CAPABILITY_PASSTHROUGH                       0x01
-/** The port wants to allocate the buffer payloads. This signals a preference that
- * payload allocation should be done on this port for efficiency reasons. */
-#define MMAL_PORT_CAPABILITY_ALLOCATION                        0x02
-/** The port supports format change events. This applies to input ports and is used
- * to let the client know whether the port supports being reconfigured via a format
- * change event (i.e. without having to disable the port). */
-#define MMAL_PORT_CAPABILITY_SUPPORTS_EVENT_FORMAT_CHANGE      0x04
-/* @} */
-
-/** Definition of a port.
- * A port is the entity that is exposed by components to receive or transmit
- * buffer headers (\ref MMAL_BUFFER_HEADER_T). A port is defined by its
- * \ref MMAL_ES_FORMAT_T.
- *
- * It may be possible to override the buffer requirements of a port by using
- * the MMAL_PARAMETER_BUFFER_REQUIREMENTS parameter.
- */
-typedef struct MMAL_PORT_T
-{
-   struct MMAL_PORT_PRIVATE_T *priv; /**< Private member used by the framework */
-   const char *name;                 /**< Port name. Used for debugging purposes (Read Only) */
-
-   MMAL_PORT_TYPE_T type;            /**< Type of the port (Read Only) */
-   uint16_t index;                   /**< Index of the port in its type list (Read Only) */
-   uint16_t index_all;               /**< Index of the port in the list of all ports (Read Only) */
-
-   uint32_t is_enabled;              /**< Indicates whether the port is enabled or not (Read Only) */
-   MMAL_ES_FORMAT_T *format;         /**< Format of the elementary stream */
-
-   uint32_t buffer_num_min;          /**< Minimum number of buffers the port requires (Read Only).
-                                          This is set by the component. */
-   uint32_t buffer_size_min;         /**< Minimum size of buffers the port requires (Read Only).
-                                          This is set by the component. */
-   uint32_t buffer_alignment_min;    /**< Minimum alignment requirement for the buffers (Read Only).
-                                          A value of zero means no special alignment requirements.
-                                          This is set by the component. */
-   uint32_t buffer_num_recommended;  /**< Number of buffers the port recommends for optimal performance (Read Only).
-                                          A value of zero means no special recommendation.
-                                          This is set by the component. */
-   uint32_t buffer_size_recommended; /**< Size of buffers the port recommends for optimal performance (Read Only).
-                                          A value of zero means no special recommendation.
-                                          This is set by the component. */
-   uint32_t buffer_num;              /**< Actual number of buffers the port will use.
-                                          This is set by the client. */
-   uint32_t buffer_size;             /**< Actual maximum size of the buffers that will be sent
-                                          to the port. This is set by the client. */
-
-   struct MMAL_COMPONENT_T *component;    /**< Component this port belongs to (Read Only) */
-   struct MMAL_PORT_USERDATA_T *userdata; /**< Field reserved for use by the client */
-
-   uint32_t capabilities;            /**< Flags describing the capabilities of a port (Read Only).
-                                       * Bitwise combination of \ref portcapabilities "Port capabilities"
-                                       * values.
-                                       */
-
-} MMAL_PORT_T;
-
-/** Commit format changes on a port.
- *
- * @param port The port for which format changes are to be committed.
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_format_commit(MMAL_PORT_T *port);
-
-/** Definition of the callback used by a port to send a \ref MMAL_BUFFER_HEADER_T
- * back to the user.
- *
- * @param port The port sending the buffer header.
- * @param buffer The buffer header being sent.
- */
-typedef void (*MMAL_PORT_BH_CB_T)(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
-
-/** Enable processing on a port
- *
- * If this port is connected to another, the given callback must be NULL, while for a
- * disconnected port, the callback must be non-NULL.
- *
- * If this is a connected output port and is successfully enabled:
- * <ul>
- * <li>The port shall be populated with a pool of buffers, allocated as required, according
- * to the buffer_num and buffer_size values.
- * <li>The input port to which it is connected shall be set to the same buffer
- * configuration and then be enabled. Should that fail, the original port shall be
- * disabled.
- * </ul>
- *
- * @param port port to enable
- * @param cb callback use by the port to send a \ref MMAL_BUFFER_HEADER_T back
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb);
-
-/** Disable processing on a port
- *
- * Disabling a port will stop all processing on this port and return all (non-processed)
- * buffer headers to the client.
- *
- * If this is a connected output port, the input port to which it is connected shall
- * also be disabled. Any buffer pool shall be released.
- *
- * @param port port to disable
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_disable(MMAL_PORT_T *port);
-
-/** Ask a port to release all the buffer headers it currently has.
- *
- * Flushing a port will ask the port to send all the buffer headers it currently has
- * to the client. Flushing is an asynchronous request and the flush call will
- * return before all the buffer headers are returned to the client.
- * It is up to the client to keep a count on the buffer headers to know when the
- * flush operation has completed.
- * It is also important to note that flushing will also reset the state of the port
- * and any processing which was buffered by the port will be lost.
- *
- * \attention Flushing a connected port behaviour TBD.
- *
- * @param port The port to flush.
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_flush(MMAL_PORT_T *port);
-
-/** Set a parameter on a port.
- *
- * @param port The port to which the request is sent.
- * @param param The pointer to the header of the parameter to set.
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_parameter_set(MMAL_PORT_T *port,
-   const MMAL_PARAMETER_HEADER_T *param);
-
-/** Get a parameter from a port.
- * The size field must be set on input to the maximum size of the parameter
- * (including the header) and will be set on output to the actual size of the
- * parameter retrieved.
- *
- * \note If MMAL_ENOSPC is returned, the parameter is larger than the size
- * given. The given parameter will have been filled up to its size and then
- * the size field set to the full parameter's size. This can be used to
- * resize the parameter buffer so that a second call should succeed.
- *
- * @param port The port to which the request is sent.
- * @param param The pointer to the header of the parameter to get.
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_parameter_get(MMAL_PORT_T *port,
-   MMAL_PARAMETER_HEADER_T *param);
-
-/** Send a buffer header to a port.
- *
- * @param port The port to which the buffer header is to be sent.
- * @param buffer The buffer header to send.
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_send_buffer(MMAL_PORT_T *port,
-   MMAL_BUFFER_HEADER_T *buffer);
-
-/** Connect an output port to an input port.
- *
- * When connected and enabled, buffers will automatically progress from the
- * output port to the input port when they become available, and released back
- * to the output port when no longer required by the input port.
- *
- * Ports can be given either way around, but one must be an output port and
- * the other must be an input port. Neither can be connected or enabled
- * already. The format of the output port will be applied to the input port
- * on connection.
- *
- * @param port One of the ports to connect.
- * @param other_port The other port to connect.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_port_connect(MMAL_PORT_T *port, MMAL_PORT_T *other_port);
-
-/** Disconnect a connected port.
- *
- * If the port is not connected, an error will be returned. Otherwise, if the
- * ports are enabled, they will be disabled and any buffer pool created will be
- * freed.
- *
- * @param port The ports to disconnect.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_port_disconnect(MMAL_PORT_T *port);
-
-/** Allocate a payload buffer.
- * This allows a client to allocate memory for a payload buffer based on the preferences
- * of a port. This for instance will allow the port to allocate memory which can be shared
- * between the host processor and videocore.
- *
- * See \ref mmal_pool_create_with_allocator().
- *
- * @param port         Port responsible for allocating the memory.
- * @param payload_size Size of the payload buffer which will be allocated.
- *
- * @return Pointer to the allocated memory.
- */
-uint8_t *mmal_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_size);
-
-/** Free a payload buffer.
- * This allows a client to free memory allocated by a previous call to \ref mmal_port_payload_alloc.
- *
- * See \ref mmal_pool_create_with_allocator().
- *
- * @param port         Port responsible for allocating the memory.
- * @param payload      Pointer to the memory to free.
- */
-void mmal_port_payload_free(MMAL_PORT_T *port, uint8_t *payload);
-
-/** Get an empty event buffer header from a port
- *
- * @param port The port from which to get the event buffer header.
- * @param buffer The address of a buffer header pointer, which will be set on return.
- * @param event The specific event FourCC required. See the \ref MmalEvents "pre-defined events".
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_port_event_get(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t event);
-
-/* @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_PORT_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_queue.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_queue.h
deleted file mode 100644
index b85cd1a..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_queue.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_QUEUE_H
-#define MMAL_QUEUE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \defgroup MmalQueue Queues of buffer headers
- * This provides a thread-safe implementation of a queue of buffer headers
- * (\ref MMAL_BUFFER_HEADER_T). The queue works in a first-in, first-out basis
- * so the buffer headers will be dequeued in the order they have been queued. */
-/* @{ */
-
-#include "mmal_buffer.h"
-
-typedef struct MMAL_QUEUE_T MMAL_QUEUE_T;
-
-/** Create a queue of MMAL_BUFFER_HEADER_T
- *
- * @return Pointer to the newly created queue or NULL on failure.
- */
-MMAL_QUEUE_T *mmal_queue_create(void);
-
-/** Put a MMAL_BUFFER_HEADER_T into a queue
- *
- * @param queue  Pointer to a queue
- * @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue
- */
-void mmal_queue_put(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer);
-
-/** Put a MMAL_BUFFER_HEADER_T back at the start of a queue.
- * This is used when a buffer header was removed from the queue but not
- * fully processed and needs to be put back where it was originally taken.
- *
- * @param queue  Pointer to a queue
- * @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue
- */
-void mmal_queue_put_back(MMAL_QUEUE_T *queue, MMAL_BUFFER_HEADER_T *buffer);
-
-/** Get a MMAL_BUFFER_HEADER_T from a queue
- *
- * @param queue  Pointer to a queue
- *
- * @return pointer to the next MMAL_BUFFER_HEADER_T or NULL if the queue is empty.
- */
-MMAL_BUFFER_HEADER_T *mmal_queue_get(MMAL_QUEUE_T *queue);
-
-/** Wait for a MMAL_BUFFER_HEADER_T from a queue.
- * This is the same as a get except that this will block until a buffer header is
- * available.
- *
- * @param queue  Pointer to a queue
- *
- * @return pointer to the next MMAL_BUFFER_HEADER_T.
- */
-MMAL_BUFFER_HEADER_T *mmal_queue_wait(MMAL_QUEUE_T *queue);
-
-/** Get the number of MMAL_BUFFER_HEADER_T currently in a queue.
- *
- * @param queue  Pointer to a queue
- *
- * @return length (in elements) of the queue.
- */
-unsigned int mmal_queue_length(MMAL_QUEUE_T *queue);
-
-/** Destroy a queue of MMAL_BUFFER_HEADER_T.
- *
- * @param queue  Pointer to a queue
- */
-void mmal_queue_destroy(MMAL_QUEUE_T *queue);
-
-/* @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_QUEUE_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_types.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_types.h
deleted file mode 100644
index 741f742..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/mmal_types.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_TYPES_H
-#define MMAL_TYPES_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \defgroup MmalTypes Common types
- * Definition for common types */
-/* @{ */
-
-#include "mmal_common.h"
-
-/** Status return codes from the API.
- *
- * \internal Please try to keep this similar to the standard POSIX codes
- * rather than making up new ones!
- */
-typedef enum
-{
-   MMAL_SUCCESS = 0,                 /**< Success */
-   MMAL_ENOMEM,                      /**< Out of memory */
-   MMAL_ENOSPC,                      /**< Out of resources (other than memory) */
-   MMAL_EINVAL,                      /**< Argument is invalid */
-   MMAL_ENOSYS,                      /**< Function not implemented */
-   MMAL_ENOENT,                      /**< No such file or directory */
-   MMAL_ENXIO,                       /**< No such device or address */
-   MMAL_EIO,                         /**< I/O error */
-   MMAL_ESPIPE,                      /**< Illegal seek */
-   MMAL_ECORRUPT,                    /**< Data is corrupt \attention FIXME: not POSIX */
-   MMAL_ENOTREADY,                   /**< Component is not ready \attention FIXME: not POSIX */
-   MMAL_ECONFIG,                     /**< Component is not configured \attention FIXME: not POSIX */
-   MMAL_EISCONN,                     /**< Port is already connected */
-   MMAL_ENOTCONN,                    /**< Port is disconnected */
-   MMAL_EAGAIN,                      /**< Resource temporarily unavailable. Try again later*/
-   MMAL_EFAULT,                      /**< Bad address */
-   /* Do not add new codes here unless they match something from POSIX */
-   MMAL_STATUS_MAX = 0x7FFFFFFF      /**< Force to 32 bit */
-} MMAL_STATUS_T;
-
-/** Describes a rectangle */
-typedef struct
-{
-   int32_t x;      /**< x coordinate (from left) */
-   int32_t y;      /**< y coordinate (from top) */
-   int32_t width;  /**< width */
-   int32_t height; /**< height */
-} MMAL_RECT_T;
-
-/** Describes a rational number */
-typedef struct
-{
-   int32_t num;    /**< Numerator */
-   int32_t den;    /**< Denominator */
-} MMAL_RATIONAL_T;
-
-/** \name Special Unknown Time Value
- * Timestamps in MMAL are defined as signed 64 bits integer values representing microseconds.
- * However a pre-defined special value is used to signal that a timestamp is not known. */
-/* @{ */
-#define MMAL_TIME_UNKNOWN (INT64_C(1)<<63)  /**< Special value signalling that time is not known */
-/* @} */
-
-/** Four Character Code type */
-typedef uint32_t MMAL_FOURCC_T;
-
-/* @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_TYPES_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/CMakeLists.txt b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/CMakeLists.txt
deleted file mode 100644
index 66a9009..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/CMakeLists.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-add_library (mmal_util SHARED
-   mmal_il.c
-   mmal_util.c
-   mmal_connection.c
-   mmal_graph.c
-   mmal_list.c
-   mmal_param_convert.c
-   mmal_util_params.c
-   mmal_component_wrapper.c
-   mmal_util_rational.c
-)
-
-target_link_libraries (mmal_util vcos)
-
-install(TARGETS mmal_util DESTINATION lib)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_component_wrapper.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_component_wrapper.c
deleted file mode 100644
index 8548aca..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_component_wrapper.c
+++ /dev/null
@@ -1,368 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "util/mmal_util.h"
-#include "util/mmal_component_wrapper.h"
-#include "mmal_logging.h"
-#include <stdio.h>
-
-typedef struct
-{
-   MMAL_WRAPPER_T wrapper; /**< Must be the first member! */
-
-   VCOS_SEMAPHORE_T sema;
-
-} MMAL_WRAPPER_PRIVATE_T;
-
-/** Callback from a control port. Error events will be received there. */
-static void mmal_wrapper_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
-   LOG_TRACE("%s(%p),%p,%4.4s", port->name, port, buffer, (char *)&buffer->cmd);
-
-   if (buffer->cmd == MMAL_EVENT_ERROR)
-   {
-      private->wrapper.status = *(MMAL_STATUS_T *)buffer->data;
-      mmal_buffer_header_release(buffer);
-
-      vcos_semaphore_post(&private->sema);
-
-      if (private->wrapper.callback)
-         private->wrapper.callback(&private->wrapper);
-      return;
-   }
-
-   mmal_buffer_header_release(buffer);
-}
-
-/** Callback from an input port. Buffer is released. */
-static void mmal_wrapper_bh_in_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_PARAM_UNUSED(port);
-   LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);
-
-   /* We're done with the buffer, just recycle it */
-   mmal_buffer_header_release(buffer);
-}
-
-/** Callback from an output port. Buffer is queued for the next component. */
-static void mmal_wrapper_bh_out_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
-   LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);
-
-   /* Queue the buffer produced by the output port */
-   mmal_queue_put(private->wrapper.output_queue[port->index], buffer);
-   vcos_semaphore_post(&private->sema);
-
-   if (private->wrapper.callback)
-      private->wrapper.callback(&private->wrapper);
-}
-
-/** Callback from the pool. Buffer is available. */
-static MMAL_BOOL_T mmal_wrapper_bh_release_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer,
-   void *userdata)
-{
-   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)userdata;
-
-   mmal_queue_put(pool->queue, buffer);
-   vcos_semaphore_post(&private->sema);
-
-   if (private->wrapper.callback)
-      private->wrapper.callback(&private->wrapper);
-
-   return 0;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_wrapper_destroy(MMAL_WRAPPER_T *wrapper)
-{
-   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)wrapper;
-   unsigned int i;
-
-   LOG_TRACE("%p, %s", wrapper, wrapper->component->name);
-
-   /* Cleanup resources */
-   mmal_component_destroy(wrapper->component);
-
-   for (i = 0; i < wrapper->input_num; i++)
-   {
-      if (wrapper->input_pool[i])
-         mmal_pool_destroy(wrapper->input_pool[i]);
-   }
-
-   for (i = 0; i < wrapper->output_num; i++)
-   {
-      if (wrapper->output_pool[i])
-         mmal_pool_destroy(wrapper->output_pool[i]);
-      if (wrapper->output_queue[i])
-         mmal_queue_destroy(wrapper->output_queue[i]);
-   }
-
-   vcos_semaphore_delete(&private->sema);
-   vcos_free(private);
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_wrapper_create(MMAL_WRAPPER_T **ctx, const char *name)
-{
-   MMAL_STATUS_T status;
-   MMAL_COMPONENT_T *component;
-   MMAL_WRAPPER_PRIVATE_T *private;
-   MMAL_WRAPPER_T *wrapper;
-   int64_t start_time;
-   unsigned int i, extra_size;
-
-   LOG_TRACE("wrapper %p, name %s", ctx, name);
-
-   /* Sanity checking */
-   if (!ctx || !name)
-      return MMAL_EINVAL;
-
-   start_time = vcos_getmicrosecs();
-
-   status = mmal_component_create(name, &component);
-   if (status != MMAL_SUCCESS)
-      return status;
-
-   extra_size = (component->input_num + component->output_num) * 2;
-   private = vcos_calloc(1, sizeof(*private) + extra_size, "mmal wrapper");
-   if (!private)
-   {
-      mmal_component_destroy(component);
-      return MMAL_ENOMEM;
-   }
-
-   if (vcos_semaphore_create(&private->sema, "mmal wrapper", 0) != VCOS_SUCCESS)
-   {
-      mmal_component_destroy(component);
-      vcos_free(private);
-      return MMAL_ENOMEM;
-   }
-
-   wrapper = &private->wrapper;
-   wrapper->component = component;
-   wrapper->control = component->control;
-   wrapper->input_num = component->input_num;
-   wrapper->input = component->input;
-   wrapper->output_num = component->output_num;
-   wrapper->output = component->output;
-   wrapper->input_pool = (MMAL_POOL_T **)&private[1];
-   wrapper->output_pool = (MMAL_POOL_T **)&wrapper->input_pool[component->input_num];
-   wrapper->output_queue = (MMAL_QUEUE_T **)&wrapper->output_pool[component->output_num];
-
-   /* Create our pools and queues */
-   for (i = 0; i < wrapper->input_num; i++)
-   {
-      wrapper->input_pool[i] = mmal_port_pool_create(wrapper->input[i], 0, 0);
-      if (!wrapper->input_pool[i])
-         goto error;
-      mmal_pool_callback_set(wrapper->input_pool[i], mmal_wrapper_bh_release_cb, (void *)wrapper);
-
-      wrapper->input[i]->userdata = (void *)wrapper;
-   }
-   for (i = 0; i < wrapper->output_num; i++)
-   {
-      wrapper->output_pool[i] = mmal_port_pool_create(wrapper->output[i], 0, 0);
-      wrapper->output_queue[i] = mmal_queue_create();
-      if (!wrapper->output_pool[i] || !wrapper->output_queue[i])
-         goto error;
-      mmal_pool_callback_set(wrapper->output_pool[i], mmal_wrapper_bh_release_cb, (void *)wrapper);
-
-      wrapper->output[i]->userdata = (void *)wrapper;
-   }
-
-   /* Setup control port */
-   wrapper->control->userdata = (void *)wrapper;
-   status = mmal_port_enable(wrapper->control, mmal_wrapper_control_cb);
-   if (status != MMAL_SUCCESS)
-      goto error;
-
-   wrapper->time_setup = vcos_getmicrosecs() - start_time;
-   *ctx = wrapper;
-   return MMAL_SUCCESS;
-
- error:
-   mmal_wrapper_destroy(wrapper);
-   return status == MMAL_SUCCESS ? MMAL_ENOMEM : status;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_wrapper_port_enable(MMAL_PORT_T *port, uint32_t flags)
-{
-   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
-   MMAL_WRAPPER_T *wrapper = &private->wrapper;
-   int64_t start_time = vcos_getmicrosecs();
-   uint32_t buffer_size;
-   MMAL_STATUS_T status;
-   MMAL_POOL_T *pool;
-
-   LOG_TRACE("%p, %s", wrapper, port->name);
-
-   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
-      return MMAL_EINVAL;
-
-   if (port->is_enabled)
-      return MMAL_SUCCESS;
-
-   pool = port->type == MMAL_PORT_TYPE_INPUT ?
-      wrapper->input_pool[port->index] : wrapper->output_pool[port->index];
-   buffer_size = (flags & MMAL_WRAPPER_FLAG_PAYLOAD_ALLOCATE) ? port->buffer_size : 0;
-
-   /* FIXME: we don't support switching between shared and non-shared memory.
-    * We would need to save the flag and force a pool resize when switching. */
-   if (flags & MMAL_WRAPPER_FLAG_PAYLOAD_USE_SHARED_MEMORY)
-   {
-      MMAL_PARAMETER_BOOLEAN_T param_zc =
-         {{MMAL_PARAMETER_ZERO_COPY, sizeof(MMAL_PARAMETER_BOOLEAN_T)}, 1};
-      status = mmal_port_parameter_set(port, &param_zc.hdr);
-      if (status != MMAL_SUCCESS && status != MMAL_ENOSYS)
-      {
-         LOG_ERROR("failed to set zero copy on %s", port->name);
-         return status;
-      }
-   }
-
-   /* Resize the pool */
-   status = mmal_pool_resize(pool, port->buffer_num, buffer_size);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("could not resize pool (%i/%i)", (int)port->buffer_num, (int)buffer_size);
-      return status;
-   }
-
-   /* Enable port. The callback specified here is the function which
-    * will be called when a buffer header comes back to the port. */
-   status = mmal_port_enable(port, port->type == MMAL_PORT_TYPE_INPUT ?
-                             mmal_wrapper_bh_in_cb : mmal_wrapper_bh_out_cb);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("could not enable port");
-      return status;
-   }
-
-   wrapper->time_enable += vcos_getmicrosecs() - start_time;
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_wrapper_port_disable(MMAL_PORT_T *port)
-{
-   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
-   MMAL_WRAPPER_T *wrapper = &private->wrapper;
-   int64_t start_time = vcos_getmicrosecs();
-   MMAL_STATUS_T status;
-
-   LOG_TRACE("%p, %s", wrapper, port->name);
-
-   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
-      return MMAL_EINVAL;
-
-   if (!port->is_enabled)
-      return MMAL_SUCCESS;
-
-   /* Disable port */
-   status = mmal_port_disable(port);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("could not disable port");
-      return status;
-   }
-
-   /* Flush the queue */
-   if (port->type == MMAL_PORT_TYPE_OUTPUT)
-   {
-      MMAL_POOL_T *pool = wrapper->output_pool[port->index];
-      MMAL_QUEUE_T *queue = wrapper->output_queue[port->index];
-      MMAL_BUFFER_HEADER_T *buffer;
-
-      while ((buffer = mmal_queue_get(queue)) != NULL)
-         mmal_buffer_header_release(buffer);
-
-      if ( !vcos_verify(mmal_queue_length(pool->queue) == pool->headers_num) )
-      {
-         LOG_ERROR("coul dnot release all buffers");
-      }
-   }
-
-   wrapper->time_disable = vcos_getmicrosecs() - start_time;
-   return status;
-}
-
-/** Wait for an empty buffer to be available on a port */
-MMAL_STATUS_T mmal_wrapper_buffer_get_empty(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer,
-   uint32_t flags)
-{
-   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
-   MMAL_WRAPPER_T *wrapper = &private->wrapper;
-   MMAL_POOL_T *pool;
-
-   LOG_TRACE("%p, %s", wrapper, port->name);
-
-   if (!buffer || (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT))
-      return MMAL_EINVAL;
-
-   pool = port->type == MMAL_PORT_TYPE_INPUT ?
-      wrapper->input_pool[port->index] : wrapper->output_pool[port->index];
-
-   while (wrapper->status == MMAL_SUCCESS &&
-          (*buffer = mmal_queue_get(pool->queue)) == NULL)
-   {
-      if (!(flags & MMAL_WRAPPER_FLAG_WAIT))
-         break;
-      vcos_semaphore_wait(&private->sema);
-   }
-
-   return wrapper->status == MMAL_SUCCESS && !*buffer ? MMAL_EAGAIN : wrapper->status;
-}
-
-/** Wait for a full buffer to be available on a port */
-MMAL_STATUS_T mmal_wrapper_buffer_get_full(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer,
-   uint32_t flags)
-{
-   MMAL_WRAPPER_PRIVATE_T *private = (MMAL_WRAPPER_PRIVATE_T *)port->userdata;
-   MMAL_WRAPPER_T *wrapper = &private->wrapper;
-   MMAL_QUEUE_T *queue;
-
-   LOG_TRACE("%p, %s", wrapper, port->name);
-
-   if (!buffer || port->type != MMAL_PORT_TYPE_OUTPUT)
-      return MMAL_EINVAL;
-   queue = wrapper->output_queue[port->index];
-
-   while (wrapper->status == MMAL_SUCCESS &&
-          (*buffer = mmal_queue_get(queue)) == NULL)
-   {
-      if (!(flags & MMAL_WRAPPER_FLAG_WAIT))
-         break;
-      vcos_semaphore_wait(&private->sema);
-   }
-
-   return wrapper->status == MMAL_SUCCESS && !*buffer ? MMAL_EAGAIN : wrapper->status;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_component_wrapper.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_component_wrapper.h
deleted file mode 100644
index ce29ae6..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_component_wrapper.h
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_WRAPPER_H
-#define MMAL_WRAPPER_H
-
-/** \defgroup MmalComponentWrapper utility
- * \ingroup MmalUtilities
- * The component wrapper utility functions can be used in place of common sequences
- * of calls to the MMAL API in order to control a standalone component. It hides some
- * of the complexity in using standalone components behind a fully synchronous
- * interface.
- * @{
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Forward type definition for a wrapper */
-typedef struct MMAL_WRAPPER_T MMAL_WRAPPER_T;
-
-/** Definition of the callback used by a wrapper to signal back to the client
- * that a buffer header is available either in the pool or in the output queue.
- *
- * @param wrapper Pointer to the wrapper
- */
-typedef void (*MMAL_WRAPPER_CALLBACK_T)(MMAL_WRAPPER_T *wrapper);
-
-/** Structure describing a wrapper around a component */
-struct MMAL_WRAPPER_T {
-
-   void *user_data;           /**< Field reserved for use by the client. */
-   MMAL_WRAPPER_CALLBACK_T callback; /**< Callback set by the client. */
-   MMAL_COMPONENT_T *component;
-   MMAL_STATUS_T status;
-
-   MMAL_PORT_T *control;        /**< Control port (Read Only). */
-
-   uint32_t    input_num;       /**< Number of input ports (Read Only). */
-   MMAL_PORT_T **input;         /**< Array of input ports (Read Only). */
-   MMAL_POOL_T **input_pool;    /**< Array of input pools (Read Only). */
-
-   uint32_t    output_num;      /**< Number of output ports (Read Only). */
-   MMAL_PORT_T **output;        /**< Array of output ports (Read Only). */
-   MMAL_POOL_T **output_pool;   /**< Array of output pools (Read Only). */
-   MMAL_QUEUE_T **output_queue; /**< Array of output queues (Read Only). */
-
-   /* Used for debug / statistics */
-   int64_t time_setup;          /**< Time in microseconds taken to setup the connection. */
-   int64_t time_enable;         /**< Time in microseconds taken to enable the connection. */
-   int64_t time_disable;        /**< Time in microseconds taken to disable the connection. */
-
-};
-
-/** Create a wrapper around a component.
- * The wrapper shall include a pool of buffer headers for each port. The pools will be suitable
- * for the current format of its associated port.
- *
- * @param wrapper    The address of a wrapper pointer that will be set to point to the created
- *                   wrapper.
- * @param name       The name of the component to create.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_wrapper_create(MMAL_WRAPPER_T **wrapper, const char *name);
-
-/** \name MMAL wrapper flags
- * \anchor wrapperflags
- */
-/* @{ */
-/** The operation should be blocking */
-#define MMAL_WRAPPER_FLAG_WAIT 1
-/** The pool for the port should allocate memory for the payloads */
-#define MMAL_WRAPPER_FLAG_PAYLOAD_ALLOCATE 2
-/** The port will use shared memory payloads */
-#define MMAL_WRAPPER_FLAG_PAYLOAD_USE_SHARED_MEMORY 4
-/* @} */
-
-/** Enable a port on a component wrapper.
- *
- * @param port port to enable
- * @param flags used to specify payload allocation flags for the pool
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_wrapper_port_enable(MMAL_PORT_T *port, uint32_t flags);
-
-/** Disable a port on a component wrapper.
- *
- * @param port port to disable
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_wrapper_port_disable(MMAL_PORT_T *port);
-
-/** Wait for an empty buffer to be available on a port.
- *
- * @param port port to get an empty buffer from
- * @param buffer points to the retreived buffer on return
- * @param flags specify MMAL_WRAPPER_FLAG_WAIT for a blocking operation
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_wrapper_buffer_get_empty(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t flags);
-
-/** Wait for a full buffer to be available on a port.
- *
- * @param port port to get a full buffer from
- * @param buffer points to the retreived buffer on return
- * @param flags specify MMAL_WRAPPER_FLAG_WAIT for a blocking operation
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_wrapper_buffer_get_full(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T **buffer, uint32_t flags);
-
-/** Cancel any ongoing blocking operation on a component wrapper.
- *
- * @param wrapper The wrapper on which to cancel operations.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_wrapper_cancel(MMAL_WRAPPER_T *wrapper);
-
-/** Destroy a wrapper.
- * Destroys a component wrapper and any resources it owns.
- *
- * @param wrapper The wrapper to be destroyed.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_wrapper_destroy(MMAL_WRAPPER_T *wrapper);
-
-#ifdef __cplusplus
-}
-#endif
-
-/** @} */
-
-#endif /* MMAL_WRAPPER_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.c
deleted file mode 100644
index a5f9a8d..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.c
+++ /dev/null
@@ -1,498 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "util/mmal_util.h"
-#include "util/mmal_connection.h"
-#include "mmal_logging.h"
-#include <stdio.h>
-
-#define CONNECTION_NAME_FORMAT "%s:%.2222s:%i/%s:%.2222s:%i"
-
-typedef struct
-{
-   MMAL_CONNECTION_T connection; /**< Must be the first member! */
-   MMAL_PORT_T *pool_port;       /**< Port used to create the pool */
-
-   /** Reference counting */
-   int refcount;
-
-} MMAL_CONNECTION_PRIVATE_T;
-
-/** Callback from an input port. Buffer is released. */
-static void mmal_connection_bh_in_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_PARAM_UNUSED(port);
-   LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);
-   /* We're done with the buffer, just recycle it */
-   mmal_buffer_header_release(buffer);
-}
-
-/** Callback from an output port. Buffer is queued for the next component. */
-static void mmal_connection_bh_out_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_CONNECTION_T *connection = (MMAL_CONNECTION_T *)port->userdata;
-   MMAL_PARAM_UNUSED(port);
-   LOG_TRACE("(%s)%p,%p,%p,%i", port->name, port, buffer, buffer->data, (int)buffer->length);
-
-   /* Queue the buffer produced by the output port */
-   mmal_queue_put(connection->queue, buffer);
-
-   if (connection->callback)
-      connection->callback(connection);
-}
-
-/** Callback from the pool. Buffer is available. */
-static MMAL_BOOL_T mmal_connection_bh_release_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer,
-   void *userdata)
-{
-   MMAL_CONNECTION_T *connection = (MMAL_CONNECTION_T *)userdata;
-   MMAL_PARAM_UNUSED(pool);
-
-   /* Queue the buffer produced by the output port */
-   mmal_queue_put(pool->queue, buffer);
-
-   if (connection->callback)
-      connection->callback(connection);
-
-   return 0;
-}
-
-/*****************************************************************************/
-static MMAL_STATUS_T mmal_connection_destroy_internal(MMAL_CONNECTION_T *connection)
-{
-   MMAL_STATUS_T status;
-
-   if (connection->is_enabled)
-   {
-      status = mmal_connection_disable(connection);
-      if (status != MMAL_SUCCESS)
-         return status;
-   }
-
-   /* Special case for tunnelling */
-   if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
-   {
-      status = mmal_port_disconnect(connection->out);
-      if (status != MMAL_SUCCESS)
-         LOG_ERROR("connection %s could not be cleared", connection->name);
-   }
-
-   /* Cleanup resources */
-   if (connection->pool)
-      mmal_pool_destroy(connection->pool);
-   if (connection->queue)
-      mmal_queue_destroy(connection->queue);
-
-   vcos_free(connection);
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_connection_destroy(MMAL_CONNECTION_T *connection)
-{
-   MMAL_CONNECTION_PRIVATE_T *private = (MMAL_CONNECTION_PRIVATE_T *)connection;
-
-   LOG_TRACE("%p, %s", connection, connection->name);
-
-   if (--private->refcount)
-   {
-      LOG_DEBUG("delaying destruction of %s (refount %i)", connection->name,
-                private->refcount);
-      return MMAL_SUCCESS;
-   }
-
-   return mmal_connection_destroy_internal(connection);
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_connection_create(MMAL_CONNECTION_T **cx,
-   MMAL_PORT_T *out, MMAL_PORT_T *in, uint32_t flags)
-{
-   MMAL_STATUS_T status = MMAL_ENOMEM;
-   unsigned int name_size = strlen(out->component->name) + strlen(in->component->name) + sizeof(CONNECTION_NAME_FORMAT);
-   unsigned int size = sizeof(MMAL_CONNECTION_PRIVATE_T) + name_size;
-   MMAL_CONNECTION_PRIVATE_T *private;
-   MMAL_CONNECTION_T *connection;
-   char *name;
-
-   /* Sanity checking */
-   if (!cx)
-      return MMAL_EINVAL;
-
-   private = vcos_malloc(size, "mmal connection");
-   if (!private)
-      return MMAL_ENOMEM;
-   memset(private, 0, size);
-   connection = &private->connection;
-   private->refcount = 1;
-   name = (char *)&private[1];
-
-   vcos_snprintf(name, name_size - 1, CONNECTION_NAME_FORMAT,
-            out->component->name,
-            mmal_port_type_to_string(out->type), (int)out->index,
-            in->component->name,
-            mmal_port_type_to_string(in->type), (int)in->index);
-
-   LOG_TRACE("out %p, in %p, flags %x, %s", out, in, flags, name);
-
-   connection->out = out;
-   connection->in = in;
-   connection->flags = flags;
-   connection->name = name;
-
-   connection->time_setup = vcos_getmicrosecs();
-
-   /* Set the format of the input port to match the output one */
-   status = mmal_format_full_copy(in->format, out->format);
-   if (status == MMAL_SUCCESS)
-      status = mmal_port_format_commit(in);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("format not set on input port");
-      goto error;
-   }
-
-   /* In pass-through mode we need to propagate the buffer requirements of the
-    * connected input port */
-   if (out->capabilities & MMAL_PORT_CAPABILITY_PASSTHROUGH)
-   {
-      MMAL_PARAMETER_BUFFER_REQUIREMENTS_T param =
-         {{MMAL_PARAMETER_BUFFER_REQUIREMENTS, sizeof(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T)},
-           in->buffer_num_min, in->buffer_size_min, in->buffer_alignment_min,
-           in->buffer_num_recommended, in->buffer_size_recommended};
-      status = mmal_port_parameter_set(out, &param.hdr);
-      if (status != MMAL_SUCCESS && status != MMAL_ENOSYS)
-      {
-         LOG_ERROR("failed to propagate buffer requirements");
-         goto error;
-      }
-   }
-
-   /* Special case for tunnelling */
-   if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
-   {
-      status = mmal_port_connect(out, in);
-      if (status != MMAL_SUCCESS)
-         LOG_ERROR("connection could not be made");
-      goto done;
-   }
-
-   /* Create empty pool of buffer headers for now (will be resized later on) */
-   private->pool_port = (in->capabilities & MMAL_PORT_CAPABILITY_ALLOCATION) ? in : out;
-   if (flags & MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT)
-      private->pool_port = in;
-   if (flags & MMAL_CONNECTION_FLAG_ALLOCATION_ON_OUTPUT)
-      private->pool_port = out;
-   connection->pool = mmal_port_pool_create(private->pool_port, 0, 0);
-   if (!connection->pool)
-      goto error;
-   mmal_pool_callback_set(connection->pool, mmal_connection_bh_release_cb, (void *)connection);
-
-   /* Create a queue to store the buffers from the output port */
-   connection->queue = mmal_queue_create();
-   if (!connection->queue)
-      goto error;
-
- done:
-   out->userdata = (void *)connection;
-   in->userdata = (void *)connection;
-   connection->time_setup = vcos_getmicrosecs() - connection->time_setup;
-   *cx = connection;
-   return status;
-
- error:
-   mmal_connection_destroy_internal(connection);
-   return status == MMAL_SUCCESS ? MMAL_ENOMEM : status;
-}
-
-/*****************************************************************************/
-void mmal_connection_acquire(MMAL_CONNECTION_T *connection)
-{
-   MMAL_CONNECTION_PRIVATE_T *private = (MMAL_CONNECTION_PRIVATE_T *)connection;
-   LOG_TRACE("connection %s(%p), refcount %i", connection->name, connection,
-             private->refcount);
-   private->refcount++;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_connection_release(MMAL_CONNECTION_T *connection)
-{
-   MMAL_CONNECTION_PRIVATE_T *private = (MMAL_CONNECTION_PRIVATE_T *)connection;
-   LOG_TRACE("connection %s(%p), refcount %i", connection->name, connection,
-             private->refcount);
-
-   if (--private->refcount)
-      return MMAL_SUCCESS;
-
-   LOG_TRACE("destroying connection %s(%p)", connection->name, connection);
-   return mmal_connection_destroy_internal(connection);
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_connection_enable(MMAL_CONNECTION_T *connection)
-{
-   MMAL_PORT_T *in = connection->in, *out = connection->out;
-   uint32_t buffer_num, buffer_size;
-   MMAL_STATUS_T status;
-
-   LOG_TRACE("%p, %s", connection, connection->name);
-
-   if (connection->is_enabled)
-      return MMAL_SUCCESS;
-
-   connection->time_enable = vcos_getmicrosecs();
-
-   /* Override the buffer values with the recommended ones (the port probably knows best) */
-   if (out->buffer_num_recommended)
-      out->buffer_num = out->buffer_num_recommended;
-   if (out->buffer_size_recommended)
-      out->buffer_size = out->buffer_size_recommended;
-   if (in->buffer_num_recommended)
-      in->buffer_num = in->buffer_num_recommended;
-   if (in->buffer_size_recommended)
-      in->buffer_size = in->buffer_size_recommended;
-
-   /* Special case for tunnelling */
-   if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
-   {
-      /* Enable port. No callback because the port is connected. Other end of the connection
-       * will be enabled automatically. */
-      status = mmal_port_enable(out, NULL);
-      if (status)
-         LOG_ERROR("output port couldn't be enabled");
-      goto done;
-   }
-
-   /* Set the buffering properties on both ports */
-   buffer_num = MMAL_MAX(out->buffer_num, in->buffer_num);
-   buffer_size = MMAL_MAX(out->buffer_size, in->buffer_size);
-   out->buffer_num = in->buffer_num = buffer_num;
-   out->buffer_size = in->buffer_size = buffer_size;
-
-   /* In pass-through mode there isn't any need to allocate memory */
-   if (out->capabilities & MMAL_PORT_CAPABILITY_PASSTHROUGH)
-      buffer_size = 0;
-
-   /* Resize the output pool */
-   status = mmal_pool_resize(connection->pool, buffer_num, buffer_size);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("couldn't resize pool");
-      goto done;
-   }
-
-   /* Enable output port. The callback specified here is the function which
-    * will be called when an empty buffer header comes back to the port. */
-   status = mmal_port_enable(out, mmal_connection_bh_out_cb);
-   if(status)
-   {
-      LOG_ERROR("output port couldn't be enabled");
-      goto done;
-   }
-
-   /* Enable input port. The callback specified here is the function which
-    * will be called when an empty buffer header comes back to the port. */
-   status = mmal_port_enable(in, mmal_connection_bh_in_cb);
-   if(status)
-   {
-      LOG_ERROR("input port couldn't be enabled");
-      mmal_port_disable(out);
-      goto done;
-   }
-
-   /* Clock ports need buffers to send clock updates, so
-    * populate both connected clock ports */
-   if ((out->type == MMAL_PORT_TYPE_CLOCK) && (in->type == MMAL_PORT_TYPE_CLOCK))
-   {
-      MMAL_BUFFER_HEADER_T *buffer = mmal_queue_get(connection->pool->queue);
-      while (buffer)
-      {
-         mmal_port_send_buffer(out, buffer);
-         buffer = mmal_queue_get(connection->pool->queue);
-         if (buffer)
-         {
-            mmal_port_send_buffer(in, buffer);
-            buffer = mmal_queue_get(connection->pool->queue);
-         }
-      }
-   }
-
- done:
-   connection->time_enable = vcos_getmicrosecs() - connection->time_enable;
-   connection->is_enabled = status == MMAL_SUCCESS;
-   return status;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_connection_disable(MMAL_CONNECTION_T *connection)
-{
-   MMAL_STATUS_T status;
-   MMAL_BUFFER_HEADER_T *buffer;
-
-   LOG_TRACE("%p, %s", connection, connection->name);
-
-   if (!connection->is_enabled)
-      return MMAL_SUCCESS;
-
-   connection->time_disable = vcos_getmicrosecs();
-
-   /* Special case for tunnelling */
-   if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
-   {
-      /* Disable port. Other end of the connection will be disabled automatically. */
-      status = mmal_port_disable(connection->out);
-      if (status)
-         LOG_ERROR("output port couldn't be disabled");
-      goto done;
-   }
-
-   /* Disable input port. */
-   status = mmal_port_disable(connection->in);
-   if(status)
-   {
-      LOG_ERROR("input port couldn't be disabled");
-      goto done;
-   }
-
-   /* Disable output port */
-   status = mmal_port_disable(connection->out);
-   if(status)
-   {
-      LOG_ERROR("output port couldn't be disabled");
-      goto done;
-   }
-
-   /* Flush the queue */
-   buffer = mmal_queue_get(connection->queue);
-   while (buffer)
-   {
-      mmal_buffer_header_release(buffer);
-      buffer = mmal_queue_get(connection->queue);
-   }
-   vcos_assert(mmal_queue_length(connection->pool->queue) == connection->pool->headers_num);
-
- done:
-   connection->time_disable = vcos_getmicrosecs() - connection->time_disable;
-   connection->is_enabled = !(status == MMAL_SUCCESS);
-   return status;
-}
-
-/*****************************************************************************/
-static MMAL_STATUS_T mmal_connection_reconfigure(MMAL_CONNECTION_T *connection, MMAL_ES_FORMAT_T *format)
-{
-   MMAL_STATUS_T status;
-   LOG_TRACE("%p, %s", connection, connection->name);
-
-   status = mmal_connection_disable(connection);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("connection couldn't be disabled");
-      return status;
-   }
-
-   /* Set the new format for the output port */
-   status = mmal_format_full_copy(connection->out->format, format);
-   if (status == MMAL_SUCCESS)
-      status = mmal_port_format_commit(connection->out);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("commit failed on port %s(%p) (%i)",
-                connection->out->name, connection->out, status);
-      return status;
-   }
-
-   /* Set the new format for the input port */
-   status = mmal_format_full_copy(connection->in->format, connection->out->format);
-   if (status == MMAL_SUCCESS)
-      status = mmal_port_format_commit(connection->in);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("commit failed on port %s(%p) (%i)",
-                connection->in->name, connection->in, status);
-      return status;
-   }
-
-   /* Enable ports */
-   status = mmal_connection_enable(connection);
-   if (status)
-   {
-      LOG_ERROR("connection couldn't be enabled");
-      return status;
-   }
-
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_connection_event_format_changed(MMAL_CONNECTION_T *connection,
-   MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_EVENT_FORMAT_CHANGED_T *event;
-   MMAL_STATUS_T status;
-
-   LOG_TRACE("%p, %s", connection, connection->name);
-
-   if (buffer->cmd != MMAL_EVENT_FORMAT_CHANGED)
-      return MMAL_EINVAL;
-
-   event = mmal_event_format_changed_get(buffer);
-   if (!event)
-      return MMAL_EINVAL;
-
-   /* If we don't need to recreate our buffers then we can just forward the event
-    * to the next component (so it gets configured properly) */
-   if ((connection->in->capabilities & MMAL_PORT_CAPABILITY_SUPPORTS_EVENT_FORMAT_CHANGE) &&
-       event->buffer_size_min <= connection->out->buffer_size &&
-       event->buffer_num_min <= connection->out->buffer_num_min)
-   {
-      status = mmal_format_full_copy(connection->out->format, event->format);
-      if (status == MMAL_SUCCESS)
-         status = mmal_port_format_commit(connection->out);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("format commit failed on port %s(%p) (%i)",
-                   connection->out->name, connection->out, status);
-         return status;
-      }
-
-      mmal_buffer_header_acquire(buffer);
-      status = mmal_port_send_buffer(connection->in, buffer);
-      if (status != MMAL_SUCCESS)
-      {
-         LOG_ERROR("buffer send failed on port %s(%p) (%i)",
-                   connection->in->name, connection->in, status);
-         mmal_buffer_header_release(buffer);
-         return status;
-      }
-
-      return MMAL_SUCCESS;
-   }
-
-   /* Otherwise we have to reconfigure our pipeline */
-   return mmal_connection_reconfigure(connection, event->format);
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.h
deleted file mode 100644
index 6aa70b6..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_connection.h
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_CONNECTION_H
-#define MMAL_CONNECTION_H
-
-/** \defgroup MmalConnectionUtility Port connection utility
- * \ingroup MmalUtilities
- * The port connection utility functions can be used in place of common sequences
- * of calls to the MMAL API in order to process buffers being passed between two
- * ports.
- *
- * \section ProcessingConnectionBufferHeaders Processing connection buffer headers
- * Either in response to the client callback function being called, or simply on a
- * timer, the client will need to process the buffer headers of the connection
- * (unless tunneling is used).
- *
- * Buffer headers that are in the pool queue will need to be sent to the output port,
- * while buffer headers in the connection queue are sent to the input port. The
- * buffer headers in the connection queue may contain pixel data (the cmd field is
- * zero) or an event (the cmd field is non-zero). In general, pixel data buffer
- * headers need to be passed on, while event buffer headers are released. In the
- * case of the format changed event, mmal_connection_event_format_changed() can be
- * called before the event is released.
- *
- * Other, specialized use cases may also be implemented, such as getting and
- * immediately releasing buffer headers from the connection queue in order to
- * prevent their propagation. This could be used to drop out video, for example.
- *
- * \section TunnellingConnections Tunnelling connections
- * If the \ref MMAL_CONNECTION_FLAG_TUNNELLING flag is set when the connection is
- * created, MMAL tunneling will be used. This automates the passing of the buffer
- * headers between the output port and input port, and back again. It will also do
- * this as efficiently as possible, avoiding trips between the ARM and the VideoCore
- * if both components are implemented on the VideoCore. The consequence of this is
- * that there is no client callback made as buffer headers get transferred.
- *
- * The client can still monitor the control port of a component (usually a sink
- * component, such as video_render) for the end of stream, in order to know when to
- * dismantle the connection.
- *
- * \section ConnectionClientCallback Client callback
- * When not using tunnelling, the client callback function is called each time a
- * buffer arrives from a port (either input or output).
- *
- * \note The callback is made on a different thread from the one used by the
- * client to set up the connection, so care must be taken with thread safety.
- * One option is to raise a signal to the main client thread that queue processing
- * needs to be done, another is for the callback to perform the queue processing
- * itself.
- *
- * The client can also store an opaque pointer in the connection object, which is
- * never used by the MMAL code and is only meaningful to the client.
- *
- * @{
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \name Connection flags
- * \anchor connectionflags
- * The following flags describe the properties of the connection. */
-/* @{ */
-/** The connection is tunnelled. Buffer headers do not transit via the client but
- * directly from the output port to the input port. */
-#define MMAL_CONNECTION_FLAG_TUNNELLING 0x1
-/** Force the pool of buffer headers used by the connection to be allocated on the input port. */
-#define MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT 0x2
-/** Force the pool of buffer headers used by the connection to be allocated on the output port. */
-#define MMAL_CONNECTION_FLAG_ALLOCATION_ON_OUTPUT 0x4
-/* @} */
-
-/** Forward type definition for a connection */
-typedef struct MMAL_CONNECTION_T MMAL_CONNECTION_T;
-
-/** Definition of the callback used by a connection to signal back to the client
- * that a buffer header is available either in the pool or in the output queue.
- *
- * @param connection Pointer to the connection
- */
-typedef void (*MMAL_CONNECTION_CALLBACK_T)(MMAL_CONNECTION_T *connection);
-
-/** Structure describing a connection between 2 ports (1 output and 1 input port) */
-struct MMAL_CONNECTION_T {
-
-   void *user_data;           /**< Field reserved for use by the client. */
-   MMAL_CONNECTION_CALLBACK_T callback; /**< Callback set by the client. */
-
-   uint32_t is_enabled;       /**< Specifies whether the connection is enabled or not (Read Only). */
-
-   uint32_t flags;            /**< Flags passed during the create call (Read Only). A bitwise
-                               * combination of \ref connectionflags "Connection flags" values.
-                               */
-   MMAL_PORT_T *in;           /**< Input port used for the connection (Read Only). */
-   MMAL_PORT_T *out;          /**< Output port used for the connection (Read Only). */
-
-   MMAL_POOL_T *pool;         /**< Pool of buffer headers used by the output port (Read Only). */
-   MMAL_QUEUE_T *queue;       /**< Queue for the buffer headers produced by the output port (Read Only). */
-
-   const char *name;          /**< Connection name (Read Only). Used for debugging purposes. */
-
-   /* Used for debug / statistics */
-   int64_t time_setup;        /**< Time in microseconds taken to setup the connection. */
-   int64_t time_enable;       /**< Time in microseconds taken to enable the connection. */
-   int64_t time_disable;      /**< Time in microseconds taken to disable the connection. */
-};
-
-/** Create a connection between two ports.
- * The connection shall include a pool of buffer headers suitable for the current format of
- * the output port. The format of the input port shall have been set to the same as that of
- * the input port.
- * Note that connections are reference counted and creating a connection automatically
- * acquires a reference to it (released when \ref mmal_connection_destroy is called).
- *
- * @param connection The address of a connection pointer that will be set to point to the created
- * connection.
- * @param out        The output port to use for the connection.
- * @param in         The input port to use for the connection.
- * @param flags      The flags specifying which type of connection should be created.
- *    A bitwise combination of \ref connectionflags "Connection flags" values.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_connection_create(MMAL_CONNECTION_T **connection,
-   MMAL_PORT_T *out, MMAL_PORT_T *in, uint32_t flags);
-
-/** Acquire a reference on a connection.
- * Acquiring a reference on a connection will prevent a connection from being destroyed until
- * the acquired reference is released (by a call to \ref mmal_connection_destroy).
- * References are internally counted so all acquired references need a matching call to
- * release them.
- *
- * @param connection connection to acquire
- */
-void mmal_connection_acquire(MMAL_CONNECTION_T *connection);
-
-/** Release a reference on a connection
- * Release an acquired reference on a connection. Triggers the destruction of the connection when
- * the last reference is being released.
- * \note This is in fact an alias of \ref mmal_connection_destroy which is added to make client
- * code clearer.
- *
- * @param connection connection to release
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_connection_release(MMAL_CONNECTION_T *connection);
-
-/** Destroy a connection.
- * Release an acquired reference on a connection. Only actually destroys the connection when
- * the last reference is being released.
- * The actual destruction of the connection will start by disabling it, if necessary.
- * Any pool, queue, and so on owned by the connection shall then be destroyed.
- *
- * @param connection The connection to be destroyed.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_connection_destroy(MMAL_CONNECTION_T *connection);
-
-/** Enable a connection.
- * The format of the two ports must have been committed before calling this function,
- * although note that on creation, the connection automatically copies and commits the
- * output port's format to the input port.
- *
- * The MMAL_CONNECTION_T::callback field must have been set if the \ref MMAL_CONNECTION_FLAG_TUNNELLING
- * flag was not specified on creation. The client may also set the MMAL_CONNECTION_T::user_data
- * in order to get a pointer passed, via the connection, to the callback.
- *
- * @param connection The connection to be enabled.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_connection_enable(MMAL_CONNECTION_T *connection);
-
-/** Disable a connection.
- *
- * @param connection The connection to be disabled.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_connection_disable(MMAL_CONNECTION_T *connection);
-
-/** Apply a format changed event to the connection.
- * This function can be used when the client is processing buffer headers and receives
- * a format changed event (\ref MMAL_EVENT_FORMAT_CHANGED). The connection is
- * reconfigured, changing the format of the ports, the number of buffer headers and
- * the size of the payload buffers as necessary.
- *
- * @param connection The connection to which the event shall be applied.
- * @param buffer The buffer containing a format changed event.
- * @return MMAL_SUCCESS on success.
- */
-MMAL_STATUS_T mmal_connection_event_format_changed(MMAL_CONNECTION_T *connection,
-   MMAL_BUFFER_HEADER_T *buffer);
-
-#ifdef __cplusplus
-}
-#endif
-
-/** @} */
-
-#endif /* MMAL_CONNECTION_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_default_components.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_default_components.h
deleted file mode 100644
index 00a31f6..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_default_components.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_DEFAULT_COMPONENTS_H
-#define MMAL_DEFAULT_COMPONENTS_H
-
-/** \defgroup MmalDefaultComponents List of default components
- * This provides a list of default components on a per platform basis.
- * @{
- */
-
-#define MMAL_COMPONENT_DEFAULT_CONTAINER_READER "container_reader"
-#define MMAL_COMPONENT_DEFAULT_CONTAINER_WRITER "container_writer"
-
-#if defined(ENABLE_MMAL_STANDALONE)
-# define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "avcodec.video_decode"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "avcodec.video_encode"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER   "sdl.video_render"
-# define MMAL_COMPONENT_DEFAULT_IMAGE_DECODER    "avcodec.video_decode"
-# define MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER    "avcodec.video_encode"
-# define MMAL_COMPONENT_DEFAULT_CAMERA           "artificial_camera"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER  "avcodec.video_convert"
-# define MMAL_COMPONENT_DEFAULT_SPLITTER         "splitter"
-# define MMAL_COMPONENT_DEFAULT_SCHEDULER        "scheduler"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER   "video_inject"
-# define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "avcodec.audio_decode"
-# define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "sdl.audio_render"
-# define MMAL_COMPONENT_DEFAULT_MIRACAST         "miracast"
-#elif defined(__VIDEOCORE__)
-# define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "ril.video_decode"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "ril.video_encode"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER   "ril.video_render"
-# define MMAL_COMPONENT_DEFAULT_IMAGE_DECODER    "ril.image_decode"
-# define MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER    "ril.image_encode"
-# define MMAL_COMPONENT_DEFAULT_CAMERA           "ril.camera"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER  "video_convert"
-# define MMAL_COMPONENT_DEFAULT_SPLITTER         "splitter"
-# define MMAL_COMPONENT_DEFAULT_SCHEDULER        "scheduler"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER   "video_inject"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_SPLITTER   "ril.video_splitter"
-# define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "none"
-# define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "ril.audio_render"
-# define MMAL_COMPONENT_DEFAULT_MIRACAST         "miracast"
-#else
-# define MMAL_COMPONENT_DEFAULT_VIDEO_DECODER    "vc.ril.video_decode"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER    "vc.ril.video_encode"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER   "vc.ril.video_render"
-# define MMAL_COMPONENT_DEFAULT_IMAGE_DECODER    "vc.ril.image_decode"
-# define MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER    "vc.ril.image_encode"
-# define MMAL_COMPONENT_DEFAULT_CAMERA           "vc.ril.camera"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER  "vc.video_convert"
-# define MMAL_COMPONENT_DEFAULT_SPLITTER         "vc.splitter"
-# define MMAL_COMPONENT_DEFAULT_SCHEDULER        "vc.scheduler"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER   "vc.video_inject"
-# define MMAL_COMPONENT_DEFAULT_VIDEO_SPLITTER   "vc.ril.video_splitter"
-# define MMAL_COMPONENT_DEFAULT_AUDIO_DECODER    "none"
-# define MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER   "vc.ril.audio_render"
-# define MMAL_COMPONENT_DEFAULT_MIRACAST         "vc.miracast"
-#endif
-
-/** @} */
-
-#endif /* MMAL_DEFAULT_COMPONENTS_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.c
deleted file mode 100644
index cb72375..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.c
+++ /dev/null
@@ -1,1318 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "util/mmal_util.h"
-#include "util/mmal_graph.h"
-#include "core/mmal_component_private.h"
-#include "core/mmal_port_private.h"
-#include "mmal_logging.h"
-
-#define GRAPH_CONNECTIONS_MAX 16
-
-/*****************************************************************************/
-
-/** Private context for our graph.
- * This also acts as a MMAL_COMPONENT_MODULE_T for when components are instantiated from graphs */
-typedef struct MMAL_COMPONENT_MODULE_T
-{
-   MMAL_GRAPH_T graph; /**< Must be the first member! */
-
-   MMAL_COMPONENT_T *component[GRAPH_CONNECTIONS_MAX];
-   unsigned int component_num;
-
-   MMAL_CONNECTION_T *connection[GRAPH_CONNECTIONS_MAX];
-   unsigned int connection_num;
-
-   MMAL_PORT_T *input[GRAPH_CONNECTIONS_MAX];
-   unsigned int input_num;
-   MMAL_PORT_T *output[GRAPH_CONNECTIONS_MAX];
-   unsigned int output_num;
-
-   MMAL_COMPONENT_T *graph_component;
-
-   MMAL_BOOL_T stop_thread;      /**< informs the worker thread to exit */
-   VCOS_THREAD_T thread;         /**< worker thread which processes all internal connections */
-   VCOS_SEMAPHORE_T sema;        /**< informs the worker thread that buffers are available */
-
-   MMAL_GRAPH_EVENT_CB event_cb; /**< callback for sending control port events to the client */
-   void *event_cb_data;          /**< callback data supplied by the client */
-
-} MMAL_GRAPH_PRIVATE_T;
-
-typedef MMAL_GRAPH_PRIVATE_T MMAL_COMPONENT_MODULE_T;
-
-/*****************************************************************************/
-static MMAL_STATUS_T mmal_component_create_from_graph(const char *name, MMAL_COMPONENT_T *component);
-static MMAL_BOOL_T graph_do_processing(MMAL_GRAPH_PRIVATE_T *graph);
-
-/*****************************************************************************/
-static void graph_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_GRAPH_PRIVATE_T *graph = (MMAL_GRAPH_PRIVATE_T *)port->userdata;
-
-   LOG_TRACE("port: %s(%p), buffer: %p, event: %4.4s", port->name, port,
-             buffer, (char *)&buffer->cmd);
-
-   if (graph->event_cb)
-   {
-      graph->event_cb((MMAL_GRAPH_T *)graph, port, buffer, graph->event_cb_data);
-   }
-   else
-   {
-      LOG_ERROR("event lost on port %i,%i (event callback not defined)",
-                (int)port->type, (int)port->index);
-      mmal_buffer_header_release(buffer);
-   }
-}
-
-/*****************************************************************************/
-static void graph_connection_cb(MMAL_CONNECTION_T *connection)
-{
-   MMAL_GRAPH_PRIVATE_T *graph = (MMAL_GRAPH_PRIVATE_T *)connection->user_data;
-   vcos_semaphore_post(&graph->sema);
-}
-
-/*****************************************************************************/
-static void* graph_worker_thread(void* ctx)
-{
-   MMAL_GRAPH_PRIVATE_T *graph = (MMAL_GRAPH_PRIVATE_T *)ctx;
-
-   while (1)
-   {
-      vcos_semaphore_wait(&graph->sema);
-      if (graph->stop_thread)
-         break;
-      while(graph_do_processing(graph));
-   }
-
-   LOG_TRACE("worker thread exit %p", graph);
-
-   return 0;
-}
-
-/*****************************************************************************/
-static void graph_stop_worker_thread(MMAL_GRAPH_PRIVATE_T *graph)
-{
-   graph->stop_thread = MMAL_TRUE;
-   vcos_semaphore_post(&graph->sema);
-   vcos_thread_join(&graph->thread, NULL);
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_create(MMAL_GRAPH_T **graph, unsigned int userdata_size)
-{
-   MMAL_GRAPH_PRIVATE_T *private;
-
-   LOG_TRACE("graph %p, userdata_size %u", graph, userdata_size);
-
-   /* Sanity checking */
-   if (!graph)
-      return MMAL_EINVAL;
-
-   private = vcos_calloc(1, sizeof(MMAL_GRAPH_PRIVATE_T) + userdata_size, "mmal connection graph");
-   if (!private)
-      return MMAL_ENOMEM;
-   *graph = &private->graph;
-   if (userdata_size)
-      (*graph)->userdata = (struct MMAL_GRAPH_USERDATA_T *)&private[1];
-
-   if (vcos_semaphore_create(&private->sema, "mmal graph sema", 0) != VCOS_SUCCESS)
-   {
-      LOG_ERROR("failed to create semaphore %p", graph);
-      vcos_free(private);
-      return MMAL_ENOSPC;
-   }
-
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_destroy(MMAL_GRAPH_T *graph)
-{
-   unsigned i;
-   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
-
-   if (!graph)
-      return MMAL_EINVAL;
-
-   LOG_TRACE("%p", graph);
-
-   /* Notify client of destruction */
-   if (graph->pf_destroy)
-      graph->pf_destroy(graph);
-
-   for (i = 0; i < private->connection_num; i++)
-      mmal_connection_release(private->connection[i]);
-
-   for (i = 0; i < private->component_num; i++)
-      mmal_component_release(private->component[i]);
-
-   vcos_semaphore_delete(&private->sema);
-
-   vcos_free(graph);
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_add_component(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *component)
-{
-   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
-
-   LOG_TRACE("graph: %p, component: %s(%p)", graph, component ? component->name: 0, component);
-
-   if (!component)
-      return MMAL_EINVAL;
-
-   if (private->component_num >= GRAPH_CONNECTIONS_MAX)
-   {
-      LOG_ERROR("no space for component %s", component->name);
-      return MMAL_ENOSPC;
-   }
-
-   mmal_component_acquire(component);
-   private->component[private->component_num++] = component;
-
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_add_connection(MMAL_GRAPH_T *graph, MMAL_CONNECTION_T *cx)
-{
-   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
-
-   LOG_TRACE("graph: %p, connection: %s(%p)", graph, cx ? cx->name: 0, cx);
-
-   if (!cx)
-      return MMAL_EINVAL;
-
-   if (private->connection_num >= GRAPH_CONNECTIONS_MAX)
-   {
-      LOG_ERROR("no space for connection %s", cx->name);
-      return MMAL_ENOSPC;
-   }
-
-   mmal_connection_acquire(cx);
-   private->connection[private->connection_num++] = cx;
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_add_port(MMAL_GRAPH_T *graph, MMAL_PORT_T *port)
-{
-   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
-   MMAL_PORT_T **list;
-   unsigned int *list_num;
-
-   LOG_TRACE("graph: %p, port: %s(%p)", graph, port ? port->name: 0, port);
-
-   if (!port || (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT))
-      return MMAL_EINVAL;
-
-   list = port->type == MMAL_PORT_TYPE_INPUT ? private->input : private->output;
-   list_num = port->type == MMAL_PORT_TYPE_INPUT ? &private->input_num : &private->output_num;
-   if (*list_num >= GRAPH_CONNECTIONS_MAX)
-   {
-      LOG_ERROR("no space for port %s", port->name);
-      return MMAL_ENOSPC;
-   }
-
-   list[(*list_num)++] = port;
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_new_component(MMAL_GRAPH_T *graph, const char *name,
-   MMAL_COMPONENT_T **component)
-{
-   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
-   MMAL_COMPONENT_T *comp;
-   MMAL_STATUS_T status;
-
-   LOG_TRACE("graph: %p, name: %s, component: %p", graph, name, component);
-
-   if (private->component_num >= GRAPH_CONNECTIONS_MAX)
-   {
-      LOG_ERROR("no space for component %s", name);
-      return MMAL_ENOSPC;
-   }
-
-   status = mmal_component_create(name, &comp);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("could not create component %s (%i)", name, status);
-      return status;
-   }
-
-   private->component[private->component_num++] = comp;
-   if (component)
-   {
-      mmal_component_acquire(comp);
-      *component = comp;
-   }
-
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_new_connection(MMAL_GRAPH_T *graph, MMAL_PORT_T *out, MMAL_PORT_T *in,
-   uint32_t flags, MMAL_CONNECTION_T **connection)
-{
-   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
-   MMAL_CONNECTION_T *cx;
-   MMAL_STATUS_T status;
-
-   if (!out || !in ||
-       out->type != MMAL_PORT_TYPE_OUTPUT || in->type != MMAL_PORT_TYPE_INPUT)
-      return MMAL_EINVAL;
-
-   LOG_TRACE("graph: %p, out: %s(%p), in: %s(%p), flags %x, connection: %p",
-             graph, out->name, out, in->name, in, (int)flags, connection);
-
-   if (private->connection_num >= GRAPH_CONNECTIONS_MAX)
-   {
-      LOG_ERROR("no space for connection %s/%s", out->name, in->name);
-      return MMAL_ENOSPC;
-   }
-
-   status = mmal_connection_create(&cx, out, in, flags);
-   if (status != MMAL_SUCCESS)
-      return status;
-
-   private->connection[private->connection_num++] = cx;
-   if (connection)
-   {
-      mmal_connection_acquire(cx);
-      *connection = cx;
-   }
-
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_enable(MMAL_GRAPH_T *graph, MMAL_GRAPH_EVENT_CB cb, void *cb_data)
-{
-   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   unsigned int i;
-
-   LOG_TRACE("graph: %p", graph);
-
-   if (vcos_thread_create(&private->thread, "mmal graph thread", NULL,
-                          graph_worker_thread, private) != VCOS_SUCCESS)
-   {
-      LOG_ERROR("failed to create worker thread %p", graph);
-      return MMAL_ENOSPC;
-   }
-
-   private->event_cb = cb;
-   private->event_cb_data = cb_data;
-
-   /* Enable all control ports */
-   for (i = 0; i < private->component_num; i++)
-   {
-      private->component[i]->control->userdata = (void *)private;
-      status = mmal_port_enable(private->component[i]->control, graph_control_cb);
-      if (status != MMAL_SUCCESS)
-         LOG_ERROR("could not enable port %s", private->component[i]->control->name);
-   }
-
-   /* Enable all our connections */
-   for (i = 0; i < private->connection_num; i++)
-   {
-      MMAL_CONNECTION_T *cx = private->connection[i];
-
-      cx->callback = graph_connection_cb;
-      cx->user_data = private;
-
-      status = mmal_connection_enable(cx);
-      if (status != MMAL_SUCCESS)
-         goto error;
-   }
-
-   /* Trigger the worker thread to populate the output ports with empty buffers */
-   vcos_semaphore_post(&private->sema);
-   return status;
-
- error:
-   graph_stop_worker_thread(private);
-   return status;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_disable(MMAL_GRAPH_T *graph)
-{
-   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   unsigned int i;
-
-   LOG_TRACE("graph: %p", graph);
-
-   graph_stop_worker_thread(private);
-
-   /* Disable all our connections */
-   for (i = 0; i < private->connection_num; i++)
-   {
-      status = mmal_connection_disable(private->connection[i]);
-      if (status != MMAL_SUCCESS)
-         break;
-   }
-
-   return status;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_build(MMAL_GRAPH_T *graph,
-   const char *name, MMAL_COMPONENT_T **component)
-{
-   LOG_TRACE("graph: %p, name: %s, component: %p", graph, name, component);
-   return mmal_component_create_with_constructor(name, mmal_component_create_from_graph,
-      (MMAL_GRAPH_PRIVATE_T *)graph, component);
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_graph_component_constructor(const char *name,
-   MMAL_COMPONENT_T *component)
-{
-   LOG_TRACE("name: %s, component: %p", name, component);
-   return mmal_component_create_from_graph(name, component);
-}
-
-/*****************************************************************************/
-static void graph_component_control_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_COMPONENT_T *graph_component = (MMAL_COMPONENT_T *)port->userdata;
-   LOG_TRACE("%s(%p),%p,%4.4s", port->name, port, buffer, (char *)&buffer->cmd);
-
-   /* Forward the event on the graph control port */
-   mmal_port_event_send(graph_component->control, buffer);
-}
-
-/*****************************************************************************/
-static void graph_component_connection_cb(MMAL_CONNECTION_T *connection)
-{
-   MMAL_COMPONENT_T *component = (MMAL_COMPONENT_T *)connection->user_data;
-   mmal_component_action_trigger(component);
-}
-
-/*****************************************************************************/
-static void graph_port_event_handler(MMAL_CONNECTION_T *connection,
-   MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_STATUS_T status;
-
-   LOG_TRACE("port: %s(%p), buffer: %p, event: %4.4s", port->name, port,
-             buffer, (char *)&buffer->cmd);
-
-   if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED && port->type == MMAL_PORT_TYPE_OUTPUT)
-   {
-      MMAL_EVENT_FORMAT_CHANGED_T *event = mmal_event_format_changed_get(buffer);
-      if (event)
-      {
-         LOG_DEBUG("----------Port format changed----------");
-         mmal_log_dump_port(port);
-         LOG_DEBUG("-----------------to---------------------");
-         mmal_log_dump_format(event->format);
-         LOG_DEBUG(" buffers num (opt %i, min %i), size (opt %i, min: %i)",
-                   event->buffer_num_recommended, event->buffer_num_min,
-                   event->buffer_size_recommended, event->buffer_size_min);
-         LOG_DEBUG("----------------------------------------");
-      }
-
-      status = mmal_connection_event_format_changed(connection, buffer);
-   }
-
-   else
-      status = MMAL_SUCCESS; /* FIXME: ignore any other event for now */
-
-   mmal_buffer_header_release(buffer);
-
-   if (status != MMAL_SUCCESS)
-      mmal_event_error_send(port->component, status);
-}
-
-/*****************************************************************************/
-static MMAL_BOOL_T graph_do_processing(MMAL_GRAPH_PRIVATE_T *graph)
-{
-   MMAL_BUFFER_HEADER_T *buffer;
-   MMAL_BOOL_T run_again = 0;
-   MMAL_STATUS_T status;
-   unsigned int i;
-
-   /* Loop through all the connections */
-   for (i = 0; i < graph->connection_num; i++)
-   {
-      MMAL_CONNECTION_T *connection = graph->connection[i];
-
-      if (connection->flags & MMAL_CONNECTION_FLAG_TUNNELLING)
-         continue; /* Nothing else to do in tunnelling mode */
-
-      /* Send any queued buffer to the next component */
-      buffer = mmal_queue_get(connection->queue);
-      while (buffer)
-      {
-         run_again = 1;
-
-         if (buffer->cmd)
-         {
-            graph_port_event_handler(connection, connection->out, buffer);
-            buffer = mmal_queue_get(connection->queue);
-            continue;
-         }
-
-         status = mmal_port_send_buffer(connection->in, buffer);
-         if (status != MMAL_SUCCESS)
-         {
-            LOG_ERROR("%s(%p) could not send buffer to %s(%p) (%s)",
-                      connection->out->name, connection->out,
-                      connection->in->name, connection->in,
-                      mmal_status_to_string(status));
-            mmal_buffer_header_release(buffer);
-            mmal_event_error_send(connection->out->component, status);
-         }
-         buffer = mmal_queue_get(connection->queue);
-      }
-
-      /* Send empty buffers to the output port of the connection */
-      buffer = connection->pool ? mmal_queue_get(connection->pool->queue) : NULL;
-      while (buffer)
-      {
-         run_again = 1;
-
-         status = mmal_port_send_buffer(connection->out, buffer);
-         if (status != MMAL_SUCCESS)
-         {
-            LOG_ERROR("mmal_port_send_buffer failed (%i)", status);
-            mmal_queue_put_back(connection->pool->queue, buffer);
-            run_again = 0;
-            // FIXME: send error ?
-            break;
-         }
-         buffer = mmal_queue_get(connection->pool->queue);
-      }
-   }
-
-   return run_again;
-}
-
-/*****************************************************************************/
-static void graph_do_processing_loop(MMAL_COMPONENT_T *component)
-{
-   while (graph_do_processing((MMAL_GRAPH_PRIVATE_T *)component->priv->module));
-}
-
-/*****************************************************************************/
-static MMAL_PORT_T *find_port_from_graph(MMAL_GRAPH_PRIVATE_T *graph, MMAL_PORT_T *port)
-{
-   MMAL_PORT_T **list;
-   unsigned int *list_num;
-
-   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
-      return 0;
-
-   list = port->type == MMAL_PORT_TYPE_INPUT ? graph->input : graph->output;
-   list_num = port->type == MMAL_PORT_TYPE_INPUT ? &graph->input_num : &graph->output_num;
-   if (port->index > *list_num)
-      return 0;
-
-   return list[port->index];
-}
-
-static MMAL_PORT_T *find_port_to_graph(MMAL_GRAPH_PRIVATE_T *graph, MMAL_PORT_T *port)
-{
-   MMAL_COMPONENT_T *component = graph->graph_component;
-   MMAL_PORT_T **list;
-   unsigned int i, *list_num;
-
-   if (port->type != MMAL_PORT_TYPE_INPUT && port->type != MMAL_PORT_TYPE_OUTPUT)
-      return 0;
-
-   list = port->type == MMAL_PORT_TYPE_INPUT ? graph->input : graph->output;
-   list_num = port->type == MMAL_PORT_TYPE_INPUT ? &graph->input_num : &graph->output_num;
-
-   for (i = 0; i < *list_num; i++)
-      if (list[i] == port)
-         break;
-
-   if (i == *list_num)
-      return 0;
-   return port->type == MMAL_PORT_TYPE_INPUT ? component->input[i] : component->output[i];
-}
-
-static MMAL_STATUS_T graph_port_update(MMAL_GRAPH_PRIVATE_T *graph,
-   MMAL_PORT_T *graph_port, MMAL_BOOL_T init)
-{
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *port;
-
-   port = find_port_from_graph(graph, graph_port);
-   if (!port)
-   {
-      LOG_ERROR("could not find matching port for %p", graph_port);
-      return MMAL_EINVAL;
-   }
-
-   status = mmal_format_full_copy(graph_port->format, port->format);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("format copy failed on port %s", port->name);
-      return status;
-   }
-
-   graph_port->buffer_num_min = port->buffer_num_min;
-   graph_port->buffer_num_recommended = port->buffer_num_recommended;
-   graph_port->buffer_size_min = port->buffer_size_min;
-   graph_port->buffer_size_recommended = port->buffer_size_recommended;
-   graph_port->buffer_alignment_min = port->buffer_alignment_min;
-   graph_port->capabilities = port->capabilities;
-   if (init)
-   {
-      graph_port->buffer_num = port->buffer_num;
-      graph_port->buffer_size = port->buffer_size;
-   }
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T graph_port_update_requirements(MMAL_GRAPH_PRIVATE_T *graph,
-   MMAL_PORT_T *graph_port)
-{
-   MMAL_PORT_T *port;
-
-   port = find_port_from_graph(graph, graph_port);
-   if (!port)
-   {
-      LOG_ERROR("could not find matching port for %p", graph_port);
-      return MMAL_EINVAL;
-   }
-
-   graph_port->buffer_num_min = port->buffer_num_min;
-   graph_port->buffer_num_recommended = port->buffer_num_recommended;
-   graph_port->buffer_size_min = port->buffer_size_min;
-   graph_port->buffer_size_recommended = port->buffer_size_recommended;
-   graph_port->buffer_alignment_min = port->buffer_alignment_min;
-   return MMAL_SUCCESS;
-}
-
-/** Destroy a previously created component */
-static MMAL_STATUS_T graph_component_destroy(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_MODULE_T *graph = component->priv->module;
-
-   /* Notify client of destruction */
-   if (graph->graph.pf_destroy)
-      graph->graph.pf_destroy(&graph->graph);
-   graph->graph.pf_destroy = NULL;
-
-   if (component->input_num)
-      mmal_ports_free(component->input, component->input_num);
-
-   if (component->output_num)
-      mmal_ports_free(component->output, component->output_num);
-
-   /* coverity[address_free] Freeing the first item in the structure is safe */
-   mmal_graph_destroy(&graph->graph);
-   return MMAL_SUCCESS;
-}
-
-/** Enable processing on a component */
-static MMAL_STATUS_T graph_component_enable(MMAL_COMPONENT_T *component)
-{
-   MMAL_PARAM_UNUSED(component);
-   return MMAL_SUCCESS;
-}
-
-/** Disable processing on a component */
-static MMAL_STATUS_T graph_component_disable(MMAL_COMPONENT_T *component)
-{
-   MMAL_PARAM_UNUSED(component);
-   return MMAL_SUCCESS;
-}
-
-/** Callback given to mmal_port_enable() */
-static void graph_port_enable_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = (MMAL_GRAPH_PRIVATE_T *)port->userdata;
-   MMAL_PORT_T *graph_port;
-   MMAL_STATUS_T status;
-
-   graph_port = find_port_to_graph(graph_private, port);
-   if (!graph_port)
-   {
-      vcos_assert(0);
-      mmal_buffer_header_release(buffer);
-      return;
-   }
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_return_buffer)
-   {
-      status = graph_private->graph.pf_return_buffer(&graph_private->graph, graph_port, buffer);
-      if (status != MMAL_ENOSYS)
-         return;
-   }
-
-   /* Forward the callback */
-   if (buffer->cmd)
-      mmal_port_event_send(graph_port, buffer);
-   else
-      mmal_port_buffer_header_callback(graph_port, buffer);
-}
-
-/** Propagate a port enable */
-static MMAL_STATUS_T graph_port_state_propagate(MMAL_GRAPH_PRIVATE_T *graph,
-   MMAL_PORT_T *port, MMAL_BOOL_T enable)
-{
-   MMAL_COMPONENT_T *component = port->component;
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   MMAL_PORT_TYPE_T type = port->type;
-   unsigned int i, j;
-
-   LOG_TRACE("graph: %p, port %s(%p)", graph, port->name, port);
-
-   if (port->type == MMAL_PORT_TYPE_OUTPUT)
-      type = MMAL_PORT_TYPE_INPUT;
-   if (port->type == MMAL_PORT_TYPE_INPUT)
-      type = MMAL_PORT_TYPE_OUTPUT;
-
-   /* Loop through all the output ports of the component and if they are not enabled and
-    * match one of the connections we maintain, then we need to propagate the port enable. */
-   for (i = 0; i < component->port_num; i++)
-   {
-      if (component->port[i]->type != type)
-         continue;
-
-      if ((component->port[i]->is_enabled && enable) ||
-          (!component->port[i]->is_enabled && !enable))
-         continue;
-
-      /* Find the matching connection */
-      for (j = 0; j < graph->connection_num; j++)
-         if (graph->connection[j]->out == component->port[i] ||
-             graph->connection[j]->in == component->port[i])
-            break;
-
-      if (j == graph->connection_num)
-         continue; /* No match */
-
-      if (enable)
-      {
-         status = mmal_connection_enable(graph->connection[j]);
-         if (status != MMAL_SUCCESS)
-            break;
-
-         mmal_log_dump_port(graph->connection[j]->out);
-         mmal_log_dump_port(graph->connection[j]->in);
-      }
-
-      status = graph_port_state_propagate(graph, graph->connection[j]->in == component->port[i] ?
-         graph->connection[j]->out : graph->connection[j]->in, enable);
-      if (status != MMAL_SUCCESS)
-         break;
-
-      if (!enable)
-      {
-         status = mmal_connection_disable(graph->connection[j]);
-         if (status != MMAL_SUCCESS)
-            break;
-      }
-   }
-
-   return status;
-}
-
-/** Enable processing on a port */
-static MMAL_STATUS_T graph_port_enable(MMAL_PORT_T *graph_port, MMAL_PORT_BH_CB_T cb)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_PORT_T *port;
-   MMAL_STATUS_T status;
-   MMAL_PARAM_UNUSED(cb);
-
-   port = find_port_from_graph(graph_private, graph_port);
-   if (!port)
-      return MMAL_EINVAL;
-
-   /* Update the buffer requirements */
-   port->buffer_num = graph_port->buffer_num;
-   port->buffer_size = graph_port->buffer_size;
-
-   /* We'll intercept the callback */
-   port->userdata = (void *)graph_private;
-   status = mmal_port_enable(port, graph_port_enable_cb);
-   if (status != MMAL_SUCCESS)
-      return status;
-
-   /* We need to enable all the connected connections */
-   status = graph_port_state_propagate(graph_private, port, 1);
-
-   mmal_component_action_trigger(graph_port->component);
-   return status;
-}
-
-/** Disable processing on a port */
-static MMAL_STATUS_T graph_port_disable(MMAL_PORT_T *graph_port)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_PORT_T *port;
-
-   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
-   if (!port)
-      return MMAL_EINVAL;
-
-   /* We need to disable all the connected connections.
-    * Since disable does an implicit flush, we only want to do that if
-    * we're acting on an input port or we risk discarding buffers along
-    * the way. */
-   if (!graph_private->input_num || port->type == MMAL_PORT_TYPE_INPUT)
-   {
-      MMAL_STATUS_T status = graph_port_state_propagate(graph_private, port, 0);
-      if (status != MMAL_SUCCESS)
-         return status;
-   }
-
-   /* Forward the call */
-   return mmal_port_disable(port);
-}
-
-/** Propagate a port flush */
-static MMAL_STATUS_T graph_port_flush_propagate(MMAL_GRAPH_PRIVATE_T *graph,
-   MMAL_PORT_T *port)
-{
-   MMAL_COMPONENT_T *component = port->component;
-   MMAL_STATUS_T status;
-   unsigned int i, j;
-
-   LOG_TRACE("graph: %p, port %s(%p)", graph, port->name, port);
-
-   status = mmal_port_flush(port);
-   if (status != MMAL_SUCCESS)
-      return status;
-
-   if (port->type == MMAL_PORT_TYPE_OUTPUT)
-      return MMAL_SUCCESS;
-
-   /* Loop through all the output ports of the component and if they match one
-    * of the connections we maintain, then we need to propagate the flush. */
-   for (i = 0; i < component->port_num; i++)
-   {
-      if (component->port[i]->type != MMAL_PORT_TYPE_OUTPUT)
-         continue;
-      if (!component->port[i]->is_enabled)
-         continue;
-
-      /* Find the matching connection */
-      for (j = 0; j < graph->connection_num; j++)
-         if (graph->connection[j]->out == component->port[i])
-            break;
-
-      if (j == graph->connection_num)
-         continue; /* No match */
-
-      /* Flush any buffer waiting in the connection queue */
-      if (graph->connection[j]->queue)
-      {
-         MMAL_BUFFER_HEADER_T *buffer = mmal_queue_get(graph->connection[j]->queue);
-         while(buffer)
-         {
-            mmal_buffer_header_release(buffer);
-            buffer = mmal_queue_get(graph->connection[j]->queue);
-         }
-      }
-
-      status = graph_port_flush_propagate(graph, graph->connection[j]->in);
-      if (status != MMAL_SUCCESS)
-         break;
-   }
-
-   return status;
-}
-
-/** Flush a port */
-static MMAL_STATUS_T graph_port_flush(MMAL_PORT_T *graph_port)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *port;
-
-   port = find_port_from_graph(graph_private, graph_port);
-   if (!port)
-      return MMAL_EINVAL;
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_flush)
-   {
-      status = graph_private->graph.pf_flush(&graph_private->graph, graph_port);
-      if (status != MMAL_ENOSYS)
-         return status;
-   }
-
-   /* Forward the call */
-   return graph_port_flush_propagate(graph_private, port);
-}
-
-/** Send a buffer header to a port */
-static MMAL_STATUS_T graph_port_send(MMAL_PORT_T *graph_port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *port;
-
-   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
-   if (!port)
-      return MMAL_EINVAL;
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_send_buffer)
-   {
-      status = graph_private->graph.pf_send_buffer(&graph_private->graph, graph_port, buffer);
-      if (status != MMAL_ENOSYS)
-         return status;
-   }
-
-   /* Forward the call */
-   return mmal_port_send_buffer(port, buffer);
-}
-
-/** Propagate a format change */
-static MMAL_STATUS_T graph_port_format_commit_propagate(MMAL_GRAPH_PRIVATE_T *graph,
-   MMAL_PORT_T *port)
-{
-   MMAL_COMPONENT_T *component = port->component;
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   unsigned int i, j;
-
-   LOG_TRACE("graph: %p, port %s(%p)", graph, port->name, port);
-
-   if (port->type == MMAL_PORT_TYPE_OUTPUT)
-      return MMAL_SUCCESS; /* Nothing to do */
-
-   /* Loop through all the output ports of the component and if they are not enabled and
-    * match one of the connections we maintain, then we need to propagate the format change. */
-   for (i = 0; i < component->output_num; i++)
-   {
-      MMAL_PORT_T *in, *out;
-
-      if (component->output[i]->is_enabled)
-         continue;
-
-      /* Find the matching connection */
-      for (j = 0; j < graph->connection_num; j++)
-         if (graph->connection[j]->out == component->output[i])
-            break;
-
-      if (j == graph->connection_num)
-         continue; /* No match */
-
-      in = graph->connection[j]->in;
-      out = graph->connection[j]->out;
-
-      /* Apply the format to the input port */
-      status = mmal_format_full_copy(in->format, out->format);
-      if (status != MMAL_SUCCESS)
-         break;
-      status = mmal_port_format_commit(in);
-      if (status != MMAL_SUCCESS)
-         break;
-
-      mmal_log_dump_port(out);
-      mmal_log_dump_port(in);
-
-      status = graph_port_format_commit_propagate(graph, in);
-      if (status != MMAL_SUCCESS)
-         break;
-   }
-
-   return status;
-}
-
-/** Set format on a port */
-static MMAL_STATUS_T graph_port_format_commit(MMAL_PORT_T *graph_port)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *port;
-   unsigned int i;
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_format_commit)
-   {
-      status = graph_private->graph.pf_format_commit(&graph_private->graph, graph_port);
-      if (status == MMAL_SUCCESS)
-         goto end;
-      if (status != MMAL_ENOSYS)
-         return status;
-   }
-
-   port = find_port_from_graph(graph_private, graph_port);
-   if (!port)
-      return MMAL_EINVAL;
-
-   /* Update actual port */
-   status = mmal_format_full_copy(port->format, graph_port->format);
-   if (status != MMAL_SUCCESS)
-      return status;
-   port->buffer_num = graph_port->buffer_num;
-   port->buffer_size = graph_port->buffer_size;
-
-   /* Forward the call */
-   status = mmal_port_format_commit(port);
-   if (status != MMAL_SUCCESS)
-      return status;
-
-   /* Propagate format changes to the connections */
-   status = graph_port_format_commit_propagate(graph_private, port);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("couldn't propagate format commit of port %s(%p)", port->name, port);
-      return status;
-   }
-
- end:
-   /* Read the values back */
-   status = graph_port_update(graph_private, graph_port, MMAL_FALSE);
-   if (status != MMAL_SUCCESS)
-      return status;
-
-   /* Get the settings for the output ports in case they have changed */
-   if (graph_port->type == MMAL_PORT_TYPE_INPUT)
-   {
-      for (i = 0; i < graph_private->output_num; i++)
-      {
-         status = graph_port_update(graph_private, graph_port->component->output[i], MMAL_FALSE);
-         if (status != MMAL_SUCCESS)
-            return status;
-      }
-   }
-
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T graph_port_control_parameter_get(MMAL_PORT_T *graph_port,
-   MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_STATUS_T status = MMAL_ENOSYS;
-   unsigned int i;
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_parameter_get)
-   {
-      status = graph_private->graph.pf_parameter_get(&graph_private->graph, graph_port, param);
-      if (status != MMAL_ENOSYS)
-         return status;
-   }
-
-   /* By default we do a get parameter on each component until one succeeds */
-   for (i = 0; i < graph_private->component_num && status != MMAL_SUCCESS; i++)
-      status = mmal_port_parameter_get(graph_private->component[i]->control, param);
-
-   return status;
-}
-
-static MMAL_STATUS_T graph_port_parameter_get(MMAL_PORT_T *graph_port,
-   MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *port;
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_parameter_get)
-   {
-      status = graph_private->graph.pf_parameter_get(&graph_private->graph, graph_port, param);
-      if (status != MMAL_ENOSYS)
-         return status;
-   }
-
-   port = find_port_from_graph(graph_private, graph_port);
-   if (!port)
-      return MMAL_EINVAL;
-
-   /* Forward the call */
-   return mmal_port_parameter_get(port, param);
-}
-
-static MMAL_STATUS_T graph_port_control_parameter_set(MMAL_PORT_T *graph_port,
-   const MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_STATUS_T status = MMAL_ENOSYS;
-   unsigned int i;
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_parameter_set)
-   {
-      status = graph_private->graph.pf_parameter_set(&graph_private->graph, graph_port, param);
-      if (status != MMAL_ENOSYS)
-         return status;
-   }
-
-   /* By default we do a set parameter on each component until one succeeds */
-   for (i = 0; i < graph_private->component_num && status != MMAL_SUCCESS; i++)
-      status = mmal_port_parameter_set(graph_private->component[i]->control, param);
-
-   return status;
-}
-
-static MMAL_STATUS_T graph_port_parameter_set(MMAL_PORT_T *graph_port,
-   const MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *port;
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_parameter_set)
-   {
-      status = graph_private->graph.pf_parameter_set(&graph_private->graph, graph_port, param);
-      if (status != MMAL_ENOSYS)
-         return status;
-   }
-
-   port = find_port_from_graph(graph_private, graph_port);
-   if (!port)
-      return MMAL_EINVAL;
-
-   /* Forward the call */
-   status = mmal_port_parameter_set(port, param);
-   if (status != MMAL_SUCCESS)
-      goto end;
-
-   if (param->id == MMAL_PARAMETER_BUFFER_REQUIREMENTS)
-   {
-      /* This might have changed the buffer requirements of other ports so fetch them all */
-      MMAL_COMPONENT_T *component = graph_port->component;
-      unsigned int i;
-      for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
-         status = graph_port_update_requirements(graph_private, component->input[i]);
-      for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
-         status = graph_port_update_requirements(graph_private, component->output[i]);
-   }
-
- end:
-   return status;
-}
-
-static MMAL_STATUS_T graph_port_connect(MMAL_PORT_T *graph_port, MMAL_PORT_T *other_port)
-{
-   MMAL_PORT_T *port;
-
-   LOG_TRACE("%s(%p) %s(%p)", graph_port->name, graph_port, other_port->name, other_port);
-
-   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
-   if (!port)
-      return MMAL_EINVAL;
-
-   /* Forward the call */
-   return other_port ? mmal_port_connect(port, other_port) : mmal_port_disconnect(port);
-}
-
-static uint8_t *graph_port_payload_alloc(MMAL_PORT_T *graph_port, uint32_t payload_size)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *port;
-   uint8_t *payload;
-
-   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
-   if (!port)
-      return 0;
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_payload_alloc)
-   {
-      status = graph_private->graph.pf_payload_alloc(&graph_private->graph, graph_port,
-         payload_size, &payload);
-      if (status != MMAL_ENOSYS)
-         return status == MMAL_SUCCESS ? payload : NULL;
-   }
-
-   /* Forward the call */
-   return mmal_port_payload_alloc(port, payload_size);
-}
-
-static void graph_port_payload_free(MMAL_PORT_T *graph_port, uint8_t *payload)
-{
-   MMAL_GRAPH_PRIVATE_T *graph_private = graph_port->component->priv->module;
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *port;
-
-   port = find_port_from_graph(graph_port->component->priv->module, graph_port);
-   if (!port)
-      return;
-
-   /* Call user defined function first */
-   if (graph_private->graph.pf_payload_free)
-   {
-      status = graph_private->graph.pf_payload_free(&graph_private->graph, graph_port, payload);
-      if (status == MMAL_SUCCESS)
-         return;
-   }
-
-   /* Forward the call */
-   mmal_port_payload_free(port, payload);
-}
-
-/** Create an instance of a component  */
-static MMAL_STATUS_T mmal_component_create_from_graph(const char *name, MMAL_COMPONENT_T *component)
-{
-   MMAL_STATUS_T status = MMAL_ENOMEM;
-   /* Our context is already allocated and available */
-   MMAL_GRAPH_PRIVATE_T *graph = component->priv->module;
-   unsigned int i;
-   MMAL_PARAM_UNUSED(name);
-
-   component->control->priv->pf_parameter_get = graph_port_control_parameter_get;
-   component->control->priv->pf_parameter_set = graph_port_control_parameter_set;
-
-   /* Allocate the ports for this component */
-   if(graph->input_num)
-   {
-      component->input = mmal_ports_alloc(component, graph->input_num, MMAL_PORT_TYPE_INPUT, 0);
-      if(!component->input)
-         goto error;
-   }
-   component->input_num = graph->input_num;
-   for(i = 0; i < component->input_num; i++)
-   {
-      component->input[i]->priv->pf_enable = graph_port_enable;
-      component->input[i]->priv->pf_disable = graph_port_disable;
-      component->input[i]->priv->pf_flush = graph_port_flush;
-      component->input[i]->priv->pf_send = graph_port_send;
-      component->input[i]->priv->pf_set_format = graph_port_format_commit;
-      component->input[i]->priv->pf_parameter_get = graph_port_parameter_get;
-      component->input[i]->priv->pf_parameter_set = graph_port_parameter_set;
-      if (graph->input[i]->priv->pf_connect && 0 /* FIXME: disabled for now */)
-         component->input[i]->priv->pf_connect = graph_port_connect;
-      component->input[i]->priv->pf_payload_alloc = graph_port_payload_alloc;
-      component->input[i]->priv->pf_payload_free = graph_port_payload_free;
-
-      /* Mirror the port values */
-      status = graph_port_update(graph, component->input[i], MMAL_TRUE);
-      if (status != MMAL_SUCCESS)
-         goto error;
-   }
-   if(graph->output_num)
-   {
-      component->output = mmal_ports_alloc(component, graph->output_num, MMAL_PORT_TYPE_OUTPUT, 0);
-      if(!component->output)
-         goto error;
-   }
-   component->output_num = graph->output_num;
-   for(i = 0; i < component->output_num; i++)
-   {
-      component->output[i]->priv->pf_enable = graph_port_enable;
-      component->output[i]->priv->pf_disable = graph_port_disable;
-      component->output[i]->priv->pf_flush = graph_port_flush;
-      component->output[i]->priv->pf_send = graph_port_send;
-      component->output[i]->priv->pf_set_format = graph_port_format_commit;
-      component->output[i]->priv->pf_parameter_get = graph_port_parameter_get;
-      component->output[i]->priv->pf_parameter_set = graph_port_parameter_set;
-      if (graph->output[i]->priv->pf_connect && 0 /* FIXME: disabled for now */)
-         component->output[i]->priv->pf_connect = graph_port_connect;
-      component->output[i]->priv->pf_payload_alloc = graph_port_payload_alloc;
-      component->output[i]->priv->pf_payload_free = graph_port_payload_free;
-
-      /* Mirror the port values */
-      status = graph_port_update(graph, component->output[i], MMAL_TRUE);
-      if (status != MMAL_SUCCESS)
-         goto error;
-   }
-
-   status = mmal_component_action_register(component, graph_do_processing_loop);
-   if (status != MMAL_SUCCESS)
-      goto error;
-
-#if 1 // FIXME
-   /* Set our connection callback */
-   for (i = 0; i < graph->connection_num; i++)
-   {
-      graph->connection[i]->callback = graph_component_connection_cb;
-      graph->connection[i]->user_data = (void *)component;
-   }
-#endif
-
-   component->priv->pf_destroy = graph_component_destroy;
-   component->priv->pf_enable = graph_component_enable;
-   component->priv->pf_disable = graph_component_disable;
-   graph->graph_component = component;
-
-   /* Enable all the control ports */
-   for (i = 0; i < graph->component_num; i++)
-   {
-      graph->component[i]->control->userdata = (void *)component;
-      status = mmal_port_enable(graph->component[i]->control, graph_component_control_cb);
-      if (status != MMAL_SUCCESS)
-         LOG_ERROR("could not enable port %s", component->control->name);
-   }
-
-   return MMAL_SUCCESS;
-
- error:
-   graph_component_destroy(component);
-   return status;
-}
-
-MMAL_PORT_T *mmal_graph_find_port(MMAL_GRAPH_T *graph,
-                                  const char *name,
-                                  MMAL_PORT_TYPE_T type,
-                                  unsigned index)
-{
-   unsigned i;
-   MMAL_GRAPH_PRIVATE_T *private = (MMAL_GRAPH_PRIVATE_T *)graph;
-   for (i=0; i<private->component_num; i++)
-   {
-      MMAL_COMPONENT_T *comp = private->component[i];
-      if (vcos_strcasecmp(name, comp->name) == 0)
-      {
-         unsigned num;
-         MMAL_PORT_T **ports;
-         if (type == MMAL_PORT_TYPE_INPUT) {
-            num = comp->input_num;
-            ports = comp->input;
-         }
-         else if (type == MMAL_PORT_TYPE_OUTPUT) {
-            num = comp->output_num;
-            ports = comp->output;
-         }
-         else if (type == MMAL_PORT_TYPE_CONTROL) {
-            num = 1;
-            ports = &comp->control;
-         }
-         else {
-            vcos_assert(0);
-            return NULL;
-         }
-         if (index < num)
-         {
-            return ports[index];
-         }
-      }
-   }
-   LOG_INFO("port %s:%d not found", name, index);
-   return NULL;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.h
deleted file mode 100644
index ef8fab7..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_graph.h
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_GRAPH_H
-#define MMAL_GRAPH_H
-
-#include "util/mmal_connection.h"
-
-/** \defgroup MmalGraphUtility Graph Utility
- * \ingroup MmalUtilities
- * The graph utility functions allows one to easily create graphs of MMAL components.
- *
- * @{
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Structure describing a graph */
-typedef struct MMAL_GRAPH_T
-{
-   /** Pointer to private data of the client */
-   struct MMAL_GRAPH_USERDATA_T *userdata;
-
-   /** Optional callback that the client can set to get notified when the graph is going to be destroyed */
-   void (*pf_destroy)(struct MMAL_GRAPH_T *);
-
-   /** Optional callback that the client can set to intercept parameter requests on ports exposed by the graph */
-   MMAL_STATUS_T (*pf_parameter_set)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param);
-   /** Optional callback that the client can set to intercept parameter requests on ports exposed by the graph */
-   MMAL_STATUS_T (*pf_parameter_get)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param);
-   /** Optional callback that the client can set to intercept format commit calls on ports exposed by the graph */
-   MMAL_STATUS_T (*pf_format_commit)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
-   /** Optional callback that the client can set to intercept send buffer calls on ports exposed by the graph */
-   MMAL_STATUS_T (*pf_send_buffer)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
-   /** Optional callback that the client can set to intercept buffer callbacks on ports exposed by the graph */
-   MMAL_STATUS_T (*pf_return_buffer)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
-   /** Optional callback that the client can set to intercept payload alloc calls on ports exposed by the graph */
-   MMAL_STATUS_T (*pf_payload_alloc)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, uint32_t payload_size, uint8_t **);
-   /** Optional callback that the client can set to intercept payload free calls on ports exposed by the graph */
-   MMAL_STATUS_T (*pf_payload_free)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port, uint8_t *payload);
-   /** Optional callback that the client can set to intercept flush calls on ports exposed by the graph */
-   MMAL_STATUS_T (*pf_flush)(struct MMAL_GRAPH_T *, MMAL_PORT_T *port);
-
-} MMAL_GRAPH_T;
-
-/** Create an instance of a graph.
- * The newly created graph will need to be populated by the client.
- *
- * @param graph returned graph
- * @param userdata_size size to be allocated for the userdata field
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_create(MMAL_GRAPH_T **graph, unsigned int userdata_size);
-
-/** Add a component to a graph.
- * Allows the client to add a component to the graph.
- *
- * @param graph instance of the graph
- * @param component component to add to a graph
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_add_component(MMAL_GRAPH_T *graph, MMAL_COMPONENT_T *component);
-
-/** Add a port to a graph.
- * Allows the client to add an input or output port to a graph. The given port
- * will effectively become an end point for the graph.
- *
- * @param graph instance of the graph
- * @param port port to add to the graph
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_add_port(MMAL_GRAPH_T *graph, MMAL_PORT_T *port);
-
-/** Add a connection to a graph.
- * Allows the client to add an internal connection to a graph.
- *
- * @param graph instance of the graph
- * @param connection connection to add to the graph
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_add_connection(MMAL_GRAPH_T *graph, MMAL_CONNECTION_T *connection);
-
-/** Create a new component and add it to a graph.
- * Allows the client to create and add a component to the graph.
- *
- * @param graph instance of the graph
- * @param name name of the component to create
- * @param component if not NULL, will contain a pointer to the created component
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_new_component(MMAL_GRAPH_T *graph, const char *name,
-   MMAL_COMPONENT_T **component);
-
-/** Create and add a connection to a graph.
- * Allows the client to create and add an internal connection to a graph.
- *
- * @param graph      instance of the graph
- * @param out        the output port to use for the connection
- * @param in         the input port to use for the connection
- * @param flags      the flags specifying which type of connection should be created
- * @param connection if not NULL, will contain a pointer to the created connection
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_new_connection(MMAL_GRAPH_T *graph, MMAL_PORT_T *out, MMAL_PORT_T *in,
-   uint32_t flags, MMAL_CONNECTION_T **connection);
-
-/** Definition of the callback used by a graph to send events to the client.
- *
- * @param graph   the graph sending the event
- * @param port    the port which generated the event
- * @param buffer  the buffer header containing the event data
- * @param cb_data data passed back to the client when the callback is invoked
- */
-typedef void (*MMAL_GRAPH_EVENT_CB)(MMAL_GRAPH_T *graph, MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer,
-   void *cb_data);
-
-/** Enable the graph and start processing.
- *
- * @param graph   the graph to enable
- * @param cb      the callback to invoke when an event occurs on any of the internal control ports
- * @param cb_data data passed back to the client when the callback is invoked
- *
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_enable(MMAL_GRAPH_T *graph, MMAL_GRAPH_EVENT_CB cb, void *cb_data);
-
-MMAL_STATUS_T mmal_graph_disable(MMAL_GRAPH_T *graph);
-
-/** Find a port in the graph.
- *
- * @param graph graph instance
- * @param name  name of the component of interest
- * @param type  type of port (in/out)
- * @param index which port index within the component
- *
- * @return port, or NULL if not found
- */
-MMAL_PORT_T *mmal_graph_find_port(MMAL_GRAPH_T *graph,
-                                  const char *name,
-                                  MMAL_PORT_TYPE_T type,
-                                  unsigned index);
-
-/** Create an instance of a component from a graph.
- * The newly created component will expose input and output ports to the client.
- * Not that all the exposed ports will be in a disabled state by default.
- *
- * @param graph graph to create the component from
- * @param name name of the component to create
- * @param component returned component
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_build(MMAL_GRAPH_T *ctx,
-   const char *name, MMAL_COMPONENT_T **component);
-
-/** Component constructor for a graph.
- * FIXME: private function
- *
- * @param name name of the component to create
- * @param component component
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_component_constructor(const char *name, MMAL_COMPONENT_T *component);
-
-/** Destroy a previously created graph
- * @param graph graph to destroy
- * @return MMAL_SUCCESS on success
- */
-MMAL_STATUS_T mmal_graph_destroy(MMAL_GRAPH_T *ctx);
-
-#ifdef __cplusplus
-}
-#endif
-
-/** @} */
-
-#endif /* MMAL_GRAPH_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.c
deleted file mode 100644
index 085a818..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.c
+++ /dev/null
@@ -1,807 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal.h"
-#include "util/mmal_il.h"
-#include "interface/vmcs_host/khronos/IL/OMX_Broadcom.h"
-
-/*****************************************************************************/
-static struct {
-   MMAL_STATUS_T mmal;
-   OMX_ERRORTYPE omx;
-} mmal_omx_error[] =
-{
-   {MMAL_SUCCESS, OMX_ErrorNone},
-   {MMAL_ENOMEM, OMX_ErrorInsufficientResources},
-   {MMAL_ENOSPC, OMX_ErrorInsufficientResources},
-   {MMAL_EINVAL, OMX_ErrorBadParameter},
-   {MMAL_ENOSYS, OMX_ErrorNotImplemented},
-   {(MMAL_STATUS_T)-1, OMX_ErrorUndefined},
-};
-
-OMX_ERRORTYPE mmalil_error_to_omx(MMAL_STATUS_T status)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_error[i].mmal != (MMAL_STATUS_T)-1; i++)
-      if(mmal_omx_error[i].mmal == status) break;
-   return mmal_omx_error[i].omx;
-}
-
-MMAL_STATUS_T mmalil_error_to_mmal(OMX_ERRORTYPE error)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_error[i].mmal != (MMAL_STATUS_T)-1; i++)
-      if(mmal_omx_error[i].omx == error) break;
-   return mmal_omx_error[i].mmal;
-}
-
-/*****************************************************************************/
-OMX_U32 mmalil_buffer_flags_to_omx(uint32_t flags)
-{
-   OMX_U32 omx_flags = 0;
-
-   if(flags & MMAL_BUFFER_HEADER_FLAG_KEYFRAME)
-      omx_flags |= OMX_BUFFERFLAG_SYNCFRAME;
-   if(flags & MMAL_BUFFER_HEADER_FLAG_FRAME_END)
-      omx_flags |= OMX_BUFFERFLAG_ENDOFFRAME;
-   if(flags & MMAL_BUFFER_HEADER_FLAG_EOS)
-      omx_flags |= OMX_BUFFERFLAG_EOS;
-   if(flags & MMAL_BUFFER_HEADER_FLAG_CONFIG)
-      omx_flags |= OMX_BUFFERFLAG_CODECCONFIG;
-   if(flags & MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY)
-      omx_flags |= OMX_BUFFERFLAG_DISCONTINUITY;
-   if (flags & MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO)
-      omx_flags |= OMX_BUFFERFLAG_CODECSIDEINFO;
-   if (flags & MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT)
-      omx_flags |= OMX_BUFFERFLAG_CAPTURE_PREVIEW;
-   if (flags & MMAL_BUFFER_HEADER_FLAG_CORRUPTED)
-      omx_flags |= OMX_BUFFERFLAG_DATACORRUPT;
-
-   return omx_flags;
-}
-
-uint32_t mmalil_buffer_flags_to_mmal(OMX_U32 flags)
-{
-   uint32_t mmal_flags = 0;
-
-   if (flags & OMX_BUFFERFLAG_SYNCFRAME)
-      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_KEYFRAME;
-   if (flags & OMX_BUFFERFLAG_ENDOFFRAME)
-      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
-   if (flags & OMX_BUFFERFLAG_EOS)
-      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_EOS;
-   if (flags & OMX_BUFFERFLAG_CODECCONFIG)
-      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;
-   if (flags & OMX_BUFFERFLAG_DISCONTINUITY)
-      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY;
-   if (flags & OMX_BUFFERFLAG_CODECSIDEINFO)
-      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO;
-   if (flags & OMX_BUFFERFLAG_CAPTURE_PREVIEW)
-      mmal_flags |= MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT;
-   if (flags & OMX_BUFFERFLAG_DATACORRUPT)
-      mmal_flags |= MMAL_BUFFER_HEADER_FLAG_CORRUPTED;
-
-   return mmal_flags;
-}
-
-/*****************************************************************************/
-void mmalil_buffer_header_to_omx(OMX_BUFFERHEADERTYPE *omx, MMAL_BUFFER_HEADER_T *mmal)
-{
-   omx->pBuffer = mmal->data;
-   omx->nAllocLen = mmal->alloc_size;
-   omx->nFilledLen = mmal->length;
-   omx->nOffset = mmal->offset;
-   omx->nFlags = mmalil_buffer_flags_to_omx(mmal->flags);
-   omx->nTimeStamp = omx_ticks_from_s64(mmal->pts);
-   if (mmal->pts == MMAL_TIME_UNKNOWN)
-   {
-      omx->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
-      omx->nTimeStamp = omx_ticks_from_s64(0);
-   }
-}
-
-void mmalil_buffer_header_to_mmal(MMAL_BUFFER_HEADER_T *mmal, OMX_BUFFERHEADERTYPE *omx)
-{
-   mmal->cmd = 0;
-   mmal->data = omx->pBuffer;
-   mmal->alloc_size = omx->nAllocLen;
-   mmal->length = omx->nFilledLen;
-   mmal->offset = omx->nOffset;
-   mmal->pts = omx_ticks_to_s64(omx->nTimeStamp);
-   if (omx->nFlags & OMX_BUFFERFLAG_TIME_UNKNOWN)
-      mmal->pts = MMAL_TIME_UNKNOWN;
-   mmal->dts = MMAL_TIME_UNKNOWN;
-   mmal->flags = mmalil_buffer_flags_to_mmal(omx->nFlags);
-}
-
-/*****************************************************************************/
-static struct {
-   MMAL_ES_TYPE_T type;
-   OMX_PORTDOMAINTYPE domain;
-} mmal_omx_es_type_table[] =
-{
-   {MMAL_ES_TYPE_VIDEO,           OMX_PortDomainVideo},
-   {MMAL_ES_TYPE_VIDEO,           OMX_PortDomainImage},
-   {MMAL_ES_TYPE_AUDIO,           OMX_PortDomainAudio},
-   {MMAL_ES_TYPE_UNKNOWN,         OMX_PortDomainMax}
-};
-
-OMX_PORTDOMAINTYPE mmalil_es_type_to_omx_domain(MMAL_ES_TYPE_T type)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_es_type_table[i].type != MMAL_ES_TYPE_UNKNOWN; i++)
-      if(mmal_omx_es_type_table[i].type == type) break;
-   return mmal_omx_es_type_table[i].domain;
-}
-
-MMAL_ES_TYPE_T mmalil_omx_domain_to_es_type(OMX_PORTDOMAINTYPE domain)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_es_type_table[i].type != MMAL_ES_TYPE_UNKNOWN; i++)
-      if(mmal_omx_es_type_table[i].domain == domain) break;
-   return mmal_omx_es_type_table[i].type;
-}
-
-/*****************************************************************************/
-static struct {
-   uint32_t encoding;
-   OMX_AUDIO_CODINGTYPE coding;
-} mmal_omx_audio_coding_table[] =
-{
-   {MMAL_ENCODING_MP4A,           OMX_AUDIO_CodingAAC},
-   {MMAL_ENCODING_MPGA,           OMX_AUDIO_CodingMP3},
-   {MMAL_ENCODING_WMA2,           OMX_AUDIO_CodingWMA},
-   {MMAL_ENCODING_WMA1,           OMX_AUDIO_CodingWMA},
-   {MMAL_ENCODING_AMRNB,          OMX_AUDIO_CodingAMR},
-   {MMAL_ENCODING_AMRWB,          OMX_AUDIO_CodingAMR},
-   {MMAL_ENCODING_AMRWBP,         OMX_AUDIO_CodingAMR},
-   {MMAL_ENCODING_VORBIS,         OMX_AUDIO_CodingVORBIS},
-   {MMAL_ENCODING_ALAW,           OMX_AUDIO_CodingPCM},
-   {MMAL_ENCODING_MULAW,          OMX_AUDIO_CodingPCM},
-   {MMAL_ENCODING_PCM_SIGNED_LE,  OMX_AUDIO_CodingPCM},
-   {MMAL_ENCODING_PCM_UNSIGNED_LE,OMX_AUDIO_CodingPCM},
-   {MMAL_ENCODING_PCM_SIGNED_BE,  OMX_AUDIO_CodingPCM},
-   {MMAL_ENCODING_PCM_UNSIGNED_BE,OMX_AUDIO_CodingPCM},
-   {MMAL_ENCODING_UNKNOWN,        OMX_AUDIO_CodingUnused}
-};
-
-uint32_t mmalil_omx_audio_coding_to_encoding(OMX_AUDIO_CODINGTYPE coding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_audio_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(mmal_omx_audio_coding_table[i].coding == coding) break;
-   return mmal_omx_audio_coding_table[i].encoding;
-}
-
-OMX_AUDIO_CODINGTYPE mmalil_encoding_to_omx_audio_coding(uint32_t encoding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_audio_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(mmal_omx_audio_coding_table[i].encoding == encoding) break;
-   return mmal_omx_audio_coding_table[i].coding;
-}
-
-static struct {
-   OMX_AUDIO_CODINGTYPE coding;
-   OMX_INDEXTYPE index;
-   unsigned int size;
-} mmal_omx_audio_format_table[] =
-{
-   {OMX_AUDIO_CodingPCM, OMX_IndexParamAudioPcm, sizeof(OMX_AUDIO_PARAM_PCMMODETYPE)},
-   {OMX_AUDIO_CodingADPCM, OMX_IndexParamAudioAdpcm, sizeof(OMX_AUDIO_PARAM_ADPCMTYPE)},
-   {OMX_AUDIO_CodingAMR, OMX_IndexParamAudioAmr, sizeof(OMX_AUDIO_PARAM_AMRTYPE)},
-   {OMX_AUDIO_CodingGSMFR, OMX_IndexParamAudioGsm_FR, sizeof(OMX_AUDIO_PARAM_GSMFRTYPE)},
-   {OMX_AUDIO_CodingGSMEFR, OMX_IndexParamAudioGsm_EFR, sizeof(OMX_AUDIO_PARAM_GSMEFRTYPE)},
-   {OMX_AUDIO_CodingGSMHR, OMX_IndexParamAudioGsm_HR, sizeof(OMX_AUDIO_PARAM_GSMHRTYPE)},
-   {OMX_AUDIO_CodingPDCFR, OMX_IndexParamAudioPdc_FR, sizeof(OMX_AUDIO_PARAM_PDCFRTYPE)},
-   {OMX_AUDIO_CodingPDCEFR, OMX_IndexParamAudioPdc_EFR, sizeof(OMX_AUDIO_PARAM_PDCEFRTYPE)},
-   {OMX_AUDIO_CodingPDCHR, OMX_IndexParamAudioPdc_HR, sizeof(OMX_AUDIO_PARAM_PDCHRTYPE)},
-   {OMX_AUDIO_CodingTDMAFR, OMX_IndexParamAudioTdma_FR, sizeof(OMX_AUDIO_PARAM_TDMAFRTYPE)},
-   {OMX_AUDIO_CodingTDMAEFR, OMX_IndexParamAudioTdma_EFR, sizeof(OMX_AUDIO_PARAM_TDMAEFRTYPE)},
-   {OMX_AUDIO_CodingQCELP8, OMX_IndexParamAudioQcelp8, sizeof(OMX_AUDIO_PARAM_QCELP8TYPE)},
-   {OMX_AUDIO_CodingQCELP13, OMX_IndexParamAudioQcelp13, sizeof(OMX_AUDIO_PARAM_QCELP13TYPE)},
-   {OMX_AUDIO_CodingEVRC, OMX_IndexParamAudioEvrc, sizeof(OMX_AUDIO_PARAM_EVRCTYPE)},
-   {OMX_AUDIO_CodingSMV, OMX_IndexParamAudioSmv, sizeof(OMX_AUDIO_PARAM_SMVTYPE)},
-   {OMX_AUDIO_CodingG723, OMX_IndexParamAudioG723, sizeof(OMX_AUDIO_PARAM_G723TYPE)},
-   {OMX_AUDIO_CodingG726, OMX_IndexParamAudioG726, sizeof(OMX_AUDIO_PARAM_G726TYPE)},
-   {OMX_AUDIO_CodingG729, OMX_IndexParamAudioG729, sizeof(OMX_AUDIO_PARAM_G729TYPE)},
-   {OMX_AUDIO_CodingAAC, OMX_IndexParamAudioAac, sizeof(OMX_AUDIO_PARAM_AACPROFILETYPE)},
-   {OMX_AUDIO_CodingMP3, OMX_IndexParamAudioMp3, sizeof(OMX_AUDIO_PARAM_MP3TYPE)},
-   {OMX_AUDIO_CodingSBC, OMX_IndexParamAudioSbc, sizeof(OMX_AUDIO_PARAM_SBCTYPE)},
-   {OMX_AUDIO_CodingVORBIS, OMX_IndexParamAudioVorbis, sizeof(OMX_AUDIO_PARAM_VORBISTYPE)},
-   {OMX_AUDIO_CodingWMA, OMX_IndexParamAudioWma, sizeof(OMX_AUDIO_PARAM_WMATYPE)},
-   {OMX_AUDIO_CodingRA, OMX_IndexParamAudioRa, sizeof(OMX_AUDIO_PARAM_RATYPE)},
-   {OMX_AUDIO_CodingMIDI, OMX_IndexParamAudioMidi, sizeof(OMX_AUDIO_PARAM_MIDITYPE)},
-   {OMX_AUDIO_CodingUnused, 0, 0}
-};
-
-OMX_INDEXTYPE mmalil_omx_audio_param_index(OMX_AUDIO_CODINGTYPE coding, OMX_U32 *size)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_audio_format_table[i].coding != OMX_AUDIO_CodingUnused; i++)
-      if(mmal_omx_audio_format_table[i].coding == coding) break;
-
-   if(size) *size = mmal_omx_audio_format_table[i].size;
-   return mmal_omx_audio_format_table[i].index;
-}
-
-MMAL_FOURCC_T mmalil_omx_audio_param_to_format(MMAL_ES_FORMAT_T *format,
-   OMX_AUDIO_CODINGTYPE coding, OMX_FORMAT_PARAM_TYPE *param)
-{
-   MMAL_AUDIO_FORMAT_T *audio = &format->es->audio;
-   format->encoding = MMAL_ENCODING_UNKNOWN;
-
-   switch(coding)
-   {
-   case OMX_AUDIO_CodingPCM:
-      audio->channels = param->pcm.nChannels;
-      audio->sample_rate = param->pcm.nSamplingRate;
-      audio->bits_per_sample = param->pcm.nBitPerSample;
-      if(param->pcm.ePCMMode == OMX_AUDIO_PCMModeLinear && param->pcm.bInterleaved)
-      {
-         if(param->pcm.eEndian == OMX_EndianBig &&
-            param->pcm.eNumData == OMX_NumericalDataSigned)
-            format->encoding = MMAL_ENCODING_PCM_SIGNED_BE;
-         else if(param->pcm.eEndian == OMX_EndianLittle &&
-            param->pcm.eNumData == OMX_NumericalDataSigned)
-            format->encoding = MMAL_ENCODING_PCM_SIGNED_LE;
-         if(param->pcm.eEndian == OMX_EndianBig &&
-            param->pcm.eNumData == OMX_NumericalDataUnsigned)
-            format->encoding = MMAL_ENCODING_PCM_UNSIGNED_BE;
-         if(param->pcm.eEndian == OMX_EndianLittle &&
-            param->pcm.eNumData == OMX_NumericalDataUnsigned)
-            format->encoding = MMAL_ENCODING_PCM_UNSIGNED_LE;
-      }
-      else if(param->pcm.ePCMMode == OMX_AUDIO_PCMModeALaw)
-         format->encoding = MMAL_ENCODING_ALAW;
-      else if(param->pcm.ePCMMode == OMX_AUDIO_PCMModeMULaw)
-         format->encoding = MMAL_ENCODING_MULAW;
-      break;
-   case OMX_AUDIO_CodingAAC:
-      audio->channels = param->aac.nChannels;
-      audio->sample_rate = param->aac.nSampleRate;
-      format->bitrate = param->aac.nBitRate;
-      switch(param->aac.eAACStreamFormat)
-      {
-      case OMX_AUDIO_AACStreamFormatMP2ADTS:
-      case OMX_AUDIO_AACStreamFormatMP4ADTS:
-         format->encoding = MMAL_ENCODING_MP4A;
-         format->encoding_variant = MMAL_ENCODING_VARIANT_MP4A_ADTS;
-         break;
-      case OMX_AUDIO_AACStreamFormatMP4FF:
-      case OMX_AUDIO_AACStreamFormatRAW:
-         format->encoding = MMAL_ENCODING_MP4A;
-         format->encoding_variant = MMAL_ENCODING_VARIANT_MP4A_DEFAULT;
-         break;
-      default: break;
-      }
-      break;
-   case OMX_AUDIO_CodingMP3:
-      format->encoding = MMAL_ENCODING_MPGA;
-      audio->channels = param->mp3.nChannels;
-      audio->sample_rate = param->mp3.nSampleRate;
-      format->bitrate = param->mp3.nBitRate;
-      break;
-   case OMX_AUDIO_CodingWMA:
-      audio->channels = param->wma.nChannels;
-      audio->sample_rate = param->wma.nSamplingRate;
-      audio->block_align = param->wma.nBlockAlign;
-      format->bitrate = param->wma.nBitRate;
-      switch(param->wma.eFormat)
-      {
-      case OMX_AUDIO_WMAFormat7:
-         format->encoding = MMAL_ENCODING_WMA1;
-         break;
-      case OMX_AUDIO_WMAFormat8:
-      case OMX_AUDIO_WMAFormat9:
-         format->encoding = MMAL_ENCODING_WMA2;
-         break;
-      default: break;
-      }
-      break;
-   case OMX_AUDIO_CodingVORBIS:
-      format->encoding = MMAL_ENCODING_VORBIS;
-      audio->channels = param->vorbis.nChannels;
-      audio->sample_rate = param->vorbis.nSampleRate;
-      format->bitrate = param->vorbis.nBitRate;
-      break;
-   case OMX_AUDIO_CodingAMR:
-      audio->channels = param->amr.nChannels;
-      audio->sample_rate = 8000;
-      format->bitrate = param->amr.nBitRate;
-      if(param->amr.eAMRBandMode >= OMX_AUDIO_AMRBandModeNB0 &&
-         param->amr.eAMRBandMode <= OMX_AUDIO_AMRBandModeNB7)
-         format->encoding = MMAL_ENCODING_AMRNB;
-      if(param->amr.eAMRBandMode >= OMX_AUDIO_AMRBandModeWB0 &&
-         param->amr.eAMRBandMode <= OMX_AUDIO_AMRBandModeWB8)
-         format->encoding = MMAL_ENCODING_AMRWB;
-      break;
-   case OMX_AUDIO_CodingADPCM:
-   case OMX_AUDIO_CodingGSMFR:
-   case OMX_AUDIO_CodingGSMEFR:
-   case OMX_AUDIO_CodingGSMHR:
-   case OMX_AUDIO_CodingPDCFR:
-   case OMX_AUDIO_CodingPDCEFR:
-   case OMX_AUDIO_CodingPDCHR:
-   case OMX_AUDIO_CodingTDMAFR:
-   case OMX_AUDIO_CodingTDMAEFR:
-   case OMX_AUDIO_CodingQCELP8:
-   case OMX_AUDIO_CodingQCELP13:
-   case OMX_AUDIO_CodingEVRC:
-   case OMX_AUDIO_CodingSMV:
-   case OMX_AUDIO_CodingG711:
-   case OMX_AUDIO_CodingG723:
-   case OMX_AUDIO_CodingG726:
-   case OMX_AUDIO_CodingG729:
-   case OMX_AUDIO_CodingSBC:
-   case OMX_AUDIO_CodingRA:
-   case OMX_AUDIO_CodingMIDI:
-   default:
-      vcos_assert(0);
-      break;
-   }
-
-   return format->encoding;
-}
-
-OMX_AUDIO_CODINGTYPE mmalil_format_to_omx_audio_param(OMX_FORMAT_PARAM_TYPE *param,
-   OMX_INDEXTYPE *param_index, MMAL_ES_FORMAT_T *format)
-{
-   MMAL_AUDIO_FORMAT_T *audio = &format->es->audio;
-   OMX_AUDIO_CODINGTYPE coding = mmalil_encoding_to_omx_audio_coding(format->encoding);
-   OMX_U32 size = 0;
-   OMX_INDEXTYPE index = mmalil_omx_audio_param_index(coding, &size);
-
-   if(param_index) *param_index = index;
-   memset(param, 0, size);
-   param->common.nSize = size;
-
-   switch(coding)
-   {
-   case OMX_AUDIO_CodingPCM:
-      param->pcm.nChannels = audio->channels;
-      param->pcm.nSamplingRate = audio->sample_rate;
-      param->pcm.nBitPerSample = audio->bits_per_sample;
-      if(audio->channels == 1)
-      {
-         param->pcm.eChannelMapping[0] = OMX_AUDIO_ChannelCF;
-      }
-      else if(audio->channels == 2)
-      {
-         param->pcm.eChannelMapping[0] = OMX_AUDIO_ChannelLF;
-         param->pcm.eChannelMapping[1] = OMX_AUDIO_ChannelRF;
-      }
-      if(format->encoding == MMAL_ENCODING_PCM_SIGNED_BE ||
-         format->encoding == MMAL_ENCODING_PCM_SIGNED_LE ||
-         format->encoding == MMAL_ENCODING_PCM_UNSIGNED_BE ||
-         format->encoding == MMAL_ENCODING_PCM_UNSIGNED_LE)
-      {
-         param->pcm.ePCMMode = OMX_AUDIO_PCMModeLinear;
-         param->pcm.bInterleaved = OMX_TRUE;
-         param->pcm.eEndian = OMX_EndianLittle;
-         param->pcm.eNumData = OMX_NumericalDataSigned;
-         if(format->encoding == MMAL_ENCODING_PCM_SIGNED_BE ||
-            format->encoding == MMAL_ENCODING_PCM_UNSIGNED_BE)
-            param->pcm.eEndian = OMX_EndianBig;
-         if(format->encoding == MMAL_ENCODING_PCM_UNSIGNED_LE ||
-            format->encoding == MMAL_ENCODING_PCM_UNSIGNED_BE)
-            param->pcm.eNumData = OMX_NumericalDataUnsigned;
-      }
-      else if(format->encoding == MMAL_ENCODING_ALAW)
-         param->pcm.ePCMMode = OMX_AUDIO_PCMModeALaw;
-      else if(format->encoding == MMAL_ENCODING_MULAW)
-         param->pcm.ePCMMode = OMX_AUDIO_PCMModeMULaw;
-      break;
-   case OMX_AUDIO_CodingAAC:
-      param->aac.nChannels = audio->channels;
-      param->aac.nSampleRate = audio->sample_rate;
-      param->aac.nBitRate = format->bitrate;
-      switch(format->encoding_variant)
-      {
-      case MMAL_ENCODING_VARIANT_MP4A_ADTS:
-         param->aac.eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4ADTS;
-         break;
-      case MMAL_ENCODING_VARIANT_MP4A_DEFAULT:
-         param->aac.eAACStreamFormat = OMX_AUDIO_AACStreamFormatRAW;
-         break;
-      default: break;
-      }
-      break;
-   case OMX_AUDIO_CodingMP3:
-      param->mp3.nChannels = audio->channels;
-      param->mp3.nSampleRate = audio->sample_rate;
-      param->mp3.nBitRate = format->bitrate;
-      break;
-   case OMX_AUDIO_CodingWMA:
-      param->wma.nChannels = audio->channels;
-      param->wma.nSamplingRate = audio->sample_rate;
-      param->wma.nBlockAlign = audio->block_align;
-      param->wma.nBitRate = format->bitrate;
-      switch(format->encoding)
-      {
-      case MMAL_ENCODING_WMA1:
-         param->wma.eFormat = OMX_AUDIO_WMAFormat7;
-         break;
-      case MMAL_ENCODING_WMA2:
-         param->wma.eFormat = OMX_AUDIO_WMAFormat8;
-         break;
-      default: break;
-      }
-      break;
-   case OMX_AUDIO_CodingVORBIS:
-      param->vorbis.nChannels = audio->channels;
-      param->vorbis.nSampleRate = audio->sample_rate;
-      param->vorbis.nBitRate = format->bitrate;
-      break;
-   case OMX_AUDIO_CodingAMR:
-      param->amr.nChannels = audio->channels;
-      param->amr.nBitRate = format->bitrate;
-      if(format->encoding == MMAL_ENCODING_AMRNB)
-         param->amr.eAMRBandMode = OMX_AUDIO_AMRBandModeNB0;
-      if(format->encoding == MMAL_ENCODING_AMRWB)
-         param->amr.eAMRBandMode = OMX_AUDIO_AMRBandModeWB0;
-      break;
-   case OMX_AUDIO_CodingADPCM:
-   case OMX_AUDIO_CodingGSMFR:
-   case OMX_AUDIO_CodingGSMEFR:
-   case OMX_AUDIO_CodingGSMHR:
-   case OMX_AUDIO_CodingPDCFR:
-   case OMX_AUDIO_CodingPDCEFR:
-   case OMX_AUDIO_CodingPDCHR:
-   case OMX_AUDIO_CodingTDMAFR:
-   case OMX_AUDIO_CodingTDMAEFR:
-   case OMX_AUDIO_CodingQCELP8:
-   case OMX_AUDIO_CodingQCELP13:
-   case OMX_AUDIO_CodingEVRC:
-   case OMX_AUDIO_CodingSMV:
-   case OMX_AUDIO_CodingG711:
-   case OMX_AUDIO_CodingG723:
-   case OMX_AUDIO_CodingG726:
-   case OMX_AUDIO_CodingG729:
-   case OMX_AUDIO_CodingSBC:
-   case OMX_AUDIO_CodingRA:
-   case OMX_AUDIO_CodingMIDI:
-   default:
-      vcos_assert(0);
-      break;
-   }
-
-   return coding;
-}
-
-/*****************************************************************************/
-static struct {
-   uint32_t encoding;
-   OMX_VIDEO_CODINGTYPE coding;
-} mmal_omx_video_coding_table[] =
-{
-   {MMAL_ENCODING_H264,           OMX_VIDEO_CodingAVC},
-   {MMAL_ENCODING_MP4V,           OMX_VIDEO_CodingMPEG4},
-   {MMAL_ENCODING_MP2V,           OMX_VIDEO_CodingMPEG2},
-   {MMAL_ENCODING_MP1V,           OMX_VIDEO_CodingMPEG2},
-   {MMAL_ENCODING_H263,           OMX_VIDEO_CodingH263},
-   {MMAL_ENCODING_WMV3,           OMX_VIDEO_CodingWMV},
-   {MMAL_ENCODING_WMV2,           OMX_VIDEO_CodingWMV},
-   {MMAL_ENCODING_WMV1,           OMX_VIDEO_CodingWMV},
-   {MMAL_ENCODING_WVC1,           OMX_VIDEO_CodingWMV},
-   {MMAL_ENCODING_VP6,            OMX_VIDEO_CodingVP6},
-   {MMAL_ENCODING_VP7,            OMX_VIDEO_CodingVP7},
-   {MMAL_ENCODING_VP8,            OMX_VIDEO_CodingVP8},
-   {MMAL_ENCODING_SPARK,          OMX_VIDEO_CodingSorenson},
-   {MMAL_ENCODING_THEORA,         OMX_VIDEO_CodingTheora},
-   {MMAL_ENCODING_UNKNOWN,        OMX_VIDEO_CodingUnused}
-};
-
-uint32_t mmalil_omx_video_coding_to_encoding(OMX_VIDEO_CODINGTYPE coding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_video_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(mmal_omx_video_coding_table[i].coding == coding) break;
-   return mmal_omx_video_coding_table[i].encoding;
-}
-
-OMX_VIDEO_CODINGTYPE mmalil_encoding_to_omx_video_coding(uint32_t encoding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_video_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(mmal_omx_video_coding_table[i].encoding == encoding) break;
-   return mmal_omx_video_coding_table[i].coding;
-}
-
-/*****************************************************************************/
-static struct {
-   uint32_t encoding;
-   OMX_IMAGE_CODINGTYPE coding;
-} mmal_omx_image_coding_table[] =
-{
-   {MMAL_ENCODING_JPEG,           OMX_IMAGE_CodingJPEG},
-   {MMAL_ENCODING_GIF,            OMX_IMAGE_CodingGIF},
-   {MMAL_ENCODING_PNG,            OMX_IMAGE_CodingPNG},
-   {MMAL_ENCODING_BMP,            OMX_IMAGE_CodingBMP},
-   {MMAL_ENCODING_TGA,            OMX_IMAGE_CodingTGA},
-   {MMAL_ENCODING_PPM,            OMX_IMAGE_CodingPPM},
-   {MMAL_ENCODING_UNKNOWN,        OMX_IMAGE_CodingUnused}
-};
-
-uint32_t mmalil_omx_image_coding_to_encoding(OMX_IMAGE_CODINGTYPE coding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_image_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(mmal_omx_image_coding_table[i].coding == coding) break;
-   return mmal_omx_image_coding_table[i].encoding;
-}
-
-OMX_IMAGE_CODINGTYPE mmalil_encoding_to_omx_image_coding(uint32_t encoding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_image_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(mmal_omx_image_coding_table[i].encoding == encoding) break;
-   return mmal_omx_image_coding_table[i].coding;
-}
-
-uint32_t mmalil_omx_coding_to_encoding(uint32_t encoding, OMX_PORTDOMAINTYPE domain)
-{
-   if(domain == OMX_PortDomainVideo)
-      return mmalil_omx_video_coding_to_encoding((OMX_VIDEO_CODINGTYPE)encoding);
-   else if(domain == OMX_PortDomainAudio)
-      return mmalil_omx_audio_coding_to_encoding((OMX_AUDIO_CODINGTYPE)encoding);
-   else if(domain == OMX_PortDomainImage)
-      return mmalil_omx_image_coding_to_encoding((OMX_IMAGE_CODINGTYPE)encoding);
-   else
-      return MMAL_ENCODING_UNKNOWN;
-}
-
-/*****************************************************************************/
-static struct {
-   uint32_t encoding;
-   OMX_COLOR_FORMATTYPE coding;
-} mmal_omx_colorformat_coding_table[] =
-{
-   {MMAL_ENCODING_I420,           OMX_COLOR_FormatYUV420PackedPlanar},
-   {MMAL_ENCODING_I422,           OMX_COLOR_FormatYUV422PackedPlanar},
-   {MMAL_ENCODING_I420_SLICE,     OMX_COLOR_FormatYUV420PackedPlanar},
-   {MMAL_ENCODING_I422_SLICE,     OMX_COLOR_FormatYUV422PackedPlanar},
-   {MMAL_ENCODING_I420,           OMX_COLOR_FormatYUV420Planar},
-   {MMAL_ENCODING_YV12,           OMX_COLOR_FormatYVU420PackedPlanar},
-   {MMAL_ENCODING_NV12,           OMX_COLOR_FormatYUV420PackedSemiPlanar},
-   {MMAL_ENCODING_NV12,           OMX_COLOR_FormatYUV420SemiPlanar},
-   {MMAL_ENCODING_NV21,           OMX_COLOR_FormatYVU420PackedSemiPlanar},
-   {MMAL_ENCODING_YUVUV128,       OMX_COLOR_FormatYUVUV128},
-   {MMAL_ENCODING_YUYV,           OMX_COLOR_FormatYCbYCr},
-   {MMAL_ENCODING_YVYU,           OMX_COLOR_FormatYCrYCb},
-   {MMAL_ENCODING_UYVY,           OMX_COLOR_FormatCbYCrY},
-   {MMAL_ENCODING_VYUY,           OMX_COLOR_FormatCrYCbY},
-   {MMAL_ENCODING_RGB16,          OMX_COLOR_Format16bitRGB565},
-   {MMAL_ENCODING_BGR24,          OMX_COLOR_Format24bitRGB888},
-   {MMAL_ENCODING_BGRA,           OMX_COLOR_Format32bitARGB8888},
-   {MMAL_ENCODING_BGR16,          OMX_COLOR_Format16bitBGR565},
-   {MMAL_ENCODING_RGB24,          OMX_COLOR_Format24bitBGR888},
-   {MMAL_ENCODING_ARGB,           OMX_COLOR_Format32bitBGRA8888},
-   {MMAL_ENCODING_RGBA,           OMX_COLOR_Format32bitABGR8888},
-   {MMAL_ENCODING_EGL_IMAGE,      OMX_COLOR_FormatBRCMEGL},
-   {MMAL_ENCODING_OPAQUE,         OMX_COLOR_FormatBRCMOpaque},
-   {MMAL_ENCODING_UNKNOWN,        OMX_COLOR_FormatUnused}
-};
-
-uint32_t mmalil_omx_color_format_to_encoding(OMX_COLOR_FORMATTYPE coding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_colorformat_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(mmal_omx_colorformat_coding_table[i].coding == coding) break;
-   return mmal_omx_colorformat_coding_table[i].encoding;
-}
-
-OMX_COLOR_FORMATTYPE mmalil_encoding_to_omx_color_format(uint32_t encoding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_colorformat_coding_table[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(mmal_omx_colorformat_coding_table[i].encoding == encoding) break;
-   return mmal_omx_colorformat_coding_table[i].coding;
-}
-
-/*****************************************************************************/
-static struct {
-   uint32_t mmal;
-   OMX_COLORSPACETYPE omx;
-} mmal_omx_colorspace_coding_table[] =
-{
-   {MMAL_COLOR_SPACE_ITUR_BT601,    OMX_COLORSPACE_ITU_R_BT601},
-   {MMAL_COLOR_SPACE_ITUR_BT709,    OMX_COLORSPACE_ITU_R_BT709},
-   {MMAL_COLOR_SPACE_JPEG_JFIF,     OMX_COLORSPACE_JPEG_JFIF},
-   {MMAL_COLOR_SPACE_FCC,           OMX_COLORSPACE_FCC},
-   {MMAL_COLOR_SPACE_SMPTE240M,     OMX_COLORSPACE_SMPTE240M},
-   {MMAL_COLOR_SPACE_BT470_2_M,     OMX_COLORSPACE_BT470_2_M},
-   {MMAL_COLOR_SPACE_BT470_2_BG,    OMX_COLORSPACE_BT470_2_BG},
-   {MMAL_COLOR_SPACE_JFIF_Y16_255,  OMX_COLORSPACE_JFIF_Y16_255},
-   {MMAL_COLOR_SPACE_UNKNOWN,       OMX_COLORSPACE_UNKNOWN}
-};
-
-uint32_t mmalil_omx_color_space_to_mmal(OMX_COLORSPACETYPE coding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_colorspace_coding_table[i].mmal != MMAL_COLOR_SPACE_UNKNOWN; i++)
-      if(mmal_omx_colorspace_coding_table[i].omx == coding) break;
-   return mmal_omx_colorspace_coding_table[i].mmal;
-}
-
-OMX_COLORSPACETYPE mmalil_color_space_to_omx(uint32_t coding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_colorspace_coding_table[i].mmal != MMAL_COLOR_SPACE_UNKNOWN; i++)
-      if(mmal_omx_colorspace_coding_table[i].mmal == coding) break;
-   return mmal_omx_colorspace_coding_table[i].omx;
-}
-
-/*****************************************************************************/
-static struct {
-   uint32_t mmal;
-   OMX_U32 omx;
-   OMX_VIDEO_CODINGTYPE omx_coding;
-} mmal_omx_video_profile_table[] =
-{
-   { MMAL_VIDEO_PROFILE_H263_BASELINE,           OMX_VIDEO_H263ProfileBaseline,           OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_PROFILE_H263_H320CODING,         OMX_VIDEO_H263ProfileH320Coding,         OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_PROFILE_H263_BACKWARDCOMPATIBLE, OMX_VIDEO_H263ProfileBackwardCompatible, OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_PROFILE_H263_ISWV2,              OMX_VIDEO_H263ProfileISWV2,              OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_PROFILE_H263_ISWV3,              OMX_VIDEO_H263ProfileISWV3,              OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_PROFILE_H263_HIGHCOMPRESSION,    OMX_VIDEO_H263ProfileHighCompression,    OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_PROFILE_H263_INTERNET,           OMX_VIDEO_H263ProfileInternet,           OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_PROFILE_H263_INTERLACE,          OMX_VIDEO_H263ProfileInterlace,          OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_PROFILE_H263_HIGHLATENCY,        OMX_VIDEO_H263ProfileHighLatency,        OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_PROFILE_MP4V_SIMPLE,             OMX_VIDEO_MPEG4ProfileSimple,            OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_SIMPLESCALABLE,     OMX_VIDEO_MPEG4ProfileSimpleScalable,    OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_CORE,               OMX_VIDEO_MPEG4ProfileCore,              OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_MAIN,               OMX_VIDEO_MPEG4ProfileMain,              OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_NBIT,               OMX_VIDEO_MPEG4ProfileNbit,              OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_SCALABLETEXTURE,    OMX_VIDEO_MPEG4ProfileScalableTexture,   OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_SIMPLEFACE,         OMX_VIDEO_MPEG4ProfileSimpleFace,        OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_SIMPLEFBA,          OMX_VIDEO_MPEG4ProfileSimpleFBA,         OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_BASICANIMATED,      OMX_VIDEO_MPEG4ProfileBasicAnimated,     OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_HYBRID,             OMX_VIDEO_MPEG4ProfileHybrid,            OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDREALTIME,   OMX_VIDEO_MPEG4ProfileAdvancedRealTime,  OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_CORESCALABLE,       OMX_VIDEO_MPEG4ProfileCoreScalable,      OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCODING,     OMX_VIDEO_MPEG4ProfileAdvancedCoding,    OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCORE,       OMX_VIDEO_MPEG4ProfileAdvancedCore,      OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSCALABLE,   OMX_VIDEO_MPEG4ProfileAdvancedScalable,  OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSIMPLE,     OMX_VIDEO_MPEG4ProfileAdvancedSimple,    OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_PROFILE_H264_BASELINE,           OMX_VIDEO_AVCProfileBaseline,            OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_PROFILE_H264_MAIN,               OMX_VIDEO_AVCProfileMain,                OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_PROFILE_H264_EXTENDED,           OMX_VIDEO_AVCProfileExtended,            OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_PROFILE_H264_HIGH,               OMX_VIDEO_AVCProfileHigh,                OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_PROFILE_H264_HIGH10,             OMX_VIDEO_AVCProfileHigh10,              OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_PROFILE_H264_HIGH422,            OMX_VIDEO_AVCProfileHigh422,             OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_PROFILE_H264_HIGH444,            OMX_VIDEO_AVCProfileHigh444,             OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE, OMX_VIDEO_AVCProfileConstrainedBaseline,             OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_PROFILE_DUMMY,                   OMX_VIDEO_AVCProfileMax,                 OMX_VIDEO_CodingAVC},
-};
-
-uint32_t mmalil_omx_video_profile_to_mmal(OMX_U32 profile, OMX_VIDEO_CODINGTYPE coding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_video_profile_table[i].mmal != MMAL_VIDEO_PROFILE_DUMMY; i++)
-      if(mmal_omx_video_profile_table[i].omx == profile
-         && mmal_omx_video_profile_table[i].omx_coding == coding) break;
-   return mmal_omx_video_profile_table[i].mmal;
-}
-
-OMX_U32 mmalil_video_profile_to_omx(uint32_t profile)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_video_profile_table[i].mmal != MMAL_VIDEO_PROFILE_DUMMY; i++)
-      if(mmal_omx_video_profile_table[i].mmal == profile) break;
-   return mmal_omx_video_profile_table[i].omx;
-}
-
-/*****************************************************************************/
-static struct {
-   uint32_t mmal;
-   OMX_U32 omx;
-   OMX_VIDEO_CODINGTYPE omx_coding;
-} mmal_omx_video_level_table[] =
-{
-   { MMAL_VIDEO_LEVEL_H263_10, OMX_VIDEO_H263Level10,  OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_LEVEL_H263_20, OMX_VIDEO_H263Level20,  OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_LEVEL_H263_30, OMX_VIDEO_H263Level30,  OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_LEVEL_H263_40, OMX_VIDEO_H263Level40,  OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_LEVEL_H263_45, OMX_VIDEO_H263Level45,  OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_LEVEL_H263_50, OMX_VIDEO_H263Level50,  OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_LEVEL_H263_60, OMX_VIDEO_H263Level60,  OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_LEVEL_H263_70, OMX_VIDEO_H263Level70,  OMX_VIDEO_CodingH263},
-   { MMAL_VIDEO_LEVEL_MP4V_0,  OMX_VIDEO_MPEG4Level0,  OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_LEVEL_MP4V_0b, OMX_VIDEO_MPEG4Level0b, OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_LEVEL_MP4V_1,  OMX_VIDEO_MPEG4Level1,  OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_LEVEL_MP4V_2,  OMX_VIDEO_MPEG4Level2,  OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_LEVEL_MP4V_3,  OMX_VIDEO_MPEG4Level3,  OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_LEVEL_MP4V_4,  OMX_VIDEO_MPEG4Level4,  OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_LEVEL_MP4V_4a, OMX_VIDEO_MPEG4Level4a, OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_LEVEL_MP4V_5,  OMX_VIDEO_MPEG4Level5,  OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_LEVEL_MP4V_6,  OMX_VIDEO_MPEG4Level6,  OMX_VIDEO_CodingMPEG4},
-   { MMAL_VIDEO_LEVEL_H264_1,  OMX_VIDEO_AVCLevel1,    OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_1b, OMX_VIDEO_AVCLevel1b,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_11, OMX_VIDEO_AVCLevel11,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_12, OMX_VIDEO_AVCLevel12,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_13, OMX_VIDEO_AVCLevel13,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_2,  OMX_VIDEO_AVCLevel2,    OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_21, OMX_VIDEO_AVCLevel21,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_22, OMX_VIDEO_AVCLevel22,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_3,  OMX_VIDEO_AVCLevel3,    OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_31, OMX_VIDEO_AVCLevel31,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_32, OMX_VIDEO_AVCLevel32,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_4,  OMX_VIDEO_AVCLevel4,    OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_41, OMX_VIDEO_AVCLevel41,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_42, OMX_VIDEO_AVCLevel42,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_5,  OMX_VIDEO_AVCLevel5,    OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_H264_51, OMX_VIDEO_AVCLevel51,   OMX_VIDEO_CodingAVC},
-   { MMAL_VIDEO_LEVEL_DUMMY,   OMX_VIDEO_AVCLevelMax,  OMX_VIDEO_CodingMax},
-};
-
-uint32_t mmalil_omx_video_level_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE coding)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_video_level_table[i].mmal != MMAL_VIDEO_LEVEL_DUMMY; i++)
-      if(mmal_omx_video_level_table[i].omx == level
-         && mmal_omx_video_level_table[i].omx_coding == coding) break;
-   return mmal_omx_video_level_table[i].mmal;
-}
-
-OMX_U32 mmalil_video_level_to_omx(uint32_t level)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_video_level_table[i].mmal != MMAL_VIDEO_LEVEL_DUMMY; i++)
-      if(mmal_omx_video_level_table[i].mmal == level) break;
-   return mmal_omx_video_level_table[i].omx;
-}
-
-/*****************************************************************************/
-static struct {
-   MMAL_VIDEO_RATECONTROL_T mmal;
-   OMX_VIDEO_CONTROLRATETYPE omx;
-} mmal_omx_video_ratecontrol_table[] =
-{
-   { MMAL_VIDEO_RATECONTROL_DEFAULT,              OMX_Video_ControlRateDisable},
-   { MMAL_VIDEO_RATECONTROL_VARIABLE,             OMX_Video_ControlRateVariable},
-   { MMAL_VIDEO_RATECONTROL_CONSTANT,             OMX_Video_ControlRateConstant},
-   { MMAL_VIDEO_RATECONTROL_VARIABLE_SKIP_FRAMES, OMX_Video_ControlRateVariableSkipFrames},
-   { MMAL_VIDEO_RATECONTROL_CONSTANT_SKIP_FRAMES, OMX_Video_ControlRateConstantSkipFrames},
-   { MMAL_VIDEO_RATECONTROL_DUMMY,                OMX_Video_ControlRateMax},
-};
-
-MMAL_VIDEO_RATECONTROL_T mmalil_omx_video_ratecontrol_to_mmal(OMX_VIDEO_CONTROLRATETYPE omx)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_video_ratecontrol_table[i].mmal != MMAL_VIDEO_RATECONTROL_DUMMY; i++)
-      if(mmal_omx_video_ratecontrol_table[i].omx == omx) break;
-   return mmal_omx_video_ratecontrol_table[i].mmal;
-}
-
-OMX_VIDEO_CONTROLRATETYPE mmalil_video_ratecontrol_to_omx(MMAL_VIDEO_RATECONTROL_T mmal)
-{
-   unsigned int i;
-   for(i = 0; mmal_omx_video_ratecontrol_table[i].mmal != MMAL_VIDEO_RATECONTROL_DUMMY; i++)
-      if(mmal_omx_video_ratecontrol_table[i].mmal == mmal) break;
-   return mmal_omx_video_ratecontrol_table[i].omx;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.h
deleted file mode 100644
index e995eab..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_il.h
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_IL_H
-#define MMAL_IL_H
-
-/** \defgroup MmalILUtility MMAL to OMX IL conversion utilities
- * \ingroup MmalUtilities
- *
- * @{
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "interface/vmcs_host/khronos/IL/OMX_Core.h"
-#include "interface/vmcs_host/khronos/IL/OMX_Component.h"
-#include "interface/vmcs_host/khronos/IL/OMX_Video.h"
-#include "interface/vmcs_host/khronos/IL/OMX_Audio.h"
-#include "interface/vmcs_host/khronos/IL/OMX_Broadcom.h"
-
-/** Convert MMAL status codes into OMX error codes.
- *
- * @param status MMAL status code.
- * @return OMX error code.
- */
-OMX_ERRORTYPE mmalil_error_to_omx(MMAL_STATUS_T status);
-
-/** Convert OMX error codes into MMAL status codes.
- *
- * @param error OMX error code.
- * @return MMAL status code.
- */
-MMAL_STATUS_T mmalil_error_to_mmal(OMX_ERRORTYPE error);
-
-/** Convert MMAL buffer header flags into OMX buffer header flags.
- *
- * @param flags OMX buffer header flags.
- * @return MMAL buffer header flags.
- */
-uint32_t mmalil_buffer_flags_to_mmal(OMX_U32 flags);
-
-/** Convert OMX buffer header flags into MMAL buffer header flags.
- *
- * @param flags MMAL buffer header flags.
- * @return OMX buffer header flags.
- */
-OMX_U32 mmalil_buffer_flags_to_omx(uint32_t flags);
-
-/** Convert a MMAL buffer header into an OMX buffer header.
- * Note that only the fields which have a direct mapping between OMX and MMAL are converted.
- *
- * @param omx  Pointer to the destination OMX buffer header.
- * @param mmal Pointer to the source MMAL buffer header.
- */
-void mmalil_buffer_header_to_omx(OMX_BUFFERHEADERTYPE *omx, MMAL_BUFFER_HEADER_T *mmal);
-
-/** Convert an OMX buffer header into a MMAL buffer header.
- *
- * @param mmal Pointer to the destination MMAL buffer header.
- * @param omx  Pointer to the source OMX buffer header.
- */
-void mmalil_buffer_header_to_mmal(MMAL_BUFFER_HEADER_T *mmal, OMX_BUFFERHEADERTYPE *omx);
-
-
-OMX_PORTDOMAINTYPE mmalil_es_type_to_omx_domain(MMAL_ES_TYPE_T type);
-MMAL_ES_TYPE_T mmalil_omx_domain_to_es_type(OMX_PORTDOMAINTYPE domain);
-uint32_t mmalil_omx_audio_coding_to_encoding(OMX_AUDIO_CODINGTYPE coding);
-OMX_AUDIO_CODINGTYPE mmalil_encoding_to_omx_audio_coding(uint32_t encoding);
-uint32_t mmalil_omx_video_coding_to_encoding(OMX_VIDEO_CODINGTYPE coding);
-OMX_VIDEO_CODINGTYPE mmalil_encoding_to_omx_video_coding(uint32_t encoding);
-uint32_t mmalil_omx_image_coding_to_encoding(OMX_IMAGE_CODINGTYPE coding);
-OMX_IMAGE_CODINGTYPE mmalil_encoding_to_omx_image_coding(uint32_t encoding);
-uint32_t mmalil_omx_coding_to_encoding(uint32_t encoding, OMX_PORTDOMAINTYPE domain);
-uint32_t mmalil_omx_color_format_to_encoding(OMX_COLOR_FORMATTYPE coding);
-OMX_COLOR_FORMATTYPE mmalil_encoding_to_omx_color_format(uint32_t encoding);
-uint32_t mmalil_omx_color_space_to_mmal(OMX_COLORSPACETYPE coding);
-OMX_COLORSPACETYPE mmalil_color_space_to_omx(uint32_t coding);
-uint32_t mmalil_omx_video_profile_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE coding);
-OMX_U32 mmalil_video_profile_to_omx(uint32_t profile);
-uint32_t mmalil_omx_video_level_to_mmal(OMX_U32 level, OMX_VIDEO_CODINGTYPE coding);
-OMX_U32 mmalil_video_level_to_omx(uint32_t level);
-MMAL_VIDEO_RATECONTROL_T mmalil_omx_video_ratecontrol_to_mmal(OMX_VIDEO_CONTROLRATETYPE omx);
-OMX_VIDEO_CONTROLRATETYPE mmalil_video_ratecontrol_to_omx(MMAL_VIDEO_RATECONTROL_T mmal);
-
-/** Union of all the OMX_VIDEO/AUDIO_PARAM types */
-typedef union OMX_FORMAT_PARAM_TYPE {
-   OMX_PARAM_U32TYPE common;
-
-   /* Video */
-   OMX_VIDEO_PARAM_AVCTYPE avc;
-   OMX_VIDEO_PARAM_H263TYPE h263;
-   OMX_VIDEO_PARAM_MPEG2TYPE mpeg2;
-   OMX_VIDEO_PARAM_MPEG4TYPE mpeg4;
-   OMX_VIDEO_PARAM_WMVTYPE wmv;
-   OMX_VIDEO_PARAM_RVTYPE rv;
-
-   /* Audio */
-   OMX_AUDIO_PARAM_PCMMODETYPE pcm;
-   OMX_AUDIO_PARAM_MP3TYPE mp3;
-   OMX_AUDIO_PARAM_AACPROFILETYPE aac;
-   OMX_AUDIO_PARAM_VORBISTYPE vorbis;
-   OMX_AUDIO_PARAM_WMATYPE wma;
-   OMX_AUDIO_PARAM_RATYPE ra;
-   OMX_AUDIO_PARAM_SBCTYPE sbc;
-   OMX_AUDIO_PARAM_ADPCMTYPE adpcm;
-   OMX_AUDIO_PARAM_G723TYPE g723;
-   OMX_AUDIO_PARAM_G726TYPE g726;
-   OMX_AUDIO_PARAM_G729TYPE g729;
-   OMX_AUDIO_PARAM_AMRTYPE amr;
-   OMX_AUDIO_PARAM_GSMFRTYPE gsmfr;
-   OMX_AUDIO_PARAM_GSMHRTYPE gsmhr;
-   OMX_AUDIO_PARAM_GSMEFRTYPE gsmefr;
-   OMX_AUDIO_PARAM_TDMAFRTYPE tdmafr;
-   OMX_AUDIO_PARAM_TDMAEFRTYPE tdmaefr;
-   OMX_AUDIO_PARAM_PDCFRTYPE pdcfr;
-   OMX_AUDIO_PARAM_PDCEFRTYPE pdcefr;
-   OMX_AUDIO_PARAM_PDCHRTYPE pdchr;
-   OMX_AUDIO_PARAM_QCELP8TYPE qcelp8;
-   OMX_AUDIO_PARAM_QCELP13TYPE qcelp13;
-   OMX_AUDIO_PARAM_EVRCTYPE evrc;
-   OMX_AUDIO_PARAM_SMVTYPE smv;
-   OMX_AUDIO_PARAM_MIDITYPE midi;
-
-} OMX_FORMAT_PARAM_TYPE;
-
-/** Get the OMX_IndexParamAudio index corresponding to a specified audio coding type.
- *
- * @param coding Audio coding type.
- * @param size  Pointer used to return the size of the parameter.
- *
- * @return OMX index or 0 if no match was found.
- */
-OMX_INDEXTYPE mmalil_omx_audio_param_index(OMX_AUDIO_CODINGTYPE coding, OMX_U32 *size);
-
-/** Convert an OMX_IndexParamAudio into a MMAL elementary stream format.
- *
- * @param format Format structure to update.
- * @param coding Audio coding type.
- * @param param  Source OMX_IndexParamAudio structure.
- *
- * @return The MMAL encoding if a match was found or MMAL_ENCODING_UNKNOWN otherwise.
- */
-MMAL_FOURCC_T mmalil_omx_audio_param_to_format(MMAL_ES_FORMAT_T *format,
-   OMX_AUDIO_CODINGTYPE coding, OMX_FORMAT_PARAM_TYPE *param);
-
-/** Convert a MMAL elementary stream format into a OMX_IndexParamAudio structure.
- *
- * @param param  OMX_IndexParamAudio structure to update.
- * @param param_index returns the OMX_IndexParamAudio index corresponding to the format.
- * @param format Source format structure.
- *
- * @return The OMX aduio coding type if a match was found or OMX_AUDIO_CodingUnused otherwise.
- */
-OMX_AUDIO_CODINGTYPE mmalil_format_to_omx_audio_param(OMX_FORMAT_PARAM_TYPE *param,
-   OMX_INDEXTYPE *param_index, MMAL_ES_FORMAT_T *format);
-
-#ifdef __cplusplus
-}
-#endif
-
-/** @} */
-
-#endif /* MMAL_IL_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.c
deleted file mode 100644
index d68db16..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.c
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "interface/vcos/vcos.h"
-#include "interface/mmal/util/mmal_list.h"
-
-
-/* Private list context */
-typedef struct MMAL_LIST_PRIVATE_T
-{
-   MMAL_LIST_T list;    /* must be first */
-   VCOS_MUTEX_T lock;
-} MMAL_LIST_PRIVATE_T;
-
-
-/* Lock the list. */
-static inline void mmal_list_lock(MMAL_LIST_T *list)
-{
-   vcos_mutex_lock(&((MMAL_LIST_PRIVATE_T*)list)->lock);
-}
-
-/* Unlock the list. */
-static inline void mmal_list_unlock(MMAL_LIST_T *list)
-{
-   vcos_mutex_unlock(&((MMAL_LIST_PRIVATE_T*)list)->lock);
-}
-
-/* Create a new linked list. */
-MMAL_LIST_T* mmal_list_create(void)
-{
-   MMAL_LIST_PRIVATE_T *private;
-
-   private = vcos_malloc(sizeof(MMAL_LIST_PRIVATE_T), "mmal-list");
-   if (private == NULL)
-      goto error;
-
-   if (vcos_mutex_create(&private->lock, "mmal-list lock") != VCOS_SUCCESS)
-      goto error;
-
-   private->list.first = NULL;
-   private->list.last = NULL;
-   private->list.length = 0;
-
-   return &private->list;
-
-error:
-   vcos_free(private);
-   return NULL;
-}
-
-/* Destroy a linked list. */
-void mmal_list_destroy(MMAL_LIST_T *list)
-{
-   MMAL_LIST_PRIVATE_T *private = (MMAL_LIST_PRIVATE_T*)list;
-
-   vcos_mutex_delete(&private->lock);
-   vcos_free(private);
-}
-
-/* Remove the last element in the list. */
-MMAL_LIST_ELEMENT_T* mmal_list_pop_back(MMAL_LIST_T *list)
-{
-   MMAL_LIST_ELEMENT_T *element;
-
-   mmal_list_lock(list);
-
-   element = list->last;
-   if (element != NULL)
-   {
-      list->length--;
-
-      list->last = element->prev;
-      if (list->last)
-         list->last->next = NULL;
-      else
-         list->first = NULL; /* list is now empty */
-
-      element->prev = NULL;
-      element->next = NULL;
-   }
-
-   mmal_list_unlock(list);
-
-   return element;
-}
-
-/* Remove the first element in the list. */
-MMAL_LIST_ELEMENT_T* mmal_list_pop_front(MMAL_LIST_T *list)
-{
-   MMAL_LIST_ELEMENT_T *element;
-
-   mmal_list_lock(list);
-
-   element = list->first;
-   if (element != NULL)
-   {
-      list->length--;
-
-      list->first = element->next;
-      if (list->first)
-         list->first->prev = NULL;
-      else
-         list->last = NULL; /* list is now empty */
-
-      element->prev = NULL;
-      element->next = NULL;
-   }
-
-   mmal_list_unlock(list);
-
-   return element;
-}
-
-/* Add an element to the front of the list. */
-void mmal_list_push_front(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element)
-{
-   mmal_list_lock(list);
-
-   list->length++;
-
-   element->prev = NULL;
-   element->next = list->first;
-
-   if (list->first)
-      list->first->prev = element;
-   else
-      list->last = element; /* list was empty */
-
-   list->first = element;
-
-   mmal_list_unlock(list);
-}
-
-/* Add an element to the back of the list. */
-void mmal_list_push_back(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element)
-{
-   mmal_list_lock(list);
-
-   list->length++;
-
-   element->next = NULL;
-   element->prev = list->last;
-
-   if (list->last)
-      list->last->next = element;
-   else
-      list->first = element; /* list was empty */
-
-   list->last = element;
-
-   mmal_list_unlock(list);
-}
-
-/* Insert an element into the list. */
-void mmal_list_insert(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element, MMAL_LIST_COMPARE_T compare)
-{
-   MMAL_LIST_ELEMENT_T *cur;
-
-   mmal_list_lock(list);
-
-   if (list->first == NULL)
-   {
-      /* List empty */
-      mmal_list_unlock(list);
-      mmal_list_push_front(list, element);
-      return;
-   }
-
-   cur = list->first;
-   while (cur)
-   {
-      if (compare(element, cur))
-      {
-         /* Slot found! */
-         list->length++;
-         if (cur == list->first)
-            list->first = element;
-         else
-            cur->prev->next = element;
-         element->prev = cur->prev;
-         element->next = cur;
-         cur->prev = element;
-         mmal_list_unlock(list);
-         return;
-      }
-
-      cur = cur->next;
-   }
-
-   /* If we get here, none of the existing elements are greater
-    * than the new on, so just add it to the back of the list */
-   mmal_list_unlock(list);
-   mmal_list_push_back(list, element);
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.h
deleted file mode 100644
index 967cc7b..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_list.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_LIST_H
-#define MMAL_LIST_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** \defgroup MmalList Generic Linked List
- * This provides a thread-safe implementation of a linked list which can be used
- * with any data type. */
-/* @{ */
-
-/** Single element in the list */
-typedef struct MMAL_LIST_ELEMENT_T
-{
-   struct MMAL_LIST_ELEMENT_T *next;
-   struct MMAL_LIST_ELEMENT_T *prev;
-} MMAL_LIST_ELEMENT_T;
-
-/** Linked list type.
- * Clients shouldn't modify this directly. Use the provided API functions to
- * add new elements. The public members are only for debug purposes.
- * */
-typedef struct MMAL_LIST_T
-{
-   unsigned int length;         /**< Number of elements in the list (read-only) */
-   MMAL_LIST_ELEMENT_T *first;  /**< First element in the list (read-only) */
-   MMAL_LIST_ELEMENT_T *last;   /**< Last element in the list (read-only) */
-} MMAL_LIST_T;
-
-/** Create a new linked list.
- *
- * @return Pointer to new queue (NULL on failure).
- */
-MMAL_LIST_T* mmal_list_create(void);
-
-/** Destroy a linked list.
- *
- * @param list List to destroy
- */
-void mmal_list_destroy(MMAL_LIST_T *list);
-
-/** Remove the last element in the list.
- *
- * @param list    List to remove from
- *
- * @return Pointer to the last element (or NULL if empty)
- */
-MMAL_LIST_ELEMENT_T* mmal_list_pop_back(MMAL_LIST_T *list);
-
-/** Remove the first element in the list.
- *
- * @param list    List to remove from
- *
- * @return Pointer to the first element (or NULL if empty)
- */
-MMAL_LIST_ELEMENT_T* mmal_list_pop_front(MMAL_LIST_T *list);
-
-/** Add an element to the front of the list.
- *
- * @param list    List to add to
- * @param element The element to add
- */
-void mmal_list_push_front(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element);
-
-/** Add an element to the back of the list.
- *
- * @param list    List to add to
- * @param element The element to add
- */
-void mmal_list_push_back(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element);
-
-/** List comparison function.
- * This is supplied by a client when inserting an element in
- * the middle of the list. The list will always insert a smaller
- * element in front of a larger element.
- *
- * @return TRUE:  lhs <  rhs
- *         FALSE: lhs >= rhs
- */
-typedef int (*MMAL_LIST_COMPARE_T)(MMAL_LIST_ELEMENT_T *lhs, MMAL_LIST_ELEMENT_T *rhs);
-
-/** Insert an element into the list.
- * The location where the element is inserted is determined using
- * the supplied comparison function. Smaller elements are inserted
- * in front of larger elements.
- *
- * @param list    List to add to
- * @param element The element to insert
- * @param compare Comparison function supplied by the client
- */
-void mmal_list_insert(MMAL_LIST_T *list, MMAL_LIST_ELEMENT_T *element, MMAL_LIST_COMPARE_T compare);
-
-/* @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_LIST_H */
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.c
deleted file mode 100644
index f470210..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.c
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "mmal_param_convert.h"
-#include <stdlib.h>
-#include <stdio.h>
-
-typedef struct string_pair_t
-{
-   const char *string;
-   int value;
-} string_pair_t;
-
-static MMAL_STATUS_T parse_enum(int *dest, string_pair_t *pairs, size_t n_pairs, const char *str)
-{
-   size_t i;
-   for (i=0; i<n_pairs; i++)
-   {
-      if (vcos_strcasecmp(str, pairs[i].string) == 0)
-      {
-         *dest = pairs[i].value;
-         return MMAL_SUCCESS;
-      }
-      i++;
-   }
-   return MMAL_EINVAL;
-}
-
-MMAL_STATUS_T mmal_parse_video_size(uint32_t *w, uint32_t *h, const char *str)
-{
-   static struct {
-      const char *name;
-      uint32_t width;
-      uint32_t height;
-   } sizes[] = {
-      { "1080p", 1920, 1080 },
-      { "720p",  1280,  720 },
-      { "vga",    640,  480 },
-      { "wvga",   800,  480 },
-      { "cif",    352,  288 },
-      { "qcif",   352/2, 288/2 },
-   };
-   size_t i;
-   for (i=0; i<vcos_countof(sizes); i++)
-   {
-      if (vcos_strcasecmp(str, sizes[i].name) == 0)
-      {
-         *w = sizes[i].width;
-         *h = sizes[i].height;
-         return MMAL_SUCCESS;
-      }
-   }
-   return MMAL_EINVAL;
-}
-
-MMAL_STATUS_T mmal_parse_rational(MMAL_RATIONAL_T *dest, const char *str)
-{
-   MMAL_STATUS_T ret;
-   char *endptr;
-   long num, den = 1;
-   num = strtoul(str, &endptr, 0);
-   if (endptr[0] == '\0')
-   {
-      /* that's it */
-      ret = MMAL_SUCCESS;
-   }
-   else if (endptr[0] == '/')
-   {
-      den = strtoul(endptr+1, &endptr, 0);
-      if (endptr[0] == '\0')
-         ret = MMAL_SUCCESS;
-      else
-         ret = MMAL_EINVAL;
-   }
-   else
-   {
-      ret = MMAL_EINVAL;
-   }
-   dest->num = num;
-   dest->den = den;
-   return ret;
-}
-
-MMAL_STATUS_T mmal_parse_int(int *dest, const char *str)
-{
-   char *endptr;
-   long i = strtol(str, &endptr, 0);
-   if (endptr[0] == '\0')
-   {
-      *dest = i;
-      return MMAL_SUCCESS;
-   }
-   else
-   {
-      return MMAL_EINVAL;
-   }
-}
-
-MMAL_STATUS_T mmal_parse_uint(unsigned int *dest, const char *str)
-{
-   char *endptr;
-   unsigned long i = strtoul(str, &endptr, 0);
-   if (endptr[0] == '\0')
-   {
-      *dest = i;
-      return MMAL_SUCCESS;
-   }
-   else
-   {
-      return MMAL_EINVAL;
-   }
-}
-
-MMAL_STATUS_T mmal_parse_video_codec(uint32_t *dest, const char *str)
-{
-   static string_pair_t video_codec_enums[] = {
-      { "h264",  MMAL_ENCODING_H264 },
-      { "h263",  MMAL_ENCODING_H263 },
-      { "mpeg4", MMAL_ENCODING_MP4V },
-      { "mpeg2", MMAL_ENCODING_MP2V },
-      { "vp8",   MMAL_ENCODING_VP8 },
-      { "vp7",   MMAL_ENCODING_VP7 },
-      { "vp6",   MMAL_ENCODING_VP6 },
-   };
-   int i = 0;
-   MMAL_STATUS_T ret;
-
-   ret = parse_enum(&i, video_codec_enums, vcos_countof(video_codec_enums), str);
-   *dest = i;
-   return ret;
-}
-
-MMAL_STATUS_T mmal_parse_geometry(MMAL_RECT_T *dest, const char *str)
-{
-   MMAL_STATUS_T ret;
-   uint32_t w, h, x, y;
-   x = y = w = h = 0;
-   /* coverity[secure_coding] */
-   if (sscanf(str, "%d*%d+%d+%d", &w,&h,&x,&y) == 4 ||
-       sscanf(str, "%d*%d", &w,&h) == 2)
-   {
-      dest->x = x;
-      dest->y = y;
-      dest->width = w;
-      dest->height = h;
-      ret = MMAL_SUCCESS;
-   }
-   else
-   {
-      ret = MMAL_EINVAL;
-   }
-   return ret;
-}
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.h
deleted file mode 100644
index 1d653c2..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_param_convert.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/** \file
- * Support for setting/getting parameters as string values.
- */
-
-#ifndef MMAL_PARAM_CONVERT_H
-#define MMAL_PARAM_CONVERT_H
-
-#include "interface/mmal/mmal.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Parse a video size. e.g. "1080p" gives 1920x1080.
- *
- * @param w width result
- * @param h height result
- * @param str string to convert
- * @return MMAL_SUCCESS or error code
- */
-MMAL_STATUS_T mmal_parse_video_size(uint32_t *w, uint32_t *h, const char *str);
-
-/** Parse a rational number. e.g. "30000/1001", "30", etc.
- * @param dest filled in with result
- * @param str string to convert
- * @return MMAL_SUCCESS or error code
- */
-MMAL_STATUS_T mmal_parse_rational(MMAL_RATIONAL_T *dest, const char *str);
-
-/** Parse an integer, e.g. -10, 0x1A, etc.
- * @param dest filled in with result
- * @param str string to convert
- * @return MMAL_SUCCESS or error code
- */
-MMAL_STATUS_T mmal_parse_int(int *dest, const char *str);
-
-/** Parse an unsigned integer, e.g. 10, 0x1A, etc.
- * @param dest filled in with result
- * @param str string to convert
- * @return MMAL_SUCCESS or error code
- */
-MMAL_STATUS_T mmal_parse_uint(unsigned int *dest, const char *str);
-
-/** Parse a geometry for a rectangle
- *
- * e.g. 100*100+50+75
- * or   200*150
- * @param dest filled in with result
- * @param str string to convert
- * @return MMAL_SUCCESS or error code
- */
-MMAL_STATUS_T mmal_parse_geometry(MMAL_RECT_T *dest, const char *str);
-
-/** Parse a video codec name (something that can be encoded/decoded)
- * @param str string to convert
- * @param dest filled in with result
- * @return MMAL_SUCCESS or error code
- */
-MMAL_STATUS_T mmal_parse_video_codec(uint32_t *dest, const char *str);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.c
deleted file mode 100644
index fa10dd6..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.c
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "../mmal.h"
-#include "mmal_encodings.h"
-#include "mmal_util.h"
-#include "mmal_logging.h"
-#include <string.h>
-#include <stdio.h>
-
-#define STATUS_TO_STR(x) { MMAL_##x, #x }
-
-static struct {
-   MMAL_STATUS_T status;
-   const char *str;
-} status_to_string_map[] =
-{
-   STATUS_TO_STR(SUCCESS),
-   STATUS_TO_STR(ENOMEM),
-   STATUS_TO_STR(ENOSPC),
-   STATUS_TO_STR(EINVAL),
-   STATUS_TO_STR(ENOSYS),
-   STATUS_TO_STR(ENOENT),
-   STATUS_TO_STR(ENXIO),
-   STATUS_TO_STR(EIO),
-   STATUS_TO_STR(ESPIPE),
-   STATUS_TO_STR(ECORRUPT),
-   STATUS_TO_STR(ENOTREADY),
-   STATUS_TO_STR(ECONFIG),
-   {0, 0}
-};
-
-const char *mmal_status_to_string(MMAL_STATUS_T status)
-{
-   unsigned i;
-
-   for (i=0; status_to_string_map[i].str; i++)
-      if (status_to_string_map[i].status == status)
-         break;
-
-   return status_to_string_map[i].str ? status_to_string_map[i].str : "UNKNOWN";
-}
-
-static struct {
-   uint32_t encoding;
-   uint32_t pitch_num;
-   uint32_t pitch_den;
-} pixel_pitch[] =
-{
-   {MMAL_ENCODING_I420,  1, 1},
-   {MMAL_ENCODING_YV12,  1, 1},
-   {MMAL_ENCODING_I422,  1, 1},
-   {MMAL_ENCODING_NV21,  1, 1},
-   {MMAL_ENCODING_NV12,  1, 1},
-   {MMAL_ENCODING_ARGB,  4, 1},
-   {MMAL_ENCODING_RGBA,  4, 1},
-   {MMAL_ENCODING_RGB32, 4, 1},
-   {MMAL_ENCODING_ABGR,  4, 1},
-   {MMAL_ENCODING_BGRA,  4, 1},
-   {MMAL_ENCODING_BGR32, 4, 1},
-   {MMAL_ENCODING_RGB16, 2, 1},
-   {MMAL_ENCODING_RGB24, 3, 1},
-   {MMAL_ENCODING_BGR16, 2, 1},
-   {MMAL_ENCODING_BGR24, 3, 1},
-   /* {MMAL_ENCODING_YUVUV128, 1, 1}, That's a special case which must not be included */
-   {MMAL_ENCODING_UNKNOWN, 0, 0}
-};
-
-uint32_t mmal_encoding_stride_to_width(uint32_t encoding, uint32_t stride)
-{
-   unsigned int i;
-
-   for(i = 0; pixel_pitch[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(pixel_pitch[i].encoding == encoding) break;
-
-   if(pixel_pitch[i].encoding == MMAL_ENCODING_UNKNOWN)
-      return 0;
-
-   return pixel_pitch[i].pitch_den * stride / pixel_pitch[i].pitch_num;
-}
-
-uint32_t mmal_encoding_width_to_stride(uint32_t encoding, uint32_t width)
-{
-   unsigned int i;
-
-   for(i = 0; pixel_pitch[i].encoding != MMAL_ENCODING_UNKNOWN; i++)
-      if(pixel_pitch[i].encoding == encoding) break;
-
-   if(pixel_pitch[i].encoding == MMAL_ENCODING_UNKNOWN)
-      return 0;
-
-   return pixel_pitch[i].pitch_num * width / pixel_pitch[i].pitch_den;
-}
-
-const char* mmal_port_type_to_string(MMAL_PORT_TYPE_T type)
-{
-   const char *str;
-
-   switch (type)
-   {
-   case MMAL_PORT_TYPE_INPUT:   str = "in";  break;
-   case MMAL_PORT_TYPE_OUTPUT:  str = "out"; break;
-   case MMAL_PORT_TYPE_CLOCK:   str = "clk"; break;
-   case MMAL_PORT_TYPE_CONTROL: str = "ctr"; break;
-   default:                     str = "invalid"; break;
-   }
-
-   return str;
-}
-
-MMAL_PARAMETER_HEADER_T *mmal_port_parameter_alloc_get(MMAL_PORT_T *port,
-   uint32_t id, uint32_t size, MMAL_STATUS_T *p_status)
-{
-   MMAL_PARAMETER_HEADER_T *param = NULL;
-   MMAL_STATUS_T status = MMAL_ENOSYS;
-
-   if (size < sizeof(MMAL_PARAMETER_HEADER_T))
-      size = sizeof(MMAL_PARAMETER_HEADER_T);
-
-   if ((param = vcos_calloc(1, size, "mmal_port_param_get")) == NULL)
-   {
-      status = MMAL_ENOMEM;
-      goto error;
-   }
-
-   param->id = id;
-   param->size = size;
-
-   if ((status = mmal_port_parameter_get(port, param)) == MMAL_ENOSPC)
-   {
-      /* We need to reallocate to get enough space for all parameter data */
-      size = param->size;
-      vcos_free(param);
-      if ((param = vcos_calloc(1, size, "mmal_port_param_get")) == NULL)
-      {
-         status = MMAL_ENOMEM;
-         goto error;
-      }
-
-      /* Now retrieve it again */
-      param->id = id;
-      param->size = size;
-      status = mmal_port_parameter_get(port, param);
-   }
-
-   if (status != MMAL_SUCCESS)
-      goto error;
-
-end:
-   if (p_status) *p_status = status;
-   return param;
-error:
-   if (param) vcos_free(param);
-   param = NULL;
-   goto end;
-}
-
-void mmal_port_parameter_free(MMAL_PARAMETER_HEADER_T *param)
-{
-   vcos_free(param);
-}
-
-/** Copy buffer header metadata from source to dest
- */
-void mmal_buffer_header_copy_header(MMAL_BUFFER_HEADER_T *dest, const MMAL_BUFFER_HEADER_T *src)
-{
-   dest->cmd    = src->cmd;
-   dest->offset = src->offset;
-   dest->length = src->length;
-   dest->flags  = src->flags;
-   dest->pts    = src->pts;
-   dest->dts    = src->dts;
-   *dest->type = *src->type;
-}
-
-/** Create a pool of MMAL_BUFFER_HEADER_T */
-MMAL_POOL_T *mmal_port_pool_create(MMAL_PORT_T *port, unsigned int headers, uint32_t payload_size)
-{
-   if (!port || !port->priv)
-      return NULL;
-
-   LOG_TRACE("%s(%i:%i) port %p, headers %u, size %i", port->component->name,
-             (int)port->type, (int)port->index, port, headers, (int)payload_size);
-
-   /* Create a pool and ask the port for some memory */
-   return mmal_pool_create_with_allocator(headers, payload_size, (void *)port,
-                                          (mmal_pool_allocator_alloc_t)mmal_port_payload_alloc,
-                                          (mmal_pool_allocator_free_t)mmal_port_payload_free);
-}
-
-/** Destroy a pool of MMAL_BUFFER_HEADER_T */
-void mmal_port_pool_destroy(MMAL_PORT_T *port, MMAL_POOL_T *pool)
-{
-   if (!port || !port->priv || !pool)
-      return;
-
-   LOG_TRACE("%s(%i:%i) port %p, pool %p", port->component->name,
-             (int)port->type, (int)port->index, port, pool);
-
-   if (!vcos_verify(!port->is_enabled))
-   {
-      LOG_ERROR("port %p, pool %p destroyed while port enabled", port, pool);
-      mmal_port_disable(port);
-   }
-
-   mmal_pool_destroy(pool);
-}
-
-/*****************************************************************************/
-void mmal_log_dump_port(MMAL_PORT_T *port)
-{
-   if (!port)
-      return;
-
-   LOG_DEBUG("%s(%p)", port->name, port);
-
-   mmal_log_dump_format(port->format);
-
-   LOG_DEBUG(" buffers num: %i(opt %i, min %i), size: %i(opt %i, min: %i), align: %i",
-            port->buffer_num, port->buffer_num_recommended, port->buffer_num_min,
-            port->buffer_size, port->buffer_size_recommended, port->buffer_size_min,
-            port->buffer_alignment_min);
-}
-
-/*****************************************************************************/
-void mmal_log_dump_format(MMAL_ES_FORMAT_T *format)
-{
-   const char *name_type;
-
-   if (!format)
-      return;
-
-   switch(format->type)
-   {
-   case MMAL_ES_TYPE_AUDIO: name_type = "audio"; break;
-   case MMAL_ES_TYPE_VIDEO: name_type = "video"; break;
-   case MMAL_ES_TYPE_SUBPICTURE: name_type = "subpicture"; break;
-   default: name_type = "unknown"; break;
-   }
-
-   LOG_DEBUG("type: %s, fourcc: %4.4s", name_type, (char *)&format->encoding);
-   LOG_DEBUG(" bitrate: %i, framed: %i", format->bitrate,
-            !!(format->flags & MMAL_ES_FORMAT_FLAG_FRAMED));
-   LOG_DEBUG(" extra data: %i, %p", format->extradata_size, format->extradata);
-   switch(format->type)
-   {
-   case MMAL_ES_TYPE_AUDIO:
-      LOG_DEBUG(" samplerate: %i, channels: %i, bps: %i, block align: %i",
-               format->es->audio.sample_rate, format->es->audio.channels,
-               format->es->audio.bits_per_sample, format->es->audio.block_align);
-      break;
-
-   case MMAL_ES_TYPE_VIDEO:
-      LOG_DEBUG(" width: %i, height: %i, (%i,%i,%i,%i)",
-               format->es->video.width, format->es->video.height,
-               format->es->video.crop.x, format->es->video.crop.y,
-               format->es->video.crop.width, format->es->video.crop.height);
-      LOG_DEBUG(" pixel aspect ratio: %i/%i, frame rate: %i/%i",
-               format->es->video.par.num, format->es->video.par.den,
-               format->es->video.frame_rate.num, format->es->video.frame_rate.den);
-      break;
-
-   case MMAL_ES_TYPE_SUBPICTURE:
-      break;
-
-   default: break;
-   }
-}
-
-MMAL_PORT_T *mmal_util_get_port(MMAL_COMPONENT_T *comp, MMAL_PORT_TYPE_T type, unsigned index)
-{
-   unsigned num;
-   MMAL_PORT_T **list;
-
-   switch (type)
-   {
-   case MMAL_PORT_TYPE_INPUT:
-      num = comp->input_num;
-      list = comp->input;
-      break;
-
-   case MMAL_PORT_TYPE_OUTPUT:
-      num = comp->output_num;
-      list = comp->output;
-      break;
-
-   case MMAL_PORT_TYPE_CLOCK:
-      num = comp->clock_num;
-      list = comp->clock;
-      break;
-
-   case MMAL_PORT_TYPE_CONTROL:
-      num = 1;
-      list = &comp->control;
-      break;
-
-   default:
-      vcos_assert(0);
-      return NULL;
-   }
-   if (index < num)
-      return list[index];
-   else
-      return NULL;
-}
-
-char *mmal_4cc_to_string(char *buf, size_t len, uint32_t fourcc)
-{
-   char *src = (char*)&fourcc;
-   vcos_assert(len >= 5);
-   if (len < 5)
-   {
-      buf[0] = '\0';
-   }
-   else if (fourcc)
-   {
-      memcpy(buf, src, 4);
-      buf[4] = '\0';
-   }
-   else
-   {
-      snprintf(buf, len, "<0>");
-   }
-   return buf;
-}
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.h
deleted file mode 100644
index 0cbb259..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_UTIL_H
-#define MMAL_UTIL_H
-
-#include "../mmal.h"
-
-/** \defgroup MmalUtilities Utility functions
- * The utility functions provide helpers for common functionality that is not part
- * of the core MMAL API.
- * @{
- */
-
-/** Offset in bytes of FIELD in TYPE. */
-#define MMAL_OFFSET(TYPE, FIELD) ((size_t)((uint8_t *)&((TYPE*)0)->FIELD - (uint8_t *)0))
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Convert a status to a statically-allocated string.
- *
- * @param status The MMAL status code.
- * @return A C string describing the status code.
- */
-const char *mmal_status_to_string(MMAL_STATUS_T status);
-
-/** Convert stride to pixel width for a given pixel encoding.
- *
- * @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
- * @param stride The stride in bytes.
- * @return The width in pixels.
- */
-uint32_t mmal_encoding_stride_to_width(uint32_t encoding, uint32_t stride);
-
-/** Convert pixel width to stride for a given pixel encoding
- *
- * @param encoding The pixel encoding (such as one of the \ref MmalEncodings "pre-defined encodings")
- * @param width The width in pixels.
- * @return The stride in bytes.
- */
-uint32_t mmal_encoding_width_to_stride(uint32_t encoding, uint32_t width);
-
-/** Convert a port type to a string.
- *
- * @param type The MMAL port type.
- * @return A NULL-terminated string describing the port type.
- */
-const char* mmal_port_type_to_string(MMAL_PORT_TYPE_T type);
-
-/** Get a parameter from a port allocating the required amount of memory
- * for the parameter (i.e. for variable length parameters like URI or arrays).
- * The size field will be set on output to the actual size of the
- * parameter allocated and retrieved.
- *
- * The pointer returned must be released by a call to \ref mmal_port_parameter_free().
- *
- * @param port port to send request to
- * @param id parameter id
- * @param size initial size hint for allocation (can be 0)
- * @param status status of the parameter get operation (can be 0)
- * @return pointer to the header of the parameter or NULL on failure.
- */
-MMAL_PARAMETER_HEADER_T *mmal_port_parameter_alloc_get(MMAL_PORT_T *port,
-   uint32_t id, uint32_t size, MMAL_STATUS_T *status);
-
-/** Free a parameter structure previously allocated via
- * \ref mmal_port_parameter_alloc_get().
- *
- * @param param pointer to header of the parameter
- */
-void mmal_port_parameter_free(MMAL_PARAMETER_HEADER_T *param);
-
-/** Copy buffer header metadata from source to destination.
- *
- * @param dest The destination buffer header.
- * @param src  The source buffer header.
- */
-void mmal_buffer_header_copy_header(MMAL_BUFFER_HEADER_T *dest, const MMAL_BUFFER_HEADER_T *src);
-
-/** Create a pool of MMAL_BUFFER_HEADER_T associated with a specific port.
- * This allows a client to allocate memory for the payload buffers based on the preferences
- * of a port. This for instance will allow the port to allocate memory which can be shared
- * between the host processor and videocore.
- * After allocation, all allocated buffer headers will have been added to the queue.
- *
- * It is valid to create a pool with no buffer headers, or with zero size payload buffers.
- * The mmal_pool_resize() function can be used to increase or decrease the number of buffer
- * headers, or the size of the payload buffers, after creation of the pool.
- *
- * @param port         Port responsible for creating the pool.
- * @param headers      Number of buffers which will be allocated with the pool.
- * @param payload_size Size of the payload buffer which will be allocated in
- *                     each of the buffer headers.
- * @return Pointer to the newly created pool or NULL on failure.
- */
-MMAL_POOL_T *mmal_port_pool_create(MMAL_PORT_T *port,
-   unsigned int headers, uint32_t payload_size);
-
-/** Destroy a pool of MMAL_BUFFER_HEADER_T associated with a specific port.
- * This will also deallocate all of the memory which was allocated when creating or
- * resizing the pool.
- *
- * @param port  Pointer to the port responsible for creating the pool.
- * @param pool  Pointer to the pool to be destroyed.
- */
-void mmal_port_pool_destroy(MMAL_PORT_T *port, MMAL_POOL_T *pool);
-
-/** Log the content of a \ref MMAL_PORT_T structure.
- *
- * @param port  Pointer to the port to dump.
- */
-void mmal_log_dump_port(MMAL_PORT_T *port);
-
-/** Log the content of a \ref MMAL_ES_FORMAT_T structure.
- *
- * @param format  Pointer to the format to dump.
- */
-void mmal_log_dump_format(MMAL_ES_FORMAT_T *format);
-
-/** Return the nth port.
- *
- * @param comp   component to query
- * @param index  port index
- * @param type   port type
- *
- * @return port or NULL if not found
- */
-MMAL_PORT_T *mmal_util_get_port(MMAL_COMPONENT_T *comp, MMAL_PORT_TYPE_T type, unsigned index);
-
-/** Convert a 4cc into a string.
- *
- * @param buf    Destination for result
- * @param len    Size of result buffer
- * @param fourcc 4cc to be converted
- * @return converted string (buf)
- *
- */
-char *mmal_4cc_to_string(char *buf, size_t len, uint32_t fourcc);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-/** @} */
-
-#endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.c
deleted file mode 100644
index 6e24791..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.c
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal_util_params.h"
-
-/** Helper function to set the value of a boolean parameter */
-MMAL_STATUS_T mmal_port_parameter_set_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T value)
-{
-   MMAL_PARAMETER_BOOLEAN_T param = {{id, sizeof(param)}, value};
-   return mmal_port_parameter_set(port, &param.hdr);
-}
-
-/** Helper function to get the value of a boolean parameter */
-MMAL_STATUS_T mmal_port_parameter_get_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T *value)
-{
-   MMAL_PARAMETER_BOOLEAN_T param = {{id, sizeof(param)}, 0};
-   // coverity[overrun-buffer-val] Structure accessed correctly via size field
-   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
-   if (status == MMAL_SUCCESS)
-      *value = param.enable;
-   return status;
-}
-
-/** Helper function to set the value of a 64 bits unsigned integer parameter */
-MMAL_STATUS_T mmal_port_parameter_set_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t value)
-{
-   MMAL_PARAMETER_UINT64_T param = {{id, sizeof(param)}, value};
-   return mmal_port_parameter_set(port, &param.hdr);
-}
-
-/** Helper function to get the value of a 64 bits unsigned integer parameter */
-MMAL_STATUS_T mmal_port_parameter_get_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t *value)
-{
-   MMAL_PARAMETER_UINT64_T param = {{id, sizeof(param)}, 0LL};
-   // coverity[overrun-buffer-val] Structure accessed correctly via size field
-   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
-   if (status == MMAL_SUCCESS)
-      *value = param.value;
-   return status;
-}
-
-/** Helper function to set the value of a 64 bits signed integer parameter */
-MMAL_STATUS_T mmal_port_parameter_set_int64(MMAL_PORT_T *port, uint32_t id, int64_t value)
-{
-   MMAL_PARAMETER_INT64_T param = {{id, sizeof(param)}, value};
-   return mmal_port_parameter_set(port, &param.hdr);
-}
-
-/** Helper function to get the value of a 64 bits signed integer parameter */
-MMAL_STATUS_T mmal_port_parameter_get_int64(MMAL_PORT_T *port, uint32_t id, int64_t *value)
-{
-   MMAL_PARAMETER_INT64_T param = {{id, sizeof(param)}, 0LL};
-   // coverity[overrun-buffer-val] Structure accessed correctly via size field
-   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
-   if (status == MMAL_SUCCESS)
-      *value = param.value;
-   return status;
-}
-
-/** Helper function to set the value of a 32 bits unsigned integer parameter */
-MMAL_STATUS_T mmal_port_parameter_set_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t value)
-{
-   MMAL_PARAMETER_UINT32_T param = {{id, sizeof(param)}, value};
-   return mmal_port_parameter_set(port, &param.hdr);
-}
-
-/** Helper function to get the value of a 32 bits unsigned integer parameter */
-MMAL_STATUS_T mmal_port_parameter_get_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t *value)
-{
-   MMAL_PARAMETER_UINT32_T param = {{id, sizeof(param)}, 0};
-   // coverity[overrun-buffer-val] Structure accessed correctly via size field
-   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
-   if (status == MMAL_SUCCESS)
-      *value = param.value;
-   return status;
-}
-
-/** Helper function to set the value of a 32 bits signed integer parameter */
-MMAL_STATUS_T mmal_port_parameter_set_int32(MMAL_PORT_T *port, uint32_t id, int32_t value)
-{
-   MMAL_PARAMETER_INT32_T param = {{id, sizeof(param)}, value};
-   return mmal_port_parameter_set(port, &param.hdr);
-}
-
-/** Helper function to get the value of a 32 bits signed integer parameter */
-MMAL_STATUS_T mmal_port_parameter_get_int32(MMAL_PORT_T *port, uint32_t id, int32_t *value)
-{
-   MMAL_PARAMETER_INT32_T param = {{id, sizeof(param)}, 0};
-   // coverity[overrun-buffer-val] Structure accessed correctly via size field
-   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
-   if (status == MMAL_SUCCESS)
-      *value = param.value;
-   return status;
-}
-
-/** Helper function to set the value of a rational parameter */
-MMAL_STATUS_T mmal_port_parameter_set_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T value)
-{
-   MMAL_PARAMETER_RATIONAL_T param = {{id, sizeof(param)}, {value.num, value.den}};
-   return mmal_port_parameter_set(port, &param.hdr);
-}
-
-/** Helper function to get the value of a rational parameter */
-MMAL_STATUS_T mmal_port_parameter_get_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T *value)
-{
-   MMAL_PARAMETER_RATIONAL_T param = {{id, sizeof(param)}, {0,0}};
-   // coverity[overrun-buffer-val] Structure accessed correctly via size field
-   MMAL_STATUS_T status = mmal_port_parameter_get(port, &param.hdr);
-   if (status == MMAL_SUCCESS)
-      *value = param.value;
-   return status;
-}
-
-/** Helper function to set the value of a string parameter */
-MMAL_STATUS_T mmal_port_parameter_set_string(MMAL_PORT_T *port, uint32_t id, const char *value)
-{
-   MMAL_PARAMETER_STRING_T *param = 0;
-   MMAL_STATUS_T status;
-   size_t param_size = sizeof(param->hdr) + strlen(value) + 1;
-
-   param = calloc(1, param_size);
-   if (!param)
-      return MMAL_ENOMEM;
-
-   param->hdr.id = id;
-   param->hdr.size = param_size;
-   memcpy(param->str, value, strlen(value)+1);
-   status = mmal_port_parameter_set(port, &param->hdr);
-   free(param);
-   return status;
-}
-
-/** Helper function to set a MMAL_PARAMETER_URI_T parameter on a port */
-MMAL_STATUS_T mmal_util_port_set_uri(MMAL_PORT_T *port, const char *uri)
-{
-   return mmal_port_parameter_set_string(port, MMAL_PARAMETER_URI, uri);
-}
-
-/** Helper function to set the value of an array of bytes parameter */
-MMAL_STATUS_T mmal_port_parameter_set_bytes(MMAL_PORT_T *port, uint32_t id,
-   const uint8_t *data, unsigned int size)
-{
-   MMAL_PARAMETER_BYTES_T *param = 0;
-   MMAL_STATUS_T status;
-   size_t param_size = sizeof(param->hdr) + size;
-
-   param = calloc(1, param_size);
-   if (!param)
-      return MMAL_ENOMEM;
-
-   param->hdr.id = id;
-   param->hdr.size = param_size;
-   memcpy(param->data, data, size);
-   status = mmal_port_parameter_set(port, &param->hdr);
-   free(param);
-   return status;
-}
-
-/** Set the display region.
- * @param port   port to configure
- * @param region region
- *
- * @return MMAL_SUCCESS or error
- */
-
-MMAL_STATUS_T mmal_util_set_display_region(MMAL_PORT_T *port,
-                                           MMAL_DISPLAYREGION_T *region)
-{
-   region->hdr.id = MMAL_PARAMETER_DISPLAYREGION;
-   region->hdr.size = sizeof(*region);
-   return mmal_port_parameter_set(port, &region->hdr);
-}
-
-MMAL_STATUS_T mmal_util_camera_use_stc_timestamp(MMAL_PORT_T *port, MMAL_CAMERA_STC_MODE_T mode)
-{
-   MMAL_PARAMETER_CAMERA_STC_MODE_T param =
-      {{MMAL_PARAMETER_USE_STC, sizeof(MMAL_PARAMETER_CAMERA_STC_MODE_T)},mode};
-   return mmal_port_parameter_set(port, &param.hdr);
-}
-
-MMAL_STATUS_T mmal_util_get_core_port_stats(MMAL_PORT_T *port, 
-                                            MMAL_CORE_STATS_DIR dir,
-                                            MMAL_BOOL_T reset,
-                                            MMAL_CORE_STATISTICS_T *stats)
-{
-   MMAL_PARAMETER_CORE_STATISTICS_T param;
-   MMAL_STATUS_T ret;
-
-   memset(&param, 0, sizeof(param));
-   param.hdr.id = MMAL_PARAMETER_CORE_STATISTICS;
-   param.hdr.size = sizeof(param);
-   param.dir = dir;
-   param.reset = reset;
-   // coverity[overrun-buffer-val] Structure accessed correctly via size field
-   ret = mmal_port_parameter_get(port, &param.hdr);
-   if (ret == MMAL_SUCCESS)
-      *stats = param.stats;
-   return ret;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.h
deleted file mode 100644
index 4b1fae6..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_params.h
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_UTIL_PARAMS_H
-#define MMAL_UTIL_PARAMS_H
-
-#include "../mmal.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file
- * Utility functions to set some common parameters.
- */
-
-/** Helper function to set the value of a boolean parameter.
- * @param port   port on which to set the parameter
- * @param id     parameter id
- * @param value  value to set the parameter to
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_set_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T value);
-
-/** Helper function to get the value of a boolean parameter.
- * @param port   port on which to get the parameter
- * @param id     parameter id
- * @param value  pointer to where the value will be returned
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_get_boolean(MMAL_PORT_T *port, uint32_t id, MMAL_BOOL_T *value);
-
-/** Helper function to set the value of a 64 bits unsigned integer parameter.
- * @param port   port on which to set the parameter
- * @param id     parameter id
- * @param value  value to set the parameter to
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_set_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t value);
-
-/** Helper function to get the value of a 64 bits unsigned integer parameter.
- * @param port   port on which to get the parameter
- * @param id     parameter id
- * @param value  pointer to where the value will be returned
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_get_uint64(MMAL_PORT_T *port, uint32_t id, uint64_t *value);
-
-/** Helper function to set the value of a 64 bits signed integer parameter.
- * @param port   port on which to set the parameter
- * @param id     parameter id
- * @param value  value to set the parameter to
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_set_int64(MMAL_PORT_T *port, uint32_t id, int64_t value);
-
-/** Helper function to get the value of a 64 bits signed integer parameter.
- * @param port   port on which to get the parameter
- * @param id     parameter id
- * @param value  pointer to where the value will be returned
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_get_int64(MMAL_PORT_T *port, uint32_t id, int64_t *value);
-
-/** Helper function to set the value of a 32 bits unsigned integer parameter.
- * @param port   port on which to set the parameter
- * @param id     parameter id
- * @param value  value to set the parameter to
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_set_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t value);
-
-/** Helper function to get the value of a 32 bits unsigned integer parameter.
- * @param port   port on which to get the parameter
- * @param id     parameter id
- * @param value  pointer to where the value will be returned
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_get_uint32(MMAL_PORT_T *port, uint32_t id, uint32_t *value);
-
-/** Helper function to set the value of a 32 bits signed integer parameter.
- * @param port   port on which to set the parameter
- * @param id     parameter id
- * @param value  value to set the parameter to
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_set_int32(MMAL_PORT_T *port, uint32_t id, int32_t value);
-
-/** Helper function to get the value of a 32 bits signed integer parameter.
- * @param port   port on which to get the parameter
- * @param id     parameter id
- * @param value  pointer to where the value will be returned
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_get_int32(MMAL_PORT_T *port, uint32_t id, int32_t *value);
-
-/** Helper function to set the value of a rational parameter.
- * @param port   port on which to set the parameter
- * @param id     parameter id
- * @param value  value to set the parameter to
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_set_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T value);
-
-/** Helper function to get the value of a rational parameter.
- * @param port   port on which to get the parameter
- * @param id     parameter id
- * @param value  pointer to where the value will be returned
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_get_rational(MMAL_PORT_T *port, uint32_t id, MMAL_RATIONAL_T *value);
-
-/** Helper function to set the value of a string parameter.
- * @param port   port on which to set the parameter
- * @param id     parameter id
- * @param value  null-terminated string value
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_set_string(MMAL_PORT_T *port, uint32_t id, const char *value);
-
-/** Helper function to set the value of an array of bytes parameter.
- * @param port   port on which to set the parameter
- * @param id     parameter id
- * @param data   pointer to the array of bytes
- * @param size   size of the array of bytes
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_port_parameter_set_bytes(MMAL_PORT_T *port, uint32_t id,
-   const uint8_t *data, unsigned int size);
-
-/** Helper function to set a MMAL_PARAMETER_URI_T parameter on a port.
- * @param port   port on which to set the parameter
- * @param uri    URI string
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_util_port_set_uri(MMAL_PORT_T *port, const char *uri);
-
-/** Set the display region.
- * @param port   port to configure
- * @param region region
- *
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_util_set_display_region(MMAL_PORT_T *port,
-                                           MMAL_DISPLAYREGION_T *region);
-
-/** Tell the camera to use the STC for timestamps rather than the clock.
- *
- * @param port   port to configure
- * @param mode   STC mode to use
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_util_camera_use_stc_timestamp(MMAL_PORT_T *port, MMAL_CAMERA_STC_MODE_T mode);
-
-/** Get the MMAL core statistics for a given port.
- *
- * @param port  port to query
- * @param dir   port direction
- * @param reset reset the stats as well
- * @param stats filled in with results
- * @return MMAL_SUCCESS or error
- */
-MMAL_STATUS_T mmal_util_get_core_port_stats(MMAL_PORT_T *port, MMAL_CORE_STATS_DIR dir, MMAL_BOOL_T reset,
-                                            MMAL_CORE_STATISTICS_T *stats);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.c
deleted file mode 100644
index fd7b054..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.c
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include <limits.h>
-#include "interface/mmal/util/mmal_util_rational.h"
-
-#define Q16_ONE   (1 << 16)
-
-#define ABS(v)    (((v) < 0) ? -(v) : (v))
-
-/** Calculate the greatest common denominator between 2 integers.
- * Avoids division. */
-static int32_t gcd(int32_t a, int32_t b)
-{
-   int shift;
-
-   if (a == 0 || b == 0)
-      return 1;
-
-   a = ABS(a);
-   b = ABS(b);
-   for (shift = 0; !((a | b) & 0x01); shift++)
-      a >>= 1, b >>= 1;
-
-   while (a > 0)
-   {
-      while (!(a & 0x01))
-         a >>= 1;
-      while (!(b & 0x01))
-         b >>= 1;
-      if (a >= b)
-         a = (a - b) >> 1;
-      else
-         b = (b - a) >> 1;
-   }
-   return b << shift;
-}
-
-/** Calculate a + b. */
-MMAL_RATIONAL_T mmal_rational_add(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b)
-{
-   MMAL_RATIONAL_T result;
-   int32_t g = gcd(a.den, b.den);
-   a.den /= g;
-   a.num = a.num * (b.den / g) + b.num * a.den;
-   g = gcd(a.num, g);
-   a.num /= g;
-   a.den *= b.den / g;
-
-   result.num = a.num;
-   result.den = a.den;
-   return result;
-}
-
-/** Calculate a - b. */
-MMAL_RATIONAL_T mmal_rational_subtract(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b)
-{
-   b.num = -b.num;
-   return mmal_rational_add(a, b);
-}
-
-/** Calculate a * b */
-MMAL_RATIONAL_T mmal_rational_multiply(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b)
-{
-   MMAL_RATIONAL_T result;
-   int32_t gcd1 = gcd(a.num, b.den);
-   int32_t gcd2 = gcd(b.num, a.den);
-   result.num = (a.num / gcd1) * (b.num / gcd2);
-   result.den = (a.den / gcd2) * (b.den / gcd1);
-
-   return result;
-}
-
-/** Calculate a / b */
-MMAL_RATIONAL_T mmal_rational_divide(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b)
-{
-   MMAL_RATIONAL_T result;
-   int32_t gcd1, gcd2;
-
-   if (b.num == 0)
-   {
-      vcos_assert(0);
-      return a;
-   }
-
-   if (a.num == 0)
-      return a;
-
-   gcd1 = gcd(a.num, b.num);
-   gcd2 = gcd(b.den, a.den);
-   result.num = (a.num / gcd1) * (b.den / gcd2);
-   result.den = (a.den / gcd2) * (b.num / gcd1);
-
-   return result;
-}
-
-/** Convert a rational number to a signed 32-bit Q16 number. */
-int32_t mmal_rational_to_fixed_16_16(MMAL_RATIONAL_T rational)
-{
-   int64_t result = (int64_t)rational.num << 16;
-   if (rational.den)
-      result /= rational.den;
-
-   if (result > INT_MAX)
-      result = INT_MAX;
-   else if (result < INT_MIN)
-      result = INT_MIN;
-
-   return (int32_t)result;
-}
-
-/** Convert a rational number to a signed 32-bit Q16 number. */
-MMAL_RATIONAL_T mmal_rational_from_fixed_16_16(int32_t fixed)
-{
-   MMAL_RATIONAL_T result = { fixed, Q16_ONE };
-   mmal_rational_simplify(&result);
-   return result;
-}
-
-/** Reduce a rational number to it's simplest form. */
-void mmal_rational_simplify(MMAL_RATIONAL_T *rational)
-{
-   int g = gcd(rational->num, rational->den);
-   rational->num /= g;
-   rational->den /= g;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.h
deleted file mode 100644
index b2ded7f..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/util/mmal_util_rational.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_UTIL_RATIONAL_H
-#define MMAL_UTIL_RATIONAL_H
-
-#include "interface/mmal/mmal_types.h"
-
-/** \defgroup MmalRationalUtilities Rational Utility Functions
- * \ingroup MmalUtilities
- * The rational utility functions allow easy manipulation of rational numbers.
- *
- * @{
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Add 2 rational numbers.
- * It is assumed that both input rational numbers are in
- * their simplest form.
- *
- * @param a First operand
- * @param b Second operand
- *
- * @return a + b
- */
-MMAL_RATIONAL_T mmal_rational_add(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);
-
-/** Subtract 2 rational numbers.
- * It is assumed that both input rational numbers are in
- * their simplest form.
- *
- * @param a        First operand
- * @param b        Second operand
- *
- * @return a - b
- */
-MMAL_RATIONAL_T mmal_rational_subtract(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);
-
-/** Multiply 2 rational numbers.
- * It is assumed that both input rational numbers are in
- * their simplest form.
- *
- * @param a        First operand
- * @param b        Second operand
- *
- * @return a * b
- */
-MMAL_RATIONAL_T mmal_rational_multiply(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);
-
-/** Divide 2 rational numbers.
- * It is assumed that both input rational numbers are in
- * their simplest form.
- *
- * @param a        First operand
- * @param b        Second operand
- *
- * @return a / b
- */
-MMAL_RATIONAL_T mmal_rational_divide(MMAL_RATIONAL_T a, MMAL_RATIONAL_T b);
-
-/** Convert a rational number to a 32-bit signed Q16 number.
- * Saturation will occur for rational numbers with an absolute
- * value greater than 32768.
- *
- * @param rational Rational number to convert
- *
- * @return 32-bit signed Q16 number
- */
-int32_t mmal_rational_to_fixed_16_16(MMAL_RATIONAL_T rational);
-
-/** Convert a signed 32-bit Q16 number to a rational number.
- *
- * @param fixed    Signed 32-bit Q16 number to convert
- *
- * @return Rational number
- */
-MMAL_RATIONAL_T mmal_rational_from_fixed_16_16(int32_t fixed);
-
-/** Reduce a rational number to it's simplest form.
- *
- * @param rational Rational number to simplify
- */
-void mmal_rational_simplify(MMAL_RATIONAL_T *rational);
-
-#ifdef __cplusplus
-}
-#endif
-
-/** @} */
-
-#endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/CMakeLists.txt b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/CMakeLists.txt
deleted file mode 100644
index 38109a7..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-add_library(mmal_vc_client SHARED mmal_vc_client.c mmal_vc_shm.c mmal_vc_api.c mmal_vc_opaque_alloc.c mmal_vc_msgnames.c mmal_vc_api_drm.c)
-target_link_libraries(mmal_vc_client vchiq_arm vcos)
-
-if(BUILD_MMAL_APPS)
-add_executable(mmal_vc_diag mmal_vc_diag.c)
-target_link_libraries(mmal_vc_diag mmal mmal_vc_client debug_sym vcos)
-endif(BUILD_MMAL_APPS)
-
-install(TARGETS mmal_vc_client DESTINATION lib)
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.c
deleted file mode 100644
index bad1721..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.c
+++ /dev/null
@@ -1,1454 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "interface/mmal/mmal_logging.h"
-#include "interface/mmal/mmal.h"
-#include "mmal_vc_api.h"
-#include "mmal_vc_msgs.h"
-#include "mmal_vc_client_priv.h"
-#include "mmal_vc_opaque_alloc.h"
-#include "mmal_vc_shm.h"
-#include "interface/mmal/util/mmal_util.h"
-#include "interface/mmal/core/mmal_component_private.h"
-#include "interface/mmal/core/mmal_port_private.h"
-#include "interface/mmal/core/mmal_buffer_private.h"
-#include "interface/vcos/vcos.h"
-
-/** Private information for MMAL VC components
- */
-
-typedef enum MMAL_ZEROLEN_CHECK_T
-{
-   ZEROLEN_NOT_INITIALIZED,
-   ZEROLEN_COMPATIBLE,
-   ZEROLEN_INCOMPATIBLE
-} MMAL_ZEROLEN_CHECK_T;
-
-typedef enum MMAL_PORT_FLUSH_CHECK_T
-{
-   PORT_FLUSH_NOT_INITIALIZED,
-   PORT_FLUSH_COMPATIBLE,
-   PORT_FLUSH_INCOMPATIBLE
-} MMAL_PORT_FLUSH_CHECK_T;
-
-typedef struct MMAL_PORT_MODULE_T
-{
-   uint32_t magic;
-   uint32_t component_handle;
-   MMAL_PORT_T *port;
-   uint32_t port_handle;
-
-   MMAL_BOOL_T has_pool;
-   VCOS_BLOCKPOOL_T pool;
-
-   MMAL_BOOL_T is_zero_copy;
-   MMAL_BOOL_T zero_copy_workaround;
-
-   MMAL_BOOL_T sent_data_on_port;
-
-   MMAL_PORT_T *connected;           /**< Connected port if any */
-} MMAL_PORT_MODULE_T;
-
-typedef struct MMAL_COMPONENT_MODULE_T
-{
-   uint32_t component_handle;
-
-   MMAL_PORT_MODULE_T **ports;
-   uint32_t ports_num;
-
-   MMAL_QUEUE_T *callback_queue;   /**< Used to queue the callbacks we need to make to the client */
-
-   MMAL_BOOL_T event_ctx_initialised;
-   MMAL_VC_CLIENT_BUFFER_CONTEXT_T event_ctx; /**< Used as the ctx for event buffers */
-} MMAL_COMPONENT_MODULE_T;
-
-/*****************************************************************************
- * Local function prototypes
- *****************************************************************************/
-static void mmal_vc_do_callback(MMAL_COMPONENT_T *component);
-static MMAL_STATUS_T mmal_vc_port_info_get(MMAL_PORT_T *port);
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_vc_get_version(uint32_t *major, uint32_t *minor, uint32_t *minimum)
-{
-   mmal_worker_version msg;
-   size_t len = sizeof(msg);
-   MMAL_STATUS_T status;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_GET_VERSION, &msg, &len, MMAL_FALSE);
-
-   if (status != MMAL_SUCCESS)
-      return status;
-
-   if (!vcos_verify(len == sizeof(msg)))
-      return MMAL_EINVAL;
-
-   *major = msg.major;
-   *minor = msg.minor;
-   *minimum = msg.minimum;
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-MMAL_STATUS_T mmal_vc_get_stats(MMAL_VC_STATS_T *stats, int reset)
-{
-   mmal_worker_stats msg;
-   size_t len = sizeof(msg);
-   msg.reset = reset;
-
-   MMAL_STATUS_T status = mmal_vc_sendwait_message(mmal_vc_get_client(),
-                                                   &msg.header, sizeof(msg),
-                                                   MMAL_WORKER_GET_STATS,
-                                                   &msg, &len, MMAL_FALSE);
-
-
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(len == sizeof(msg));
-      *stats = msg.stats;
-   }
-   return status;
-}
-
-/** Set port buffer requirements. */
-static MMAL_STATUS_T mmal_vc_port_requirements_set(MMAL_PORT_T *port)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_STATUS_T status;
-   mmal_worker_reply reply;
-   mmal_worker_port_action msg;
-   size_t replylen = sizeof(reply);
-
-   msg.component_handle = module->component_handle;
-   msg.action = MMAL_WORKER_PORT_ACTION_SET_REQUIREMENTS;
-   msg.port_handle = module->port_handle;
-   msg.param.enable.port = *port;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-   if (status != MMAL_SUCCESS)
-      LOG_ERROR("failed to set port requirements (%i/%i,%i/%i)",
-                port->buffer_num, port->buffer_num_min,
-                port->buffer_size, port->buffer_size_min);
-
-   return status;
-}
-
-/** Get port buffer requirements. */
-static MMAL_STATUS_T mmal_vc_port_requirements_get(MMAL_PORT_T *port)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   mmal_worker_port_info_get msg;
-   mmal_worker_port_info reply;
-   size_t replylen = sizeof(reply);
-   MMAL_STATUS_T status;
-
-   msg.component_handle = module->component_handle;
-   msg.port_type = port->type;
-   msg.index = port->index;
-
-   LOG_TRACE("get port requirements (%i:%i)", port->type, port->index);
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_PORT_INFO_GET, &reply, &replylen, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to get port requirements (%i:%i)", port->type, port->index);
-      return status;
-   }
-
-   port->buffer_num_min = reply.port.buffer_num_min;
-   port->buffer_num_recommended = reply.port.buffer_num_recommended;
-   port->buffer_size_min = reply.port.buffer_size_min;
-   port->buffer_size_recommended = reply.port.buffer_size_recommended;
-   port->buffer_alignment_min = reply.port.buffer_alignment_min;
-
-   return MMAL_SUCCESS;
-}
-
-/** Enable processing on a port */
-static MMAL_STATUS_T mmal_vc_port_enable(MMAL_PORT_T *port, MMAL_PORT_BH_CB_T cb)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_STATUS_T status;
-   mmal_worker_reply reply;
-   mmal_worker_port_action msg;
-   size_t replylen = sizeof(reply);
-   MMAL_PARAM_UNUSED(cb);
-
-   if (!port->component->priv->module->event_ctx_initialised)
-   {
-      MMAL_POOL_T *pool = port->component->priv->event_pool;
-      MMAL_DRIVER_BUFFER_T *drv;
-      unsigned int i;
-
-      /* We need to associate our vc client context to all our event buffers.
-       * This only needs to be done when the first port is enabled because no event
-       * can be received on disabled ports. */
-      for (i = 0; i < pool->headers_num; i++)
-      {
-         drv = mmal_buffer_header_driver_data(pool->header[i]);
-         drv->client_context = &port->component->priv->module->event_ctx;
-         drv->magic = MMAL_MAGIC;
-      }
-
-      port->component->priv->module->event_ctx_initialised = MMAL_TRUE;
-   }
-
-   if (!module->connected)
-   {
-      if (vcos_blockpool_create_on_heap(&module->pool, port->buffer_num,
-             sizeof(MMAL_VC_CLIENT_BUFFER_CONTEXT_T),
-             VCOS_BLOCKPOOL_ALIGN_DEFAULT, VCOS_BLOCKPOOL_FLAG_NONE, "mmal vc port pool") != VCOS_SUCCESS)
-      {
-         LOG_ERROR("failed to create port pool");
-         return MMAL_ENOMEM;
-      }
-      module->has_pool = 1;
-   }
-
-   if (module->connected)
-   {
-      /* The connected port won't be enabled explicitly so make sure we apply
-       * the buffer requirements now. */
-      status = mmal_vc_port_requirements_set(module->connected);
-      if (status != MMAL_SUCCESS)
-         goto error;
-   }
-
-   msg.component_handle = module->component_handle;
-   msg.action = MMAL_WORKER_PORT_ACTION_ENABLE;
-   msg.port_handle = module->port_handle;
-   msg.param.enable.port = *port;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to enable port %s: %s",
-               port->name, mmal_status_to_string(status));
-      goto error;
-   }
-
-   if (module->connected)
-      mmal_vc_port_info_get(module->connected);
-
-   return MMAL_SUCCESS;
-
- error:
-   if (module->has_pool)
-      vcos_blockpool_delete(&module->pool);
-   return status;
-}
-
-/** Disable processing on a port */
-static MMAL_STATUS_T mmal_vc_port_disable(MMAL_PORT_T *port)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_STATUS_T status;
-   mmal_worker_reply reply;
-   mmal_worker_port_action msg;
-   size_t replylen = sizeof(reply);
-
-   msg.component_handle = module->component_handle;
-   msg.action = MMAL_WORKER_PORT_ACTION_DISABLE;
-   msg.port_handle = module->port_handle;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-   if (status != MMAL_SUCCESS)
-      LOG_ERROR("failed to disable port - reason %d", status);
-
-   if (module->has_pool)
-   {
-      /* MMAL server should make sure that all buffers are sent back before it
-       * disables the port. */
-      vcos_assert(vcos_blockpool_available_count(&module->pool) == port->buffer_num);
-      vcos_blockpool_delete(&module->pool);
-      module->has_pool = 0;
-   }
-
-   /* We need to make sure all the queued callbacks have been done */
-   while (mmal_queue_length(port->component->priv->module->callback_queue))
-      mmal_vc_do_callback(port->component);
-
-   if (module->connected)
-      mmal_vc_port_info_get(module->connected);
-
-   return status;
-}
-
-/** Flush a port using MMAL_WORKER_PORT_ACTION - when the port is zero-copy or no data has been sent */
-static MMAL_STATUS_T mmal_vc_port_flush_normal(MMAL_PORT_T *port)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_STATUS_T status;
-   mmal_worker_reply reply;
-   mmal_worker_port_action msg;
-   size_t replylen = sizeof(reply);
-
-   msg.component_handle = module->component_handle;
-   msg.action = MMAL_WORKER_PORT_ACTION_FLUSH;
-   msg.port_handle = module->port_handle;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-   if (status != MMAL_SUCCESS)
-      LOG_ERROR("failed to disable port - reason %d", status);
-
-   return status;
-}
-
-
-/** Flush a port using PORT_FLUSH - generates a dummy bulk transfer to keep it in sync
-  * with buffers being passed using bulk transfer */
-static MMAL_STATUS_T mmal_vc_port_flush_sync(MMAL_PORT_T *port)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_STATUS_T status;
-   mmal_worker_reply reply;
-   MMAL_VC_CLIENT_BUFFER_CONTEXT_T client_context;
-   mmal_worker_buffer_from_host *msg;
-
-   size_t replylen = sizeof(reply);
-
-   msg = &client_context.msg;
-
-   client_context.magic = MMAL_MAGIC;
-   client_context.port = port;
-
-   msg->drvbuf.client_context = &client_context;
-   msg->drvbuf.component_handle = module->component_handle;
-   msg->drvbuf.port_handle = module->port_handle;
-   msg->drvbuf.magic = MMAL_MAGIC;
-
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg->header, sizeof(*msg),
-                                     MMAL_WORKER_PORT_FLUSH, &reply, &replylen, MMAL_TRUE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-   if (status != MMAL_SUCCESS)
-      LOG_ERROR("failed to disable port - reason %d", status);
-
-   return status;
-}
-
-/** Flush a port */
-static MMAL_STATUS_T mmal_vc_port_flush(MMAL_PORT_T *port)
-{
-   static MMAL_PORT_FLUSH_CHECK_T is_port_flush_compatible = PORT_FLUSH_NOT_INITIALIZED;
-   uint32_t major = 0, minor = 0, minimum = 0;
-   MMAL_STATUS_T status;
-   /* Buffers sent to videocore, if not zero-copy, use vchiq bulk transfers to copy the data.
-      A flush could be sent while one of these buffers is being copied. If the normal flushing method
-      is used, the flush can arrive before the buffer, which causes confusion when a pre-flush buffer
-      arrives after the flush. So use a special flush mode that uses a dummy vchiq transfer to synchronise
-      things.
-      If data has never been sent on the port, then we don't need to worry about a flush overtaking data.
-      In that case, the port may not actually be set up on the other end to receive bulk transfers, so use
-      the normal flushing mechanism in that case.
-    */
-
-   if (port->priv->module->is_zero_copy || !port->priv->module->sent_data_on_port)
-      return mmal_vc_port_flush_normal(port);
-
-   if (is_port_flush_compatible == PORT_FLUSH_NOT_INITIALIZED)
-   {
-      status = mmal_vc_get_version(&major, &minor, &minimum);
-      if (major >= 15)
-      {
-         is_port_flush_compatible = PORT_FLUSH_COMPATIBLE;
-      }
-      else
-      {
-         LOG_ERROR("Version number of MMAL Server incompatible. Required Major:14 Minor: 2 \
-          or Greater. Current Major %d , Minor %d",major,minor);
-         is_port_flush_compatible = PORT_FLUSH_INCOMPATIBLE;
-      }
-   }
-
-   if (is_port_flush_compatible == PORT_FLUSH_COMPATIBLE)
-      return mmal_vc_port_flush_sync(port);
-   else
-      return mmal_vc_port_flush_normal(port);
-}
-
-
-/** Connect 2 ports together */
-static MMAL_STATUS_T mmal_vc_port_connect(MMAL_PORT_T *port, MMAL_PORT_T *other_port)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_STATUS_T status;
-   mmal_worker_reply reply;
-   mmal_worker_port_action msg;
-   size_t replylen = sizeof(reply);
-
-   /* We only support connecting vc components together */
-   if (other_port && port->priv->pf_enable != other_port->priv->pf_enable)
-      return MMAL_ENOSYS;
-
-   /* Send the request to the video side */
-   msg.component_handle = module->component_handle;
-   msg.action = other_port ? MMAL_WORKER_PORT_ACTION_CONNECT : MMAL_WORKER_PORT_ACTION_DISCONNECT;
-   msg.port_handle = module->port_handle;
-   if (other_port)
-   {
-      msg.param.connect.component_handle = other_port->priv->module->component_handle;
-      msg.param.connect.port_handle = other_port->priv->module->port_handle;
-   }
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_PORT_ACTION, &reply, &replylen, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to connect ports: %s", mmal_status_to_string(status));
-      return status;
-   }
-
-   if (other_port)
-   {
-      /* Connection */
-      module->connected = other_port;
-      other_port->priv->module->connected = port;
-   }
-   else
-   {
-      /* Disconnection */
-      if (module->connected)
-         module->connected->priv->module->connected = NULL;
-      module->connected = NULL;
-   }
-
-   return MMAL_SUCCESS;
-}
-
-/*****************************************************************************/
-static void mmal_vc_do_callback(MMAL_COMPONENT_T *component)
-{
-   MMAL_COMPONENT_MODULE_T *module = component->priv->module;
-   MMAL_BUFFER_HEADER_T *buffer;
-   MMAL_PORT_T *port;
-
-   /* Get a buffer from this port */
-   buffer = mmal_queue_get(module->callback_queue);
-   if (!buffer)
-      return; /* Will happen when a port gets disabled */
-
-   port = (MMAL_PORT_T *)buffer->priv->component_data;
-
-   /* Catch and report any transmission error */
-   if (buffer->flags & MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED)
-       mmal_event_error_send(port->component, MMAL_EIO);
-
-   /* Events generated by this component are handled differently */
-   if (mmal_buffer_header_driver_data(buffer)->client_context ==
-       &component->priv->module->event_ctx)
-   {
-      mmal_port_event_send(port, buffer);
-      return;
-   }
-
-   buffer->data = mmal_vc_shm_lock(buffer->data, port->priv->module->zero_copy_workaround);
-   mmal_port_buffer_header_callback(port, buffer);
-}
-
-/** Called back from VCHI(Q) event handler when buffers come back from the copro.
- *
- * The message points to the message sent by videocore, and which should have
- * a pointer back to our original client side context.
- *
- */
-static void mmal_vc_port_send_callback(mmal_worker_buffer_from_host *msg)
-{
-   MMAL_BUFFER_HEADER_T *buffer;
-   MMAL_PORT_T *port;
-   MMAL_VC_CLIENT_BUFFER_CONTEXT_T *client_context = msg->drvbuf.client_context;
-
-   vcos_assert(client_context);
-   vcos_assert(client_context->magic == MMAL_MAGIC);
-
-   buffer = client_context->buffer;
-   port = client_context->port;
-   vcos_blockpool_free(msg->drvbuf.client_context);
-
-   vcos_assert(port->priv->module->magic == MMAL_MAGIC);
-   mmal_vc_msg_to_buffer_header(buffer, msg);
-
-   /* Queue the callback so it is delivered by the action thread */
-   buffer->priv->component_data = (void *)port;
-   mmal_queue_put(port->component->priv->module->callback_queue, buffer);
-   mmal_component_action_trigger(port->component);
-}
-
-static void mmal_vc_port_send_event_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   /* Queue the event to be delivered by the action thread */
-   buffer->priv->component_data = (void *)port;
-   mmal_queue_put(port->component->priv->module->callback_queue, buffer);
-   mmal_component_action_trigger(port->component);
-}
-
-/** Called from the client to send a buffer (empty or full) to
-  * the copro.
-  */
-static MMAL_STATUS_T mmal_vc_port_send(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_STATUS_T status;
-   MMAL_VC_CLIENT_BUFFER_CONTEXT_T *client_context;
-   mmal_worker_buffer_from_host *msg;
-   uint32_t length;
-   uint32_t msgid = MMAL_WORKER_BUFFER_FROM_HOST;
-   uint32_t major = 0, minor = 0, minimum = 0;
-   static MMAL_ZEROLEN_CHECK_T is_vc_zerolength_compatible = ZEROLEN_NOT_INITIALIZED;
-
-   vcos_assert(port);
-   vcos_assert(module);
-   vcos_assert(module->magic == MMAL_MAGIC);
-
-   /* Handle event buffers */
-   if (buffer->cmd)
-   {
-      MMAL_EVENT_FORMAT_CHANGED_T *event = mmal_event_format_changed_get(buffer);
-      if (event)
-      {
-         mmal_format_copy(port->format, event->format);
-         status = port->priv->pf_set_format(port);
-         if(status != MMAL_SUCCESS)
-            LOG_ERROR("format not set on port %p", port);
-      }
-      else
-      {
-         LOG_ERROR("discarding event %i on port %p", (int)buffer->cmd, port);
-      }
-
-      buffer->length = 0;
-      mmal_port_buffer_header_callback(port, buffer);
-      return MMAL_SUCCESS;
-   }
-
-   /* We can only send buffers if we have a pool */
-   if (!module->has_pool)
-   {
-      LOG_ERROR("no pool on port %p", port);
-      return MMAL_EINVAL;
-   }
-
-   client_context = vcos_blockpool_alloc(&module->pool);
-   if(!client_context)
-   {
-      LOG_INFO("couldn't allocate client buffer context from pool");
-      return MMAL_ENOMEM;
-   }
-   msg = &client_context->msg;
-
-   client_context->magic = MMAL_MAGIC;
-   client_context->buffer = buffer;
-   client_context->callback = mmal_vc_port_send_callback;
-   client_context->callback_event = NULL;
-   client_context->port = port;
-
-   msg->drvbuf.client_context = client_context;
-   msg->drvbuf.component_handle = module->component_handle;
-   msg->drvbuf.port_handle = module->port_handle;
-   msg->drvbuf.magic = MMAL_MAGIC;
-
-   length = buffer->length;
-
-   if (length <= MMAL_VC_SHORT_DATA && !port->priv->module->is_zero_copy &&
-       port->format->encoding == MMAL_ENCODING_OPAQUE)
-   {
-      memcpy(msg->short_data, buffer->data + buffer->offset, buffer->length);
-      msg->payload_in_message = length;
-      length = 0;
-   }
-   else
-   {
-      msg->payload_in_message = 0;
-   }
-
-   buffer->data =
-      mmal_vc_shm_unlock(buffer->data, &length, port->priv->module->zero_copy_workaround);
-   mmal_vc_buffer_header_to_msg(msg, buffer);
-
-   if (!VCOS_BLOCKPOOL_IS_VALID_HANDLE_FORMAT(msg->drvbuf.component_handle, 256))
-   {
-      LOG_ERROR("bad component handle 0x%x", msg->drvbuf.component_handle);
-      return MMAL_EINVAL;
-   }
-
-   if (msg->drvbuf.port_handle > 255)
-   {
-      LOG_ERROR("bad port handle 0x%x", msg->drvbuf.port_handle);
-      return MMAL_EINVAL;
-   }
-
-   if (module->is_zero_copy)
-      length = 0;
-
-   if (is_vc_zerolength_compatible == ZEROLEN_NOT_INITIALIZED)
-   {
-      status = mmal_vc_get_version(&major, &minor, &minimum);
-      if ((major > 12 ) || ((major == 12) && (minor >= 2)))
-      {
-         is_vc_zerolength_compatible = ZEROLEN_COMPATIBLE;
-      }
-      else
-      {
-         LOG_ERROR("Version number of MMAL Server incompatible. Required Major:12 Minor: 2 \
-          or Greater. Current Major %d , Minor %d",major,minor);
-         is_vc_zerolength_compatible = ZEROLEN_INCOMPATIBLE;
-      }
-   }
-
-   if ((is_vc_zerolength_compatible == ZEROLEN_COMPATIBLE) && !(module->is_zero_copy) && !length
-       && (msg->buffer_header.flags & MMAL_BUFFER_HEADER_FLAG_EOS))
-   {
-      length = 8;
-      msgid = MMAL_WORKER_BUFFER_FROM_HOST_ZEROLEN;
-   }
-
-   if (length)
-   {
-      // We're doing a bulk transfer. Note this so that flushes know
-      // they need to use the more cumbersome fake-bulk-transfer mechanism
-      // to guarantee correct ordering.
-      port->priv->module->sent_data_on_port = MMAL_TRUE;
-   }
-
-   status = mmal_vc_send_message(mmal_vc_get_client(), &msg->header, sizeof(*msg),
-                                 buffer->data + buffer->offset, length,
-                                 msgid);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_INFO("failed %d", status);
-      vcos_blockpool_free(msg->drvbuf.client_context);
-      buffer->data = mmal_vc_shm_lock(buffer->data, port->priv->module->zero_copy_workaround);
-   }
-
-   return status;
-}
-
-static MMAL_STATUS_T mmal_vc_component_disable(MMAL_COMPONENT_T *component)
-{
-   MMAL_STATUS_T status;
-   mmal_worker_reply reply;
-   mmal_worker_component_disable msg;
-   size_t replylen = sizeof(reply);
-
-   vcos_assert(component && component->priv && component->priv->module);
-
-   msg.component_handle = component->priv->module->component_handle;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-         MMAL_WORKER_COMPONENT_DISABLE,
-         &reply, &replylen, MMAL_FALSE);
-
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to disable component - reason %d", status);
-      goto fail;
-   }
-
-   return status;
-fail:
-   return status;
-}
-
-static MMAL_STATUS_T mmal_vc_component_enable(MMAL_COMPONENT_T *component)
-{
-   MMAL_STATUS_T status;
-   mmal_worker_reply reply;
-   mmal_worker_component_enable msg;
-   size_t replylen = sizeof(reply);
-
-   vcos_assert(component && component->priv && component->priv->module);
-
-   msg.component_handle = component->priv->module->component_handle;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_COMPONENT_ENABLE, &reply, &replylen, MMAL_FALSE);
-
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to enable component: %s", mmal_status_to_string(status));
-      return status;
-   }
-
-   return MMAL_SUCCESS;
-}
-
-static MMAL_STATUS_T mmal_vc_component_destroy(MMAL_COMPONENT_T *component)
-{
-   MMAL_STATUS_T status;
-   mmal_worker_component_destroy msg;
-   mmal_worker_reply reply;
-   size_t replylen = sizeof(reply);
-
-   vcos_assert(component && component->priv && component->priv->module);
-
-   msg.component_handle = component->priv->module->component_handle;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-         MMAL_WORKER_COMPONENT_DESTROY,
-         &reply, &replylen, MMAL_FALSE);
-
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to destroy component - reason %d", status );
-      goto fail;
-   }
-
-   if(component->input_num)
-      mmal_ports_free(component->input, component->input_num);
-   if(component->output_num)
-      mmal_ports_free(component->output, component->output_num);
-   if(component->clock_num)
-      mmal_ports_free(component->clock, component->clock_num);
-
-   vcos_free(component->priv->module);
-   component->priv->module = NULL;
-
-fail:
-   // no longer require videocore
-   mmal_vc_release();
-   mmal_vc_deinit();
-   return status;
-}
-
-MMAL_STATUS_T mmal_vc_consume_mem(size_t size, uint32_t *handle)
-{
-   MMAL_STATUS_T status;
-   mmal_worker_consume_mem req;
-   mmal_worker_consume_mem reply;
-   size_t len = sizeof(reply);
-
-   req.size = (uint32_t) size;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
-                                     &req.header, sizeof(req),
-                                     MMAL_WORKER_CONSUME_MEM,
-                                     &reply, &len, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(len == sizeof(reply));
-      status = reply.status;
-      *handle = reply.handle;
-   }
-   return status;
-}
-
-MMAL_STATUS_T mmal_vc_lmk(uint32_t alloc_size)
-{
-   MMAL_STATUS_T status;
-   mmal_worker_lmk req;
-   mmal_worker_lmk reply;
-   size_t len = sizeof(reply);
-
-   req.alloc_size = alloc_size;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
-                                     &req.header, sizeof(req),
-                                     MMAL_WORKER_LMK,
-                                     &reply, &len, MMAL_FALSE);
-   return status;
-}
-
-MMAL_STATUS_T mmal_vc_host_log(const char *msg)
-{
-   MMAL_STATUS_T status = MMAL_EINVAL;
-   if (msg)
-   {
-      mmal_worker_host_log req;
-      mmal_worker_reply reply;
-      size_t replylen = sizeof(reply);
-      size_t msg_len = vcos_safe_strcpy(req.msg, msg, sizeof(req.msg), 0);
-
-      /* Reduce the length if it is shorter than the max message length */
-      status = mmal_vc_sendwait_message(mmal_vc_get_client(), &req.header,
-            sizeof(req) - sizeof(req.msg) + vcos_min(sizeof(req.msg), msg_len + 1),
-            MMAL_WORKER_HOST_LOG,
-            &reply, &replylen, MMAL_FALSE);
-
-      if (status == MMAL_SUCCESS)
-      {
-         vcos_assert(replylen == sizeof(reply));
-         status = reply.status;
-      }
-   }
-   return status;
-}
-
-MMAL_STATUS_T mmal_vc_get_core_stats(MMAL_CORE_STATISTICS_T *stats,
-                                     MMAL_STATS_RESULT_T *result,
-                                     char *name,
-                                     size_t namelen,
-                                     MMAL_PORT_TYPE_T type,
-                                     unsigned component_index,
-                                     unsigned port_index,
-                                     MMAL_CORE_STATS_DIR dir,
-                                     MMAL_BOOL_T reset)
-{
-   mmal_worker_get_core_stats_for_port req;
-   mmal_worker_get_core_stats_for_port_reply reply;
-   MMAL_STATUS_T status;
-   size_t len = sizeof(reply);
-
-   req.component_index = component_index;
-   req.port_index = port_index;
-   req.type = type;
-   req.reset = reset;
-   req.dir = dir;
-   
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
-                                     &req.header, sizeof(req),
-                                     MMAL_WORKER_GET_CORE_STATS_FOR_PORT,
-                                     &reply, &len, MMAL_FALSE);
-
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(len == sizeof(reply));
-      *stats = reply.stats;
-      *result = reply.result;
-      strncpy(name, reply.component_name, namelen);
-      name[namelen-1] = '\0';
-   }
-   return status;
-}
-
-
-/** Get port context data. */
-static MMAL_STATUS_T mmal_vc_port_info_get(MMAL_PORT_T *port)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   mmal_worker_port_info_get msg;
-   mmal_worker_port_info reply;
-   size_t replylen = sizeof(reply);
-   MMAL_STATUS_T status;
-
-   msg.component_handle = module->component_handle;
-   msg.port_type = port->type;
-   msg.index = port->index;
-
-   LOG_TRACE("get port info (%i:%i)", port->type, port->index);
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_PORT_INFO_GET, &reply, &replylen, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to get port info (%i:%i): %s", port->type, port->index,
-                mmal_status_to_string(status));
-      return status;
-   }
-
-   module->port_handle = reply.port_handle;
-   port->buffer_num_min = reply.port.buffer_num_min;
-   port->buffer_num_recommended = reply.port.buffer_num_recommended;
-   port->buffer_num = reply.port.buffer_num;
-   port->buffer_size_min = reply.port.buffer_size_min;
-   port->buffer_size_recommended = reply.port.buffer_size_recommended;
-   port->buffer_size = reply.port.buffer_size;
-   port->buffer_alignment_min = reply.port.buffer_alignment_min;
-   port->is_enabled = reply.port.is_enabled;
-   port->capabilities = reply.port.capabilities;
-   reply.format.extradata = port->format->extradata;
-   reply.format.es = port->format->es;
-   *port->format = reply.format;
-   *port->format->es = reply.es;
-   if(port->format->extradata_size)
-   {
-      status = mmal_format_extradata_alloc(port->format, port->format->extradata_size);
-      if(status != MMAL_SUCCESS)
-      {
-         vcos_assert(0);
-         port->format->extradata_size = 0;
-         LOG_ERROR("couldn't allocate extradata %i", port->format->extradata_size);
-         return MMAL_ENOMEM;
-      }
-      memcpy(port->format->extradata, reply.extradata, port->format->extradata_size);
-   }
-
-   return MMAL_SUCCESS;
-}
-
-/** Set port context data. */
-static MMAL_STATUS_T mmal_vc_port_info_set(MMAL_PORT_T *port)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   mmal_worker_port_info_set msg;
-   mmal_worker_port_info reply;
-   size_t replylen = sizeof(reply);
-   MMAL_STATUS_T status;
-
-   msg.component_handle = module->component_handle;
-   msg.port_type = port->type;
-   msg.index = port->index;
-   msg.port = *port;
-   msg.format = *port->format;
-   msg.es = *port->format->es;
-   if(msg.format.extradata_size > MMAL_FORMAT_EXTRADATA_MAX_SIZE)
-   {
-      vcos_assert(0);
-      msg.format.extradata_size = MMAL_FORMAT_EXTRADATA_MAX_SIZE;
-   }
-   memcpy(msg.extradata, msg.format.extradata, msg.format.extradata_size);
-
-   LOG_TRACE("set port info (%i:%i)", port->type, port->index);
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_PORT_INFO_SET, &reply, &replylen, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to set port info (%i:%i): %s", port->type, port->index,
-                mmal_status_to_string(status));
-      return status;
-   }
-
-   port->buffer_num_min = reply.port.buffer_num_min;
-   port->buffer_num_recommended = reply.port.buffer_num_recommended;
-   port->buffer_num = reply.port.buffer_num;
-   port->buffer_size_min = reply.port.buffer_size_min;
-   port->buffer_size_recommended = reply.port.buffer_size_recommended;
-   port->buffer_size = reply.port.buffer_size;
-   port->buffer_alignment_min = reply.port.buffer_alignment_min;
-   port->is_enabled = reply.port.is_enabled;
-   port->capabilities = reply.port.capabilities;
-   reply.format.extradata = port->format->extradata;
-   reply.format.es = port->format->es;
-   *port->format = reply.format;
-   *port->format->es = reply.es;
-   if(port->format->extradata_size)
-   {
-      status = mmal_format_extradata_alloc(port->format, port->format->extradata_size);
-      if(status != MMAL_SUCCESS)
-      {
-         vcos_assert(0);
-         port->format->extradata_size = 0;
-         LOG_ERROR("couldn't allocate extradata %i", port->format->extradata_size);
-         return MMAL_ENOMEM;
-      }
-      memcpy(port->format->extradata, reply.extradata, port->format->extradata_size);
-   }
-
-   return MMAL_SUCCESS;
-}
-
-/** Set format on a port */
-static MMAL_STATUS_T mmal_vc_port_set_format(MMAL_PORT_T *port)
-{
-   MMAL_COMPONENT_T *component = port->component;
-   MMAL_COMPONENT_MODULE_T *module = component->priv->module;
-   MMAL_STATUS_T status;
-   unsigned int i;
-
-   status = mmal_vc_port_info_set(port);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("mmal_vc_port_info_set failed %p (%s)", port,
-                mmal_status_to_string(status));
-      return status;
-   }
-
-   /* Get the setting back for this port */
-   status = mmal_vc_port_info_get(port);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("mmal_vc_port_info_get failed %p (%s)", port,
-                mmal_status_to_string(status));
-      return status;
-   }
-
-   /* Get the settings for the output ports in case they have changed */
-   if (port->type == MMAL_PORT_TYPE_INPUT)
-   {
-      for (i = 0; i < module->ports_num; i++)
-      {
-         if (module->ports[i]->port->type != MMAL_PORT_TYPE_OUTPUT)
-            continue;
-
-         status = mmal_vc_port_info_get(module->ports[i]->port);
-         if (status != MMAL_SUCCESS)
-         {
-            LOG_ERROR("mmal_vc_port_info_get failed %p (%i)",
-                      module->ports[i]->port, status);
-            return status;
-         }
-      }
-   }
-
-   return MMAL_SUCCESS;
-}
-
-/** Set parameter on a port */
-static MMAL_STATUS_T mmal_vc_port_parameter_set(MMAL_PORT_T *port, const MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_STATUS_T status;
-   mmal_worker_port_param_set msg;
-   size_t msglen = MMAL_OFFSET(mmal_worker_port_param_set, param) + param->size;
-   mmal_worker_reply reply;
-   size_t replylen = sizeof(reply);
-
-   if(param->size > MMAL_WORKER_PORT_PARAMETER_SET_MAX)
-   {
-      LOG_ERROR("parameter too large (%u > %u)", param->size, MMAL_WORKER_PORT_PARAMETER_SET_MAX);
-      return MMAL_ENOSPC;
-   }
-
-   /* Intercept the zero copy parameter */
-   if (param->id == MMAL_PARAMETER_ZERO_COPY &&
-       param->size >= sizeof(MMAL_PARAMETER_BOOLEAN_T) )
-   {
-      module->is_zero_copy = !!((MMAL_PARAMETER_BOOLEAN_T *)param)->enable;
-      module->zero_copy_workaround = ((MMAL_PARAMETER_BOOLEAN_T *)param)->enable == 0xBEEF;
-      LOG_DEBUG("%s zero copy on port %p", module->is_zero_copy ? "enable" : "disable", port);
-   }
-
-   msg.component_handle = module->component_handle;
-   msg.port_handle = module->port_handle;
-   /* coverity[overrun-buffer-arg] */
-   memcpy(&msg.param, param, param->size);
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, msglen,
-                                     MMAL_WORKER_PORT_PARAMETER_SET, &reply, &replylen, MMAL_FALSE);
-
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to set port parameter %u:%u:%s", msg.component_handle, msg.port_handle,
-                mmal_status_to_string(status));
-      return status;
-   }
-
-   if (param->id == MMAL_PARAMETER_BUFFER_REQUIREMENTS)
-   {
-      /* This might have changed the buffer requirements of other ports so fetch them all */
-      MMAL_COMPONENT_T *component = port->component;
-      unsigned int i;
-      for (i = 0; status == MMAL_SUCCESS && i < component->input_num; i++)
-         status = mmal_vc_port_requirements_get(component->input[i]);
-      for (i = 0; status == MMAL_SUCCESS && i < component->output_num; i++)
-         status = mmal_vc_port_requirements_get(component->output[i]);
-   }
-
-   return status;
-}
-
-/** Get parameter on a port */
-static MMAL_STATUS_T mmal_vc_port_parameter_get(MMAL_PORT_T *port, MMAL_PARAMETER_HEADER_T *param)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_STATUS_T status;
-   mmal_worker_port_param_get msg;
-   mmal_worker_port_param_get_reply reply;
-   size_t replylen = MMAL_OFFSET(mmal_worker_port_param_get_reply, param) + param->size;
-
-   if(param->size > MMAL_WORKER_PORT_PARAMETER_GET_MAX)
-   {
-      LOG_ERROR("parameter too large (%u > %u)", param->size, MMAL_WORKER_PORT_PARAMETER_GET_MAX);
-      return MMAL_ENOMEM;
-   }
-
-   msg.component_handle = module->component_handle;
-   msg.port_handle = module->port_handle;
-   msg.param = *param;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_PORT_PARAMETER_GET, &reply, &replylen, MMAL_FALSE);
-   if (status == MMAL_SUCCESS)
-   {
-      status = reply.status;
-      /* Reply must include the parameter header */
-      vcos_assert(replylen >= MMAL_OFFSET(mmal_worker_port_param_get_reply, space));
-      
-      /* If the call fails with MMAL_ENOSPC then reply.param.size is set to the size required for
-       * the call to succeed, and that may be bigger than the buffers, so only check these asserts
-       * if the call succeeded.
-       */
-      if ( status == MMAL_SUCCESS )
-      {
-         /* Reply mustn't be bigger than the parameter given */
-         vcos_assert(replylen <= (MMAL_OFFSET(mmal_worker_port_param_get_reply, param) + param->size));
-         /* Reply must be consistent with the parameter size embedded in it */
-         vcos_assert(replylen == (MMAL_OFFSET(mmal_worker_port_param_get_reply, param) + reply.param.size));
-      }
-   }
-
-   if (status != MMAL_SUCCESS && status != MMAL_ENOSPC)
-   {
-      LOG_ERROR("failed to get port parameter %u:%u", msg.component_handle, msg.port_handle);
-      return status;
-   }
-   
-   if (status == MMAL_ENOSPC)
-   {
-      /* Copy only as much as we have space for but report true size of parameter */
-      /* coverity[overrun-buffer-arg] */
-      memcpy(param, &reply.param, param->size);
-      param->size = reply.param.size;
-   }
-   else
-   {
-      memcpy(param, &reply.param, reply.param.size);
-   }
-
-   return status;
-}
-
-static uint8_t *mmal_vc_port_payload_alloc(MMAL_PORT_T *port, uint32_t payload_size)
-{
-   MMAL_PORT_MODULE_T *module = port->priv->module;
-   MMAL_BOOL_T can_deref = MMAL_TRUE;
-   char buf[5];
-   MMAL_PARAM_UNUSED(module);
-   void *ret;
-   (void)buf;
-
-   LOG_TRACE("%s: allocating %d bytes, format %s, is_zero_copy %d",
-             port->name,
-             payload_size,
-             mmal_4cc_to_string(buf, sizeof(buf), port->format->encoding),
-             module->is_zero_copy);
-
-   if (port->format->encoding == MMAL_ENCODING_OPAQUE &&
-       module->is_zero_copy)
-   {
-      MMAL_OPAQUE_IMAGE_HANDLE_T h = mmal_vc_opaque_alloc_desc(port->name);
-      can_deref = MMAL_FALSE;
-      ret = (void*)h;
-      if (!ret)
-      {
-         LOG_ERROR("%s: failed to allocate %d bytes opaque memory",
-                   port->name, payload_size);
-         return NULL;
-      }
-   }
-
-   else if (module->is_zero_copy)
-   {
-      ret = mmal_vc_shm_alloc(payload_size);
-      if (!ret)
-      {
-         LOG_ERROR("%s: failed to allocate %d bytes of shared memory",
-                   port->name, payload_size);
-         return NULL;
-      }
-   }
-
-   else
-   {
-      /* Allocate conventional memory */
-      ret = vcos_malloc(payload_size, "mmal_vc_port payload");
-      if (!ret)
-      {
-         LOG_ERROR("could not allocate %i bytes", (int)payload_size);
-         return NULL;
-      }
-   }
-
-   /* Ensure that newly minted opaque buffers are always in a sensible
-    * state, and don't have random garbage in them.
-    */
-   if (can_deref && port->format->encoding == MMAL_ENCODING_OPAQUE)
-      memset(ret, 0, payload_size);
-
-   LOG_DEBUG("%s: allocated at %p", port->name, ret);
-   return ret;
-}
-
-static void mmal_vc_port_payload_free(MMAL_PORT_T *port, uint8_t *payload)
-{
-   MMAL_PARAM_UNUSED(port);
-
-   if (port->format->encoding == MMAL_ENCODING_OPAQUE)
-   {
-      mmal_vc_opaque_release((MMAL_OPAQUE_IMAGE_HANDLE_T)payload);
-      return;
-   }
-
-   else if (mmal_vc_shm_free(payload) == MMAL_SUCCESS)
-      return;
-
-   /* We're dealing with conventional memory */
-   vcos_free(payload);
-}
-
-/** Create a component given its name. */
-static MMAL_STATUS_T mmal_vc_component_create(const char *name, MMAL_COMPONENT_T *component)
-{
-   MMAL_STATUS_T status;
-   const char *basename;
-   mmal_worker_component_create msg;
-   mmal_worker_component_create_reply reply;
-   size_t replylen = sizeof(reply);
-   MMAL_COMPONENT_MODULE_T *module = NULL;
-   unsigned int ports_num, i;
-
-   LOG_TRACE("%s", name);
-
-   if (strstr(name, VIDEOCORE_PREFIX ".") != name)
-      return MMAL_ENOSYS;
-
-   basename = name + sizeof(VIDEOCORE_PREFIX ".") - 1;
-   if (strlen(basename) >= sizeof(msg.name)-1)
-   {
-      vcos_assert(0);
-      return MMAL_EINVAL;
-   }
-
-   msg.client_component = component;
-   /* coverity[secure_coding] Length tested above */
-   strcpy(msg.name, basename);
-#ifdef __linux__
-   msg.pid = getpid();
-#endif
-
-   status = mmal_vc_init();
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to initialise mmal ipc for '%s' (%i:%s)",
-                name, status, mmal_status_to_string(status));
-      return status;
-   }
-   // claim VC for entire duration of component.
-   status = mmal_vc_use();
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                                     MMAL_WORKER_COMPONENT_CREATE, &reply, &replylen, MMAL_FALSE);
-
-   vcos_log_info("%s: %s: handle 0x%x status %d reply status %d",
-                 __FUNCTION__, name, reply.component_handle, status, reply.status);
-
-   if (status == MMAL_SUCCESS)
-   {
-      vcos_assert(replylen == sizeof(reply));
-      status = reply.status;
-   }
-
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("failed to create component '%s' (%i:%s)", name, status,
-                mmal_status_to_string(status));
-      mmal_vc_release();
-      mmal_vc_deinit();
-      return status;
-   }
-
-   /* Component has been created, allocate our context. */
-   status = MMAL_ENOMEM;
-   ports_num = 1 + reply.input_num + reply.output_num + reply.clock_num;
-   module = vcos_calloc(1, sizeof(*module) + ports_num * sizeof(*module->ports), "mmal_vc_module");
-   if (!module)
-   {
-      mmal_worker_component_destroy msg;
-      mmal_worker_reply reply;
-      size_t replylen = sizeof(reply);
-      MMAL_STATUS_T destroy_status;
-
-      destroy_status = mmal_vc_sendwait_message(mmal_vc_get_client(), &msg.header, sizeof(msg),
-                               MMAL_WORKER_COMPONENT_DESTROY, &reply, &replylen, MMAL_FALSE);
-      vcos_assert(destroy_status == MMAL_SUCCESS);
-      mmal_vc_release();
-      mmal_vc_deinit();
-      return status;
-   }
-   module->ports = (MMAL_PORT_MODULE_T **)&module[1];
-   module->component_handle = reply.component_handle;
-   component->priv->module = module;
-
-   /* Allocate our local ports. Control port reallocated to set module size. */
-   mmal_port_free(component->control);
-   component->control = mmal_port_alloc(component, MMAL_PORT_TYPE_CONTROL,
-                                        sizeof(MMAL_PORT_MODULE_T));
-   if (!component->control)
-      goto fail;
-   component->input = mmal_ports_alloc(component, reply.input_num, MMAL_PORT_TYPE_INPUT,
-                                       sizeof(MMAL_PORT_MODULE_T));
-   if (!component->input)
-      goto fail;
-   component->input_num = reply.input_num;
-   component->output = mmal_ports_alloc(component, reply.output_num, MMAL_PORT_TYPE_OUTPUT,
-                                        sizeof(MMAL_PORT_MODULE_T));
-   if (!component->output)
-      goto fail;
-   component->output_num = reply.output_num;
-   component->clock = mmal_ports_alloc(component, reply.clock_num, MMAL_PORT_TYPE_CLOCK,
-                                        sizeof(MMAL_PORT_MODULE_T));
-   if (!component->clock)
-      goto fail;
-   component->clock_num = reply.clock_num;
-
-   /* We want to do the buffer callbacks to the client into a separate thread.
-    * We'll need to queue these callbacks and have an action which does the actual callback. */
-   module->callback_queue = mmal_queue_create();
-   if (!module->callback_queue)
-      goto fail;
-   status = mmal_component_action_register(component, mmal_vc_do_callback);
-   if (status != MMAL_SUCCESS)
-      goto fail;
-
-   LOG_TRACE(" handle %i", reply.component_handle);
-
-   module->ports[module->ports_num] = component->control->priv->module;
-   module->ports[module->ports_num]->port = component->control;
-   module->ports[module->ports_num]->component_handle = module->component_handle;
-   module->ports_num++;
-
-   for (i = 0; i < component->input_num; i++, module->ports_num++)
-   {
-      module->ports[module->ports_num] = component->input[i]->priv->module;
-      module->ports[module->ports_num]->port = component->input[i];
-      module->ports[module->ports_num]->component_handle = module->component_handle;
-   }
-
-   for (i = 0; i < component->output_num; i++, module->ports_num++)
-   {
-      module->ports[module->ports_num] = component->output[i]->priv->module;
-      module->ports[module->ports_num]->port = component->output[i];
-      module->ports[module->ports_num]->component_handle = module->component_handle;
-   }
-
-   for (i = 0; i < component->clock_num; i++, module->ports_num++)
-   {
-      module->ports[module->ports_num] = component->clock[i]->priv->module;
-      module->ports[module->ports_num]->port = component->clock[i];
-      module->ports[module->ports_num]->component_handle = module->component_handle;
-   }
-
-   /* Get the ports info */
-   for (i = 0; i < module->ports_num; i++)
-   {
-      MMAL_PORT_T *port = module->ports[i]->port;
-      port->priv->pf_set_format = mmal_vc_port_set_format;
-      port->priv->pf_enable = mmal_vc_port_enable;
-      port->priv->pf_disable = mmal_vc_port_disable;
-      port->priv->pf_send = mmal_vc_port_send;
-      port->priv->pf_flush = mmal_vc_port_flush;
-      port->priv->pf_connect = mmal_vc_port_connect;
-      port->priv->pf_parameter_set = mmal_vc_port_parameter_set;
-      port->priv->pf_parameter_get = mmal_vc_port_parameter_get;
-      port->priv->pf_payload_alloc = mmal_vc_port_payload_alloc;
-      port->priv->pf_payload_free = mmal_vc_port_payload_free;
-      port->priv->module->component_handle = module->component_handle;
-      port->priv->module->magic = MMAL_MAGIC;
-
-      status = mmal_vc_port_info_get(port);
-      if (status != MMAL_SUCCESS)
-         goto fail;
-   }
-
-   /* Initialise the vc client context which will be used for our event buffers */
-   module->event_ctx_initialised = MMAL_FALSE;
-   module->event_ctx.magic = MMAL_MAGIC;
-   module->event_ctx.callback_event = mmal_vc_port_send_event_callback;
-
-   /* populate component structure */
-   component->priv->pf_enable = mmal_vc_component_enable;
-   component->priv->pf_disable = mmal_vc_component_disable;
-   component->priv->pf_destroy = mmal_vc_component_destroy;
-   return MMAL_SUCCESS;
-
-fail:
-   mmal_vc_component_destroy(component);
-   return status;
-}
-
-MMAL_CONSTRUCTOR(mmal_register_component_videocore);
-void mmal_register_component_videocore(void)
-{
-   mmal_vc_shm_init();
-   mmal_component_supplier_register(VIDEOCORE_PREFIX, mmal_vc_component_create);
-}
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.h
deleted file mode 100644
index c80fb10..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api.h
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_VC_API_H
-#define MMAL_VC_API_H
-
-/** @file
-  *
-  * Public API for MMAL VC client. Most functionality is exposed
-  * via MMAL itself.
-  */
-
-#include "interface/mmal/mmal_types.h"
-#include "interface/mmal/mmal_parameters.h"
-#include "interface/mmal/mmal_port.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** State of components created by the VC adaptation layer, used for
- * statistics reporting.
- */
-typedef enum {
-   MMAL_STATS_COMP_IDLE,
-   MMAL_STATS_COMP_CREATED,
-   MMAL_STATS_COMP_DESTROYING,
-   MMAL_STATS_COMP_DESTROYED,
-   MMAL_STATS_COMP_UNUSED = 0xffffffff /* force 32bit */
-} MMAL_STATS_COMP_STATE_T;
-
-/** Per-component statistics collected by the VC adaptation layer.
- */
-struct MMAL_VC_COMP_STATS_T {
-   struct MMAL_DRIVER_COMPONENT_T *comp;
-   MMAL_STATS_COMP_STATE_T state;
-   uint32_t pid;
-   uint32_t pool_mem_alloc_size;
-   char name[20];
-};
-
-/** VC adaptation layer statistics.
- */
-struct MMAL_VC_STATS_T
-{
-   struct
-   {
-      uint32_t rx;               /**< Count of data buffers received */
-      uint32_t rx_zero_copy;     /**< Count of zero-copy data buffers received */
-      uint32_t rx_empty;         /**< Empty data buffers (to be filled) */
-      uint32_t rx_fails;         /**< Gave up partway through */
-      uint32_t tx;               /**< Count of data buffers sent */
-      uint32_t tx_zero_copy;     /**< Count of zero-copy data buffers sent */
-      uint32_t tx_empty;         /**< Count of empty data buffers sent */
-      uint32_t tx_fails;         /**< Gave up partway through */
-      uint32_t tx_short_msg;     /**< Messages sent directly in the control message */
-      uint32_t rx_short_msg;     /**< Messages received directly in the control message */
-   } buffers;
-   struct service
-   {
-      uint32_t created;          /**< How many services created */
-      uint32_t pending_destroy;  /**< How many destroyed */
-      uint32_t destroyed;        /**< How many destroyed */
-      uint32_t failures;         /**< Failures to create a service */
-   } service;
-   struct commands
-   {
-      uint32_t bad_messages;
-      uint32_t executed;
-      uint32_t failed;
-      uint32_t replies;
-      uint32_t reply_fails;
-   } commands;
-   struct
-   {
-      uint32_t tx;               /**< Count of events sent */
-      uint32_t tx_fails;         /**< Count of events not fully sent */
-   } events;
-   struct
-   {
-      uint32_t created;
-      uint32_t destroyed;
-      uint32_t destroying;
-      uint32_t failed;
-      uint32_t list_size;
-      struct MMAL_VC_COMP_STATS_T component_list[8];
-   } components;
-   struct
-   {
-      uint32_t enqueued_messages;
-      uint32_t dequeued_messages;
-      uint32_t max_parameter_set_delay;
-      uint32_t max_messages_waiting;
-   } worker;
-
-};
-typedef struct MMAL_VC_STATS_T MMAL_VC_STATS_T;
-
-/* Simple circular text buffer used to store 'interesting' data
- * from MMAL clients. e.g. settings for each picture taken */
-struct MMAL_VC_HOST_LOG_T
-{
-   /** Simple circular buffer of plain text log messages separated by NUL */
-   char buffer[16 << 10];
-   /** For VCDBG validation and to help detect buffer overflow */
-   uint32_t magic;
-   /** Write offset into buffer */
-   int32_t offset;
-   /** Counter of host messages logged since boot */
-   unsigned count;
-};
-typedef struct MMAL_VC_HOST_LOG_T MMAL_VC_HOST_LOG_T;
-
-/** Status from querying MMAL core statistics.
- */
-typedef enum
-{
-   MMAL_STATS_FOUND,
-   MMAL_STATS_COMPONENT_NOT_FOUND,
-   MMAL_STATS_PORT_NOT_FOUND,
-   MMAL_STATS_INVALID = 0x7fffffff
-} MMAL_STATS_RESULT_T;
-
-MMAL_STATUS_T mmal_vc_init(void);
-void mmal_vc_deinit(void);
-
-MMAL_STATUS_T mmal_vc_use(void);
-MMAL_STATUS_T mmal_vc_release(void);
-
-MMAL_STATUS_T mmal_vc_get_version(uint32_t *major, uint32_t *minor, uint32_t *minimum);
-MMAL_STATUS_T mmal_vc_get_stats(MMAL_VC_STATS_T *stats, int reset);
-
-/** Return the MMAL core statistics for a given component/port.
- *
- * @param stats         Updated with given port statistics
- * @param result        Whether the port/component was found
- * @param name          Filled in with the name of the port
- * @param namelen       Length of name
- * @param component     Which component (indexed from zero)
- * @param port_type     Which type of port
- * @param port          Which port (index from zero)
- * @param reset         Reset the stats.
- */
-MMAL_STATUS_T mmal_vc_get_core_stats(MMAL_CORE_STATISTICS_T *stats,
-                                     MMAL_STATS_RESULT_T *result,
-                                     char *name,
-                                     size_t namelen,
-                                     MMAL_PORT_TYPE_T type,
-                                     unsigned component,
-                                     unsigned port,
-                                     MMAL_CORE_STATS_DIR dir,
-                                     MMAL_BOOL_T reset);
-/**
- * Stores an arbitrary text message in a circular buffer inside the MMAL VC server.
- * The purpose of this message is to log high level events from the host in order
- * to diagnose problems that require multiple actions to reproduce. e.g. taking
- * multiple pictures with different settings.
- *
- * @param   msg  The message text.
- * @return  MMAL_SUCCESS if the message was logged or MMAL_ENOSYS if the API
- *          if not supported.
- */
-MMAL_STATUS_T mmal_vc_host_log(const char *msg);
-
-/* For backwards compatibility in builds */
-#define MMAL_VC_API_HAVE_HOST_LOG
-
-/* VC DEBUG ONLY ************************************************************/
-/** Consumes memory in the relocatable heap.
- *
- * The existing reserved memory is freed first then the new chunk is allocated.
- * If zero is specified for the size then the previously reserved memory
- * is freed and no allocation occurs.
- *
- * At startup no memory is reserved.
- *
- * @param size    Size of memory to consume in bytes.
- * @param handle  Set to the mem handle for the reserved memory or zero
- *                if no memory was allocated.
- * @return        MMAL_SUCCESS if memory was reserved (or size zero requested),
- *                MMAL_ENOSPC if the allocation failed or MMAL_ENOSYS if the
- *                API is not supported e.g in release mode VC images.
- * @internal
- */
-MMAL_STATUS_T mmal_vc_consume_mem(size_t size, uint32_t *handle);
-
-/** Trigger LMK action from VC, for diagnostics.
- * @internal
- */
-MMAL_STATUS_T mmal_vc_lmk(uint32_t alloc_size);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api_drm.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api_drm.c
deleted file mode 100644
index a926a86..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api_drm.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "mmal_vc_api_drm.h"
-#include "mmal_vc_api.h"
-#include "interface/mmal/mmal_logging.h"
-#include "interface/mmal/mmal.h"
-#include "mmal_vc_api.h"
-#include "mmal_vc_msgs.h"
-#include "mmal_vc_client_priv.h"
-#include "mmal_vc_opaque_alloc.h"
-#include "mmal_vc_shm.h"
-#include "interface/mmal/util/mmal_util.h"
-#include "interface/mmal/core/mmal_component_private.h"
-#include "interface/mmal/core/mmal_port_private.h"
-#include "interface/mmal/core/mmal_buffer_private.h"
-#include "interface/vcos/vcos.h"
-
-
-int mmal_vc_drm_get_time(unsigned int * time)
-{
-   MMAL_STATUS_T status;
-   mmal_worker_msg_header req;
-   mmal_worker_drm_get_time_reply reply;
-   size_t len = sizeof(reply);
-   status = mmal_vc_init();
-   if (status != MMAL_SUCCESS) return status;
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
-                                     &req, sizeof(req),
-                                     MMAL_WORKER_DRM_GET_TIME,
-                                     &reply, &len, MMAL_FALSE);
-   *time = reply.time;
-   mmal_vc_deinit();
-   return status;
-}
-
-
-int mmal_vc_drm_get_lhs32(unsigned char * into)
-{
-   MMAL_STATUS_T status;
-   mmal_worker_msg_header req;
-   mmal_worker_drm_get_lhs32_reply reply;
-   size_t len = sizeof(reply);
-   status = mmal_vc_init();
-   if (status != MMAL_SUCCESS) return status;
-
-   status = mmal_vc_sendwait_message(mmal_vc_get_client(),
-                                     &req, sizeof(req),
-                                     MMAL_WORKER_DRM_GET_LHS32,
-                                     &reply, &len, MMAL_FALSE);
-   memcpy(into, reply.secret, 32);
-   mmal_vc_deinit();
-   return status;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api_drm.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api_drm.h
deleted file mode 100644
index 04688b6..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_api_drm.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifndef MMAL_VC_API_DRM_H
-#define MMAL_VC_API_DRM_H
-
-/** @file
-  *
-  * Public API for MMAL VC client. (Divx DRM part)
-  */
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// Reads the current clock (in microseconds) into the "time" variable.
-// Returns zero on success, nonszero on failure
-int mmal_vc_drm_get_time(unsigned int * time);
-
-// Reads the local hardware secret into the "into" variable (needs to be 32 bytes of space for this)
-// Returns 0 on success, nonzero on failure
-// Usage:
-//   unsigned char buffer[32];
-//   success = mmal_vc_divx_drm_get_lhs(buffer);
-int mmal_vc_drm_get_lhs32(unsigned char * into);
-
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client.c
deleted file mode 100644
index 4309256..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client.c
+++ /dev/null
@@ -1,821 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-#include "mmal.h"
-#include "mmal_vc_msgs.h"
-#include "mmal_vc_api.h"
-#include "mmal_vc_client_priv.h"
-#include "interface/vcos/vcos.h"
-#include "vchiq_util.h"
-#include "interface/mmal/core/mmal_buffer_private.h"
-#include "interface/mmal/core/mmal_component_private.h"
-#include "interface/mmal/core/mmal_port_private.h"
-#include "interface/mmal/util/mmal_list.h"
-#include "interface/mmal/util/mmal_util.h"
-
-#define VCOS_LOG_CATEGORY (&mmal_ipc_log_category)
-#include "interface/mmal/mmal_logging.h"
-
-#include <stdio.h>
-
-#define MAX_WAITERS 16
-static VCOS_ONCE_T once = VCOS_ONCE_INIT;
-static VCHIQ_INSTANCE_T mmal_vchiq_instance;
-static VCOS_LOG_CAT_T mmal_ipc_log_category;
-
-/** Client threads use one of these to wait for
- * a reply from VideoCore.
- */
-typedef struct MMAL_WAITER_T
-{
-   VCOS_SEMAPHORE_T sem;
-   unsigned inuse;
-   void *dest;                   /**< Where to write reply */
-   size_t destlen;               /**< Max length for reply */
-} MMAL_WAITER_T;
-
-/** We have an array of waiters and allocate them to waiting
-  * threads. They can be released back to the pool in any order.
-  * If there are none free, the calling thread will block until
-  * one becomes available.
-  */
-typedef struct 
-{
-   MMAL_WAITER_T waiters[MAX_WAITERS];
-   VCOS_SEMAPHORE_T sem;
-} MMAL_WAITPOOL_T;
-
-struct MMAL_CLIENT_T
-{
-   int refcount;
-   int usecount;
-   VCOS_MUTEX_T lock;
-   VCHIQ_SERVICE_HANDLE_T service;
-   MMAL_WAITPOOL_T waitpool;
-   VCOS_MUTEX_T bulk_lock;
-
-   MMAL_BOOL_T inited;
-};
-
-/* One client per process/VC connection. Multiple threads may
- * be using a single client.
- */
-static MMAL_CLIENT_T client;
-
-static void init_once(void)
-{
-   vcos_mutex_create(&client.lock, VCOS_FUNCTION);
-}
-
-/** Create a pool of wait-structures.
-  */
-static MMAL_STATUS_T create_waitpool(MMAL_WAITPOOL_T *waitpool)
-{
-   MMAL_STATUS_T status;
-   int i;
-
-   status = vcos_semaphore_create(&waitpool->sem, VCOS_FUNCTION,
-                                  MAX_WAITERS);
-   if (status != MMAL_SUCCESS)
-      return status;
-
-   for (i=0; i<MAX_WAITERS; i++)
-   {
-      waitpool->waiters[i].inuse = 0;
-      status = vcos_semaphore_create(&waitpool->waiters[i].sem,
-                                     "mmal waiter", 0);
-      if (status != MMAL_SUCCESS)
-         break;
-   }
-
-   if (status != MMAL_SUCCESS)
-   {
-      /* clean up */
-      i--;
-      while (i>=0)
-      {
-         vcos_semaphore_delete(&waitpool->waiters[i].sem);
-         i--;
-      }
-      vcos_semaphore_delete(&waitpool->sem);
-   }
-   return status;
-}
-
-static void destroy_waitpool(MMAL_WAITPOOL_T *waitpool)
-{
-   int i;
-   for (i=0; i<MAX_WAITERS; i++)
-      vcos_semaphore_delete(&waitpool->waiters[i].sem);
-
-   vcos_semaphore_delete(&waitpool->sem);
-}
-
-/** Grab a waiter from the pool. Return immediately if one already
-  * available, or wait for one to become available.
-  */
-static MMAL_WAITER_T *get_waiter(MMAL_CLIENT_T *client)
-{
-   int i;
-   MMAL_WAITER_T *waiter = NULL;
-   vcos_semaphore_wait(&client->waitpool.sem);
-   vcos_mutex_lock(&client->lock);
-   for (i=0; i<MAX_WAITERS; i++)
-   {
-      if (client->waitpool.waiters[i].inuse == 0)
-         break;
-   }
-   /* If this fails, the semaphore is not working */
-   if (vcos_verify(i != MAX_WAITERS))
-   {
-      waiter = client->waitpool.waiters+i;
-      waiter->inuse = 1;
-   }
-   vcos_mutex_unlock(&client->lock);
-
-   return waiter;
-}
-
-/** Return a waiter to the pool.
-  */
-static void release_waiter(MMAL_CLIENT_T *client, MMAL_WAITER_T *waiter)
-{
-   LOG_TRACE("at %p", waiter);
-   vcos_assert(waiter);
-   vcos_assert(waiter->inuse);
-   waiter->inuse = 0;
-   vcos_semaphore_post(&client->waitpool.sem);
-}
-
-static MMAL_PORT_T *mmal_vc_port_by_number(MMAL_COMPONENT_T *component, uint32_t type, uint32_t number)
-{
-   switch (type)
-   {
-      case MMAL_PORT_TYPE_CONTROL:
-         vcos_assert(number == 0);
-         return component->control;
-      case MMAL_PORT_TYPE_INPUT:
-         vcos_assert(number < component->input_num);
-         return component->input[number];
-      case MMAL_PORT_TYPE_OUTPUT:
-         vcos_assert(number < component->output_num);
-         return component->output[number];
-      case MMAL_PORT_TYPE_CLOCK:
-         vcos_assert(number < component->clock_num);
-         return component->clock[number];
-   }
-
-   return NULL;
-}
-
-static void mmal_vc_handle_event_msg(VCHIQ_HEADER_T *vchiq_header,
-                                    VCHIQ_SERVICE_HANDLE_T service,
-                                    void *context)
-{
-   mmal_worker_event_to_host *msg = (mmal_worker_event_to_host *)vchiq_header->data;
-   MMAL_COMPONENT_T *component = msg->client_component;
-   MMAL_BUFFER_HEADER_T *buffer;
-   MMAL_STATUS_T status;
-   MMAL_PORT_T *port;
-
-   LOG_DEBUG("event to host, cmd 0x%08x len %d to component %p port (%d,%d)",
-         msg->cmd, msg->length, msg->client_component, msg->port_type, msg->port_num);
-   (void)context;
-
-   port = mmal_vc_port_by_number(component, msg->port_type, msg->port_num);
-   if (!vcos_verify(port))
-   {
-      LOG_ERROR("port (%i,%i) doesn't exist", (int)msg->port_type, (int)msg->port_num);
-      goto error;
-   }
-
-   status = mmal_port_event_get(port, &buffer, msg->cmd);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("no event buffer available to receive event (%i)", (int)status);
-      goto error;
-   }
-
-   if (!vcos_verify(msg->length <= buffer->alloc_size))
-   {
-      LOG_ERROR("event buffer to small to receive event (%i/%i)",
-                (int)buffer->alloc_size, (int)msg->length);
-      goto error;
-   }
-   buffer->length = msg->length;
-
-   /* Sanity check that the event buffers have the proper vc client context */
-   if (!vcos_verify(mmal_buffer_header_driver_data(buffer)->magic == MMAL_MAGIC &&
-          mmal_buffer_header_driver_data(buffer)->client_context &&
-          mmal_buffer_header_driver_data(buffer)->client_context->magic == MMAL_MAGIC &&
-          mmal_buffer_header_driver_data(buffer)->client_context->callback_event))
-   {
-      LOG_ERROR("event buffers not configured properly by component");
-      goto error;
-   }
-
-   if (buffer->length > MMAL_WORKER_EVENT_SPACE)
-   {
-      /* a buffer full of data for us to process */
-      int len = buffer->length;
-      len = (len+3) & (~3);
-      LOG_DEBUG("queue event bulk rx: %p, %d", buffer->data, buffer->length);
-      msg->delayed_buffer = buffer;
-
-      VCHIQ_STATUS_T vst = vchiq_queue_bulk_receive(service, buffer->data, len, vchiq_header);
-      if (vst != VCHIQ_SUCCESS)
-      {
-         LOG_TRACE("queue event bulk rx len %d failed to start", buffer->length);
-         mmal_buffer_header_release(buffer);
-         goto error;
-      }
-   }
-   else
-   {
-      if (msg->length)
-         memcpy(buffer->data, msg->data, msg->length);
-
-      mmal_buffer_header_driver_data(buffer)->client_context->callback_event(port, buffer);
-      LOG_DEBUG("done callback back to client");
-      vchiq_release_message(service, vchiq_header);
-   }
-
-   return;
-
-error:
-   /* FIXME: How to abort bulk receive if necessary? */
-   msg->length = 0; /* FIXME: set a buffer flag to signal error */
-   vchiq_release_message(service, vchiq_header);
-}
-
-static MMAL_STATUS_T mmal_vc_use_internal(MMAL_CLIENT_T *client)
-{
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   vcos_mutex_lock(&client->lock);
-   if(client->usecount++ == 0)
-   {
-      if(vchiq_use_service(client->service) != VCHIQ_SUCCESS)
-      {
-         client->usecount--;
-         status = MMAL_EIO;
-      }
-   }
-   vcos_mutex_unlock(&client->lock);
-   return status;
-}
-
-static MMAL_STATUS_T mmal_vc_release_internal(MMAL_CLIENT_T *client)
-{
-   MMAL_STATUS_T status = MMAL_SUCCESS;
-   vcos_mutex_lock(&client->lock);
-   if(--client->usecount == 0)
-   {
-      if(vchiq_release_service(client->service) != VCHIQ_SUCCESS)
-      {
-         client->usecount++;
-         status = MMAL_EIO;
-      }
-   }
-   vcos_mutex_unlock(&client->lock);
-   return status;
-}
-
-
-/** Callback invoked by VCHIQ
-  */
-static VCHIQ_STATUS_T mmal_vc_vchiq_callback(VCHIQ_REASON_T reason,
-                                             VCHIQ_HEADER_T *vchiq_header,
-                                             VCHIQ_SERVICE_HANDLE_T service,
-                                             void *context)
-{
-   LOG_TRACE("reason %d", reason);
-
-   switch (reason)
-   {
-   case VCHIQ_MESSAGE_AVAILABLE:
-      {
-         mmal_worker_msg_header *msg = (mmal_worker_msg_header*)vchiq_header->data;
-         vcos_assert(msg->magic == MMAL_MAGIC);
-
-         if (msg->msgid == MMAL_WORKER_BUFFER_TO_HOST)
-         {
-            LOG_TRACE("buffer to host");
-            mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)vchiq_header->data;
-            LOG_TRACE("len %d context %p", msg->buffer_header.length, msg->drvbuf.client_context);
-            vcos_assert(msg->drvbuf.client_context);
-            vcos_assert(msg->drvbuf.client_context->magic == MMAL_MAGIC);
-
-            /* If the buffer is referencing another, need to replicate it here
-             * in order to use the reference buffer's payload and ensure the
-             * reference is not released prematurely */
-            if (msg->has_reference)
-               mmal_buffer_header_replicate(msg->drvbuf.client_context->buffer,
-                                            msg->drvbuf_ref.client_context->buffer);
-
-            /* Sanity check the size of the transfer so we don't overrun our buffer */
-            if (!vcos_verify(msg->buffer_header.offset + msg->buffer_header.length <=
-                             msg->drvbuf.client_context->buffer->alloc_size))
-            {
-               LOG_TRACE("buffer too small (%i, %i)",
-                         msg->buffer_header.offset + msg->buffer_header.length,
-                         msg->drvbuf.client_context->buffer->alloc_size);
-               msg->buffer_header.length = 0; /* FIXME: set a buffer flag to signal error */
-               msg->drvbuf.client_context->callback(msg);
-               vchiq_release_message(service, vchiq_header);
-               break;
-            }
-            /*To handle VC to HOST filled buffer callback of EOS buffer to receive in sync with data buffers*/
-            if (!msg->is_zero_copy &&
-                  (msg->buffer_header.length != 0 ||
-                     (msg->buffer_header.flags & MMAL_BUFFER_HEADER_FLAG_EOS)))
-            {
-               /* a buffer full of data for us to process */
-               VCHIQ_STATUS_T vst = VCHIQ_SUCCESS;
-               LOG_TRACE("queue bulk rx: %p, %d", msg->drvbuf.client_context->buffer->data +
-                         msg->buffer_header.offset, msg->buffer_header.length);
-               int len = msg->buffer_header.length;
-               len = (len+3) & (~3);
-
-               if (!len && (msg->buffer_header.flags & MMAL_BUFFER_HEADER_FLAG_EOS))
-               {
-                  len = 8;
-               }
-               if (!msg->payload_in_message)
-               {
-                  /* buffer transferred using vchiq bulk xfer */
-                  vst = vchiq_queue_bulk_receive(service,
-                     msg->drvbuf.client_context->buffer->data + msg->buffer_header.offset,
-                     len, vchiq_header);
-
-                  if (vst != VCHIQ_SUCCESS)
-                  {
-                     LOG_TRACE("queue bulk rx len %d failed to start", msg->buffer_header.length);
-                     msg->buffer_header.length = 0; /* FIXME: set a buffer flag to signal error */
-                     msg->drvbuf.client_context->callback(msg);
-                     vchiq_release_message(service, vchiq_header);
-                  }
-               }
-               else if (msg->payload_in_message <= MMAL_VC_SHORT_DATA)
-               {
-                  /* we have already received the buffer data in the message! */
-                  MMAL_BUFFER_HEADER_T *dst = msg->drvbuf.client_context->buffer;
-                  LOG_TRACE("short data: dst = %p, dst->data = %p, len %d short len %d", dst, dst? dst->data : 0, msg->buffer_header.length, msg->payload_in_message);
-                  memcpy(dst->data, msg->short_data, msg->payload_in_message);
-                  dst->offset = 0;
-                  dst->length = msg->payload_in_message;
-                  vchiq_release_message(service, vchiq_header);
-                  msg->drvbuf.client_context->callback(msg);
-               }
-               else
-               {
-                  /* impossible short data length */
-                  LOG_ERROR("Message with invalid short payload length %d",
-                            msg->payload_in_message);
-                  vcos_assert(0);
-               }
-            }
-            else
-            {
-
-               /* Message received from videocore; the client_context should have
-                * been passed all the way through by videocore back to us, and will
-                * be picked up in the callback to complete the sequence.
-                */
-               LOG_TRACE("doing cb (%p) context %p",
-                         msg->drvbuf.client_context, msg->drvbuf.client_context ?
-                         msg->drvbuf.client_context->callback : 0);
-               msg->drvbuf.client_context->callback(msg);
-               LOG_TRACE("done callback back to client");
-               vchiq_release_message(service, vchiq_header);
-            }
-         }
-         else if (msg->msgid == MMAL_WORKER_EVENT_TO_HOST)
-         {
-            mmal_vc_handle_event_msg(vchiq_header, service, context);
-         }
-         else
-         {
-            MMAL_WAITER_T *waiter = msg->u.waiter;
-            LOG_TRACE("waking up waiter at %p", waiter);
-            vcos_assert(waiter->inuse);
-            int len = vcos_min(waiter->destlen, vchiq_header->size);
-            waiter->destlen = len;
-            LOG_TRACE("copying payload @%p to %p len %d", waiter->dest, msg, len);
-            memcpy(waiter->dest, msg, len);
-            vchiq_release_message(service, vchiq_header);
-            vcos_semaphore_post(&waiter->sem);
-         }
-      }
-      break;
-   case VCHIQ_BULK_TRANSMIT_DONE:
-      {
-         /* nothing to do here, need to wait for the copro to tell us it
-          * has emptied the buffer before we can recycle it, otherwise we
-          * end up feeding the copro with buffers it cannot handle.
-          */
-#ifdef VCOS_LOGGING_ENABLED
-         mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)context;
-#endif
-         LOG_TRACE("bulk tx done: %p, %d", msg->buffer_header.data, msg->buffer_header.length);
-      }
-      break;
-   case VCHIQ_BULK_RECEIVE_DONE:
-      {
-         VCHIQ_HEADER_T *header = (VCHIQ_HEADER_T *)context;
-         mmal_worker_msg_header *msg_hdr = (mmal_worker_msg_header*)header->data;
-         if (msg_hdr->msgid == MMAL_WORKER_BUFFER_TO_HOST)
-         {
-            mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)msg_hdr;
-            vcos_assert(msg->drvbuf.client_context->magic == MMAL_MAGIC);
-            msg->drvbuf.client_context->callback(msg);
-            LOG_TRACE("bulk rx done: %p, %d", msg->buffer_header.data, msg->buffer_header.length);
-         }
-         else
-         {
-            mmal_worker_event_to_host *msg = (mmal_worker_event_to_host *)msg_hdr;
-            MMAL_PORT_T *port = mmal_vc_port_by_number(msg->client_component, msg->port_type, msg->port_num);
-
-            vcos_assert(port);
-            mmal_buffer_header_driver_data(msg->delayed_buffer)->
-               client_context->callback_event(port, msg->delayed_buffer);
-            LOG_DEBUG("event bulk rx done, length %d", msg->length);
-         }
-         vchiq_release_message(service, header);
-      }
-      break;
-   case VCHIQ_BULK_RECEIVE_ABORTED:
-      {
-         VCHIQ_HEADER_T *header = (VCHIQ_HEADER_T *)context;
-         mmal_worker_msg_header *msg_hdr = (mmal_worker_msg_header*)header->data;
-         if (msg_hdr->msgid == MMAL_WORKER_BUFFER_TO_HOST)
-         {
-            mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)msg_hdr;
-            LOG_TRACE("bulk rx aborted: %p, %d", msg->buffer_header.data, msg->buffer_header.length);
-            vcos_assert(msg->drvbuf.client_context->magic == MMAL_MAGIC);
-            msg->buffer_header.flags |= MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED;
-            msg->drvbuf.client_context->callback(msg);
-         }
-         else
-         {
-            mmal_worker_event_to_host *msg = (mmal_worker_event_to_host *)msg_hdr;
-            MMAL_PORT_T *port = mmal_vc_port_by_number(msg->client_component, msg->port_type, msg->port_num);
-
-            vcos_assert(port);
-            LOG_DEBUG("event bulk rx aborted");
-            msg->delayed_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED;
-            mmal_buffer_header_driver_data(msg->delayed_buffer)->
-               client_context->callback_event(port, msg->delayed_buffer);
-         }
-         vchiq_release_message(service, header);
-      }
-      break;
-   case VCHIQ_BULK_TRANSMIT_ABORTED:
-      {
-         mmal_worker_buffer_from_host *msg = (mmal_worker_buffer_from_host *)context;
-         LOG_INFO("bulk tx aborted: %p, %d", msg->buffer_header.data, msg->buffer_header.length);
-         vcos_assert(msg->drvbuf.client_context->magic == MMAL_MAGIC);
-         /* Nothing to do as the VC side will release the buffer and notify us of the error */
-      }
-      break;
-   default:
-      break;
-   }
-
-   return VCHIQ_SUCCESS;
-}
-
-/** Send a message and wait for a reply.
-  *
-  * @param client       client to send message for
-  * @param msg_header   message vchiq_header to send
-  * @param size         length of message, including header
-  * @param msgid        message id
-  * @param dest         destination for reply
-  * @param destlen      size of destination, updated with actual length
-  * @param send_dummy_bulk whether to send a dummy bulk transfer
-  */
-MMAL_STATUS_T mmal_vc_sendwait_message(struct MMAL_CLIENT_T *client,
-                                       mmal_worker_msg_header *msg_header,
-                                       size_t size,
-                                       uint32_t msgid,
-                                       void *dest,
-                                       size_t *destlen,
-                                       MMAL_BOOL_T send_dummy_bulk)
-{
-   MMAL_STATUS_T ret;
-   MMAL_WAITER_T *waiter;
-   VCHIQ_STATUS_T vst;
-   VCHIQ_ELEMENT_T elems[] = {{msg_header, size}};
-
-   vcos_assert(size >= sizeof(mmal_worker_msg_header));
-   vcos_assert(dest);
-
-   if (!client->inited)
-   {
-      vcos_assert(0);
-      return MMAL_EINVAL;
-   }
-
-   if (send_dummy_bulk)
-      vcos_mutex_lock(&client->bulk_lock);
-
-   waiter = get_waiter(client);
-   msg_header->msgid  = msgid;
-   msg_header->u.waiter = waiter;
-   msg_header->magic  = MMAL_MAGIC;
-
-   waiter->dest    = dest;
-   waiter->destlen = *destlen;
-   LOG_TRACE("wait %p, reply to %p", waiter, dest);
-   mmal_vc_use_internal(client);
-
-   vst = vchiq_queue_message(client->service, elems, 1);
-
-   if (vst != VCHIQ_SUCCESS)
-   {
-      ret = MMAL_EIO;
-      if (send_dummy_bulk)
-        vcos_mutex_unlock(&client->bulk_lock);
-      goto fail_msg;
-   }
-
-   if (send_dummy_bulk)
-   {
-      uint32_t data_size = 8;
-      /* The data is just some dummy bytes so it's fine for it to be static */
-      static uint8_t data[8];
-      vst = vchiq_queue_bulk_transmit(client->service, data, data_size, msg_header);
-
-      vcos_mutex_unlock(&client->bulk_lock);
-
-      if (!vcos_verify(vst == VCHIQ_SUCCESS))
-      {
-         LOG_ERROR("failed bulk transmit");
-         /* This really should not happen and if it does, things will go wrong as
-          * we've already queued the vchiq message above. */
-         vcos_assert(0);
-         ret = MMAL_EIO;
-         goto fail_msg;
-      }
-   }
-
-   /* now wait for the reply...
-    *
-    * FIXME: we could do with a timeout here. Need to be careful to cancel
-    * the semaphore on a timeout.
-    */
-   vcos_semaphore_wait(&waiter->sem);
-
-   mmal_vc_release_internal(client);
-   LOG_TRACE("got reply (len %i/%i)", (int)*destlen, (int)waiter->destlen);
-   *destlen = waiter->destlen;
-
-   release_waiter(client, waiter);
-   return MMAL_SUCCESS;
-
-fail_msg:
-   mmal_vc_release_internal(client);
-
-   release_waiter(client, waiter);
-   return ret;
-}
-
-/** Send a message and do not wait for a reply.
-  *
-  * @note
-  * This function should only be called from within a mmal component, so
-  * vchiq_use/release_service calls aren't required (dealt with at higher level).
-  *
-  * @param client       client to send message for
-  * @param msg_header   message header to send
-  * @param size         length of message, including header
-  * @param msgid        message id
-  */
-MMAL_STATUS_T mmal_vc_send_message(MMAL_CLIENT_T *client,
-                                   mmal_worker_msg_header *msg_header, size_t size,
-                                   uint8_t *data, size_t data_size,
-                                   uint32_t msgid)
-{
-   VCHIQ_STATUS_T vst;
-   VCHIQ_ELEMENT_T elems[] = {{msg_header, size}};
-   MMAL_BOOL_T using_bulk_transfer = (data_size != 0);
-
-   LOG_TRACE("len %d", data_size);
-   vcos_assert(size >= sizeof(mmal_worker_msg_header));
-
-   if (!client->inited)
-   {
-      vcos_assert(0);
-      return MMAL_EINVAL;
-   }
-
-   if (using_bulk_transfer)
-      vcos_mutex_lock(&client->bulk_lock);
-
-   msg_header->msgid  = msgid;
-   msg_header->magic  = MMAL_MAGIC;
-
-   vst = vchiq_queue_message(client->service, elems, 1);
-
-   if (vst != VCHIQ_SUCCESS)
-   {
-      if (using_bulk_transfer)
-         vcos_mutex_unlock(&client->bulk_lock);
-
-      LOG_ERROR("failed");
-      goto error;
-   }
-
-   if (using_bulk_transfer)
-   {
-      LOG_TRACE("bulk transmit: %p, %i", data, data_size);
-
-      data_size = (data_size + 3) & ~3;
-      vst = vchiq_queue_bulk_transmit(client->service, data, data_size, msg_header);
-
-      vcos_mutex_unlock(&client->bulk_lock);
-
-      if (!vcos_verify(vst == VCHIQ_SUCCESS))
-      {
-         LOG_ERROR("failed bulk transmit");
-         /* This really should not happen and if it does, things will go wrong as
-          * we've already queued the vchiq message above. */
-         vcos_assert(0);
-         goto error;
-      }
-   }
-
-   return MMAL_SUCCESS;
-
- error:
-   return MMAL_EIO;
-}
-
-MMAL_STATUS_T mmal_vc_use(void)
-{
-   MMAL_STATUS_T status = MMAL_ENOTCONN;
-   if(client.inited)
-      status = mmal_vc_use_internal(&client);
-   return status;
-}
-
-MMAL_STATUS_T mmal_vc_release(void)
-{
-   MMAL_STATUS_T status = MMAL_ENOTCONN;
-   if(client.inited)
-      status = mmal_vc_release_internal(&client);
-   return status;
-}
-
-MMAL_STATUS_T mmal_vc_init(void)
-{
-   VCHIQ_SERVICE_PARAMS_T vchiq_params;
-   MMAL_BOOL_T vchiq_initialised = 0, waitpool_initialised = 0;
-   MMAL_BOOL_T service_initialised = 0;
-   MMAL_STATUS_T status = MMAL_EIO;
-   VCHIQ_STATUS_T vchiq_status;
-   int count;
-
-   vcos_once(&once, init_once);
-
-   vcos_mutex_lock(&client.lock);
-
-   count = client.refcount++;
-   if (count > 0)
-   {
-      /* Already initialised so nothing to do */
-      vcos_mutex_unlock(&client.lock);
-      return MMAL_SUCCESS;
-   }
-
-   vcos_log_register("mmalipc", VCOS_LOG_CATEGORY);
-
-   /* Initialise a VCHIQ instance */
-   vchiq_status = vchiq_initialise(&mmal_vchiq_instance);
-   if (vchiq_status != VCHIQ_SUCCESS)
-   {
-      LOG_ERROR("failed to initialise vchiq");
-      status = MMAL_EIO;
-      goto error;
-   }
-   vchiq_initialised = 1;
-
-   vchiq_status = vchiq_connect(mmal_vchiq_instance);
-   if (vchiq_status != VCHIQ_SUCCESS)
-   {
-      LOG_ERROR("failed to connect to vchiq");
-      status = MMAL_EIO;
-      goto error;
-   }
-
-   memset(&vchiq_params,0,sizeof(vchiq_params));
-   vchiq_params.fourcc = MMAL_CONTROL_FOURCC();
-   vchiq_params.callback = mmal_vc_vchiq_callback;
-   vchiq_params.userdata = &client;
-   vchiq_params.version = WORKER_VER_MAJOR;
-   vchiq_params.version_min = WORKER_VER_MINIMUM;
-
-   vchiq_status = vchiq_open_service(mmal_vchiq_instance, &vchiq_params, &client.service);
-   if (vchiq_status != VCHIQ_SUCCESS)
-   {
-      LOG_ERROR("could not open vchiq service");
-      status = MMAL_EIO;
-      goto error;
-   }
-   client.usecount = 1; /* usecount set to 1 by the open call. */
-   service_initialised = 1;
-
-   status = create_waitpool(&client.waitpool);
-   if (status != MMAL_SUCCESS)
-   {
-      LOG_ERROR("could not create wait pool");
-      goto error;
-   }
-   waitpool_initialised = 1;
-
-   if (vcos_mutex_create(&client.bulk_lock, "mmal client bulk lock") != VCOS_SUCCESS)
-   {
-      LOG_ERROR("could not create bulk lock");
-      status = MMAL_ENOSPC;
-      goto error;
-   }
-
-   client.inited = 1;
-
-   vcos_mutex_unlock(&client.lock);
-   /* assume we're not using VC immediately.  Do this outside the lock */
-   mmal_vc_release();
-
-
-   return MMAL_SUCCESS;
-
- error:
-   if (waitpool_initialised)
-      destroy_waitpool(&client.waitpool);
-   if (service_initialised)
-   {
-      client.usecount = 0;
-      vchiq_close_service(client.service);
-   }
-   if (vchiq_initialised)
-      vchiq_shutdown(mmal_vchiq_instance);
-   vcos_log_unregister(VCOS_LOG_CATEGORY);
-   client.refcount--;
-
-   vcos_mutex_unlock(&client.lock);
-   return status;
-}
-
-void mmal_vc_deinit(void)
-{
-   int count;
-
-   vcos_mutex_lock(&client.lock);
-   count = --client.refcount;
-   if (count != 0)
-   {
-      /* Still in use so don't do anything */
-      vcos_mutex_unlock(&client.lock);
-      return;
-   }
-
-   vcos_mutex_delete(&client.bulk_lock);
-   destroy_waitpool(&client.waitpool);
-   vchiq_close_service(client.service);
-   vchiq_shutdown(mmal_vchiq_instance);
-   vcos_log_unregister(VCOS_LOG_CATEGORY);
-
-   client.service = VCHIQ_SERVICE_HANDLE_INVALID;
-   client.inited = 0;
-   vcos_mutex_unlock(&client.lock);
-}
-
-MMAL_CLIENT_T *mmal_vc_get_client(void)
-{
-   return &client;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client_priv.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client_priv.h
deleted file mode 100644
index 0fc3aaa..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_client_priv.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_VC_CLIENT_H
-#define MMAL_VC_CLIENT_H
-
-/** @file mmal_vc_client_priv.h
-  *
-  * Internal API for vchiq_arm MMAL client.
-  */
-
-struct MMAL_CLIENT_T;
-typedef struct MMAL_CLIENT_T MMAL_CLIENT_T;
-
-void mmal_vc_client_init(void);
-
-/** Hold the context required when sending a buffer to the copro.
- */
-typedef struct MMAL_VC_CLIENT_BUFFER_CONTEXT_T
-{
-   uint32_t magic;
-
-   /** Called when VC is done with the buffer */
-   void (*callback)(struct mmal_worker_buffer_from_host *);
-
-   /** Called when VC sends an event */
-   void (*callback_event)(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *event);
-
-   /** The port this buffer was sent to */
-   MMAL_PORT_T *port;
-
-   /** The original buffer from the host. */
-   MMAL_BUFFER_HEADER_T *buffer;
-
-   /** The actual message sent to the host */
-   struct mmal_worker_buffer_from_host msg;
-} MMAL_VC_CLIENT_BUFFER_CONTEXT_T;
-
-
-MMAL_CLIENT_T *mmal_vc_get_client(void);
-
-MMAL_STATUS_T mmal_vc_sendwait_message(MMAL_CLIENT_T *client,
-                                       mmal_worker_msg_header *header,
-                                       size_t size,
-                                       uint32_t msgid,
-                                       void *dest,
-                                       size_t *destlen,
-                                       MMAL_BOOL_T send_dummy_bulk);
-
-MMAL_STATUS_T mmal_vc_send_message(MMAL_CLIENT_T *client,
-                                   mmal_worker_msg_header *header, size_t size,
-                                   uint8_t *data, size_t data_size,
-                                   uint32_t msgid);
-
-#endif
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.c
deleted file mode 100644
index ba53d45..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "mmal_vc_msgnames.h"
-#include "mmal_vc_msgs.h"
-
-/** Convert a message id to a name.
-  */
-const char *mmal_msgname(uint32_t id)
-{
-#define MSGNAME(x) { MMAL_WORKER_##x, #x }
-   static struct {
-      uint32_t id;
-      const char *name;
-   } msgnames[] = {
-      MSGNAME(QUIT),
-      MSGNAME(SERVICE_CLOSED),
-      MSGNAME(GET_VERSION),
-      MSGNAME(COMPONENT_CREATE),
-      MSGNAME(COMPONENT_DESTROY),
-      MSGNAME(COMPONENT_ENABLE),
-      MSGNAME(COMPONENT_DISABLE),
-      MSGNAME(PORT_INFO_GET),
-      MSGNAME(PORT_INFO_SET),
-      MSGNAME(PORT_ACTION),
-      MSGNAME(BUFFER_FROM_HOST),
-      MSGNAME(BUFFER_TO_HOST),
-      MSGNAME(GET_STATS),
-      MSGNAME(PORT_PARAMETER_SET),
-      MSGNAME(PORT_PARAMETER_GET),
-      MSGNAME(EVENT_TO_HOST),
-      MSGNAME(GET_CORE_STATS_FOR_PORT),
-      MSGNAME(OPAQUE_ALLOCATOR),
-      MSGNAME(CONSUME_MEM),
-      MSGNAME(LMK),
-      MSGNAME(OPAQUE_ALLOCATOR_DESC),
-      MSGNAME(DRM_GET_LHS32),
-      MSGNAME(DRM_GET_TIME),
-      MSGNAME(BUFFER_FROM_HOST_ZEROLEN),
-      MSGNAME(PORT_FLUSH),
-      MSGNAME(HOST_LOG),
-      { 0, NULL },
-   };
-   vcos_static_assert(sizeof(msgnames)/sizeof(msgnames[0]) == MMAL_WORKER_MSG_LAST);
-   int i = 0;
-   while (msgnames[i].name)
-   {
-      if (msgnames[i].id == id)
-         return msgnames[i].name;
-      i++;
-   }
-   return "unknown-message";
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.h
deleted file mode 100644
index 12a97c7..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgnames.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_VC_MSGNAMES_H
-#define MMAL_VC_MSGNAMES_H
-
-#include "interface/vcos/vcos.h"
-
-/** Convert a message id to a name.
-  */
-const char *mmal_msgname(uint32_t id);
-
-#endif
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgs.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgs.h
deleted file mode 100644
index ef21d81..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_msgs.h
+++ /dev/null
@@ -1,516 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_VC_MSGS_H
-#define MMAL_VC_MSGS_H
-
-/** @file mmal_vc_msgs.h
-  *
-  * Private message definitions, defining the message API between
-  * the host and VideoCore.
-  */
-#include "interface/vcos/vcos.h"
-#include "interface/mmal/mmal.h"
-#include "mmal_vc_api.h"
-
-#define MMAL_CONTROL_FOURCC() VCHIQ_MAKE_FOURCC('m','m','a','l')
-
-/* Major version indicates binary backwards compatiblity */
-#define WORKER_VER_MAJOR   15
-#define WORKER_VER_MINIMUM 10
-/* Minor version is not used normally.
- */
-#define WORKER_VER_MINOR   1
-#ifndef WORKER_VER_MINIMUM
-#endif
-
-#define VIDEOCORE_PREFIX "vc"
-
-#define MMAL_MAX_PORTS     8                 /**< Max ports per component */
-
-#define MMAL_WORKER_MAX_MSG_LEN  512
-#define MMAL_VC_CORE_STATS_NAME_MAX      32  /**< Length of the name in the core stats message */
-
-/** A MMAL_CONTROL_SERVICE_T gets space for a single message. This
-  * is the space allocated for these messages.
-  */
-#define MMAL_WORKER_MSG_LEN  28
-
-/** Maximum size of the format extradata.
- * FIXME: should probably be made bigger and maybe be passed separately from the info.
- */
-#define MMAL_FORMAT_EXTRADATA_MAX_SIZE 128
-
-/** Size of space reserved in a buffer message for short messages.
- */
-#define MMAL_VC_SHORT_DATA 128
-
-/** Message ids sent to worker thread.
-  */
-
-/* Please update the array in mmal_vc_msgnames.c if this is updated.
- */
-typedef enum {
-   MMAL_WORKER_QUIT = 1,
-   MMAL_WORKER_SERVICE_CLOSED,
-   MMAL_WORKER_GET_VERSION,
-   MMAL_WORKER_COMPONENT_CREATE,
-   MMAL_WORKER_COMPONENT_DESTROY,
-   MMAL_WORKER_COMPONENT_ENABLE,
-   MMAL_WORKER_COMPONENT_DISABLE,
-   MMAL_WORKER_PORT_INFO_GET,
-   MMAL_WORKER_PORT_INFO_SET,
-   MMAL_WORKER_PORT_ACTION,
-   MMAL_WORKER_BUFFER_FROM_HOST,
-   MMAL_WORKER_BUFFER_TO_HOST,
-   MMAL_WORKER_GET_STATS,
-   MMAL_WORKER_PORT_PARAMETER_SET,
-   MMAL_WORKER_PORT_PARAMETER_GET,
-   MMAL_WORKER_EVENT_TO_HOST,
-   MMAL_WORKER_GET_CORE_STATS_FOR_PORT,
-   MMAL_WORKER_OPAQUE_ALLOCATOR,
-   /* VC debug mode only - due to security, denial of service implications */
-   MMAL_WORKER_CONSUME_MEM,
-   MMAL_WORKER_LMK,
-   MMAL_WORKER_OPAQUE_ALLOCATOR_DESC,
-   MMAL_WORKER_DRM_GET_LHS32,
-   MMAL_WORKER_DRM_GET_TIME,
-   MMAL_WORKER_BUFFER_FROM_HOST_ZEROLEN,
-   MMAL_WORKER_PORT_FLUSH,
-   MMAL_WORKER_HOST_LOG,
-   MMAL_WORKER_MSG_LAST
-} MMAL_WORKER_CMD_T;
-
-/** Every message has one of these at the start.
-  */
-typedef struct
-{
-   uint32_t magic;
-   uint32_t msgid;
-   struct MMAL_CONTROL_SERVICE_T *control_service;       /** Handle to the control service */
-
-   union {
-      struct MMAL_WAITER_T *waiter;    /** User-land wait structure, passed back */
-   } u;
-
-   MMAL_STATUS_T status;            /** Result code, passed back */
-   /* Make sure this structure is 64 bit aligned */
-   uint32_t dummy;
-} mmal_worker_msg_header;
-
-/* Make sure mmal_worker_msg_header will preserve 64 bits alignment */
-vcos_static_assert(!(sizeof(mmal_worker_msg_header) & 0x7));
-
-/* Message structures sent to worker thread.
- */
-
-/** Tell the worker a service has closed. It should start to delete
-  * the associated components.
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-} mmal_worker_service_closed;
-vcos_static_assert(sizeof(mmal_worker_service_closed) <= MMAL_WORKER_MSG_LEN);
-
-/** Send from VC to host to report our version */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t flags;
-   uint32_t major;
-   uint32_t minor;
-   uint32_t minimum;
-} mmal_worker_version;
-
-/** Request component creation */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   void *client_component;             /** Client component */
-   char name[128];
-   uint32_t pid;                       /**< For debug */
-} mmal_worker_component_create;
-
-/** Reply to component-creation message. Reports back
-  * the number of ports.
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_STATUS_T status;
-   uint32_t component_handle;          /** Handle on VideoCore for component */
-   uint32_t input_num;                 /**< Number of input ports */
-   uint32_t output_num;                /**< Number of output ports */
-   uint32_t clock_num;                 /**< Number of clock ports */
-} mmal_worker_component_create_reply;
-vcos_static_assert(sizeof(mmal_worker_component_create_reply) <= MMAL_WORKER_MAX_MSG_LEN);
-
-/** Destroys a component
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t component_handle;          /**< which component */
-} mmal_worker_component_destroy;
-
-/** Enables a component
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t component_handle;          /**< which component */
-} mmal_worker_component_enable;
-
-/** Disable a component
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t component_handle;          /**< Which component */
-} mmal_worker_component_disable;
-
-/** Component port info. Used to get port info.
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t component_handle;          /**< Which component */
-   MMAL_PORT_TYPE_T port_type;         /**< Type of port */
-   uint32_t index;                     /**< Which port of given type to get */
-} mmal_worker_port_info_get;
-vcos_static_assert(sizeof(mmal_worker_port_info_get) <= MMAL_WORKER_MAX_MSG_LEN);
-
-/** Component port info. Used to set port info.
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t component_handle;          /**< Which component */
-   MMAL_PORT_TYPE_T port_type;         /**< Type of port */
-   uint32_t index;                     /**< Which port of given type to get */
-   MMAL_PORT_T port;
-   MMAL_ES_FORMAT_T format;
-   MMAL_ES_SPECIFIC_FORMAT_T es;
-   uint8_t  extradata[MMAL_FORMAT_EXTRADATA_MAX_SIZE];
-} mmal_worker_port_info_set;
-vcos_static_assert(sizeof(mmal_worker_port_info_set) <= MMAL_WORKER_MAX_MSG_LEN);
-
-/** Report port info back in response to a get / set. */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_STATUS_T status;               /**< Result of query */
-   uint32_t component_handle;          /**< Which component */
-   MMAL_PORT_TYPE_T port_type;         /**< Type of port */
-   uint32_t index;                     /**< Which port of given type to get */
-   int32_t found;                      /**< Did we find anything? */
-   uint32_t port_handle;               /**< Handle to use for this port */
-   MMAL_PORT_T port;
-   MMAL_ES_FORMAT_T format;
-   MMAL_ES_SPECIFIC_FORMAT_T es;
-   uint8_t  extradata[MMAL_FORMAT_EXTRADATA_MAX_SIZE];
-} mmal_worker_port_info;
-vcos_static_assert(sizeof(mmal_worker_port_info) <= MMAL_WORKER_MAX_MSG_LEN);
-
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_STATUS_T status;
-} mmal_worker_reply;
-
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_STATUS_T status;
-   uint8_t secret[32];
-} mmal_worker_drm_get_lhs32_reply;
-vcos_static_assert(sizeof(mmal_worker_drm_get_lhs32_reply) <= MMAL_WORKER_MAX_MSG_LEN);
-
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_STATUS_T status;
-   uint32_t time;
-} mmal_worker_drm_get_time_reply;
-vcos_static_assert(sizeof(mmal_worker_drm_get_time_reply) <= MMAL_WORKER_MAX_MSG_LEN);
-
-/** List of actions for a port */
-enum MMAL_WORKER_PORT_ACTIONS
-{
-   MMAL_WORKER_PORT_ACTION_UNKNOWN = 0,        /**< Unkown action */
-   MMAL_WORKER_PORT_ACTION_ENABLE,             /**< Enable a port */
-   MMAL_WORKER_PORT_ACTION_DISABLE,            /**< Disable a port */
-   MMAL_WORKER_PORT_ACTION_FLUSH,              /**< Flush a port */
-   MMAL_WORKER_PORT_ACTION_CONNECT,            /**< Connect 2 ports together */
-   MMAL_WORKER_PORT_ACTION_DISCONNECT,         /**< Disconnect 2 ports connected together */
-   MMAL_WORKER_PORT_ACTION_SET_REQUIREMENTS,   /**< Set buffer requirements  */
-   MMAL_WORKER_PORT_ACTION_MAX = 0x7fffffff    /**< Make the enum 32bits */
-};
-
-/** Trigger an action on a port.
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t component_handle;
-   uint32_t port_handle;
-   enum MMAL_WORKER_PORT_ACTIONS action;
-
-   /** Action parameter */
-   union {
-      struct {
-         MMAL_PORT_T port;
-      } enable;
-      struct {
-         uint32_t component_handle;
-         uint32_t port_handle;
-      } connect;
-   } param;
-
-} mmal_worker_port_action;
-vcos_static_assert(sizeof(mmal_worker_port_action) <= MMAL_WORKER_MAX_MSG_LEN);
-
-#define MMAL_WORKER_PORT_PARAMETER_SPACE      96
-
-#define MMAL_WORKER_PORT_PARAMETER_SET_MAX \
-   (MMAL_WORKER_PORT_PARAMETER_SPACE*sizeof(uint32_t)+sizeof(MMAL_PARAMETER_HEADER_T))
-
-#define MMAL_WORKER_PORT_PARAMETER_GET_MAX   MMAL_WORKER_PORT_PARAMETER_SET_MAX
-
-/** Component port parameter set. Doesn't include space for the parameter data.
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t component_handle;          /**< Which component */
-   uint32_t port_handle;               /**< Which port */
-   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
-   uint32_t space[MMAL_WORKER_PORT_PARAMETER_SPACE];
-} mmal_worker_port_param_set;
-vcos_static_assert(sizeof(mmal_worker_port_param_set) <= MMAL_WORKER_MAX_MSG_LEN);
-
-/** Component port parameter get.
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t component_handle;          /**< Which component */
-   uint32_t port_handle;               /**< Which port */
-   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size (no data) */
-} mmal_worker_port_param_get;
-vcos_static_assert(sizeof(mmal_worker_port_param_get) <= MMAL_WORKER_MAX_MSG_LEN);
-
-/** Component port parameter get reply. Doesn't include space for the parameter data.
-  */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_STATUS_T status;               /**< Status of mmal_port_parameter_get call */
-   MMAL_PARAMETER_HEADER_T param;      /**< Parameter ID and size */
-   uint32_t space[MMAL_WORKER_PORT_PARAMETER_SPACE];
-} mmal_worker_port_param_get_reply;
-vcos_static_assert(sizeof(mmal_worker_port_param_get_reply) <= MMAL_WORKER_MAX_MSG_LEN);
-
-/** Buffer header driver area structure. In the private area
-  * of a buffer header there is a driver area where we can
-  * put values. This structure defines the layout of that.
-  */
-struct MMAL_DRIVER_BUFFER_T
-{
-   uint32_t magic;
-   uint32_t component_handle;    /**< The component this buffer is from */
-   uint32_t port_handle;         /**< Index into array of ports for this component */
-
-   /** Client side uses this to get back to its context structure. */
-   struct MMAL_VC_CLIENT_BUFFER_CONTEXT_T *client_context;
-};
-
-/** Receive a buffer from the host.
-  *
-  * @sa mmal_port_send_buffer()
-  */
-
-typedef struct mmal_worker_buffer_from_host
-{
-   mmal_worker_msg_header header;
-
-   /** Our control data, copied from the buffer header "driver area"
-    * @sa mmal_buffer_header_driver_data().
-    */
-   struct MMAL_DRIVER_BUFFER_T drvbuf;
-
-   /** Referenced buffer control data.
-    * This is set if the buffer is referencing another
-    * buffer as is the case with passthrough ports where
-    * buffers on the output port reference buffers on the
-    * input port. */
-   struct MMAL_DRIVER_BUFFER_T drvbuf_ref;
-
-   /** the buffer header itself */
-   MMAL_BUFFER_HEADER_T buffer_header;
-   MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T buffer_header_type_specific;
-
-   MMAL_BOOL_T is_zero_copy;
-   MMAL_BOOL_T has_reference;
-
-   /** If the data is short enough, then send it in the control message rather
-    * than using a separate VCHIQ bulk transfer.
-    */
-   uint32_t payload_in_message;
-   uint8_t short_data[MMAL_VC_SHORT_DATA];
-
-} mmal_worker_buffer_from_host;
-vcos_static_assert(sizeof(mmal_worker_buffer_from_host) <= MMAL_WORKER_MAX_MSG_LEN);
-
-/** Maximum number of event data bytes that can be passed in the message.
- * More than this and the data is passed in a bulk message.
- */
-#define MMAL_WORKER_EVENT_SPACE 256
-
-/** Send an event buffer from the host.
-  *
-  * @sa mmal_port_send_event()
-  */
-
-typedef struct mmal_worker_event_to_host
-{
-   mmal_worker_msg_header header;
-
-   struct MMAL_COMPONENT_T *client_component;
-   uint32_t port_type;
-   uint32_t port_num;
-
-   uint32_t cmd;
-   uint32_t length;
-   uint8_t data[MMAL_WORKER_EVENT_SPACE];
-   MMAL_BUFFER_HEADER_T *delayed_buffer;  /* Only used to remember buffer for bulk rx */
-} mmal_worker_event_to_host;
-vcos_static_assert(sizeof(mmal_worker_event_to_host) <= MMAL_WORKER_MAX_MSG_LEN);
-
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_VC_STATS_T stats;
-   uint32_t reset;
-} mmal_worker_stats;
-vcos_static_assert(sizeof(mmal_worker_stats) <= MMAL_WORKER_MAX_MSG_LEN);
-
-typedef enum {
-   MMAL_WORKER_OPAQUE_MEM_ALLOC,
-   MMAL_WORKER_OPAQUE_MEM_RELEASE,
-   MMAL_WORKER_OPAQUE_MEM_ACQUIRE,
-   MMAL_WORKER_OPAQUE_MEM_MAX = 0x7fffffff,
-} MMAL_WORKER_OPAQUE_MEM_OP;
-
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_WORKER_OPAQUE_MEM_OP op;
-   uint32_t handle;
-   MMAL_STATUS_T status;
-   char description[32];
-} mmal_worker_opaque_allocator;
-
-/*
- * Per-port core statistics
- */
-typedef struct
-{
-   mmal_worker_msg_header header;
-   uint32_t component_index;
-   uint32_t port_index;
-   MMAL_PORT_TYPE_T type;
-   MMAL_CORE_STATS_DIR dir;
-   MMAL_BOOL_T reset;
-} mmal_worker_get_core_stats_for_port;
-
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_STATUS_T status;
-   MMAL_STATS_RESULT_T result;
-   MMAL_CORE_STATISTICS_T stats;
-   char component_name[MMAL_VC_CORE_STATS_NAME_MAX];
-} mmal_worker_get_core_stats_for_port_reply;
-
-typedef struct
-{
-   mmal_worker_msg_header header;
-   MMAL_STATUS_T status;
-   /* The amount of memory to reserve */
-   uint32_t size;
-   /* Handle to newly allocated memory or MEM_HANDLE_INVALD on failure */
-   uint32_t handle;
-} mmal_worker_consume_mem;
-vcos_static_assert(sizeof(mmal_worker_consume_mem) <= MMAL_WORKER_MAX_MSG_LEN);
-
-typedef struct
-{
-   mmal_worker_msg_header header;
-   /* Message text to add to the circular buffer */
-   char msg[MMAL_WORKER_MAX_MSG_LEN - sizeof(mmal_worker_msg_header)];
-} mmal_worker_host_log;
-vcos_static_assert(sizeof(mmal_worker_host_log) <= MMAL_WORKER_MAX_MSG_LEN);
-
-typedef struct
-{
-   mmal_worker_msg_header header;
-   /* The memory allocation size to pass to lmk, as if in a response to an
-    * allocation for this amount of memory. */
-   uint32_t alloc_size;
-} mmal_worker_lmk;
-vcos_static_assert(sizeof(mmal_worker_lmk) <= MMAL_WORKER_MAX_MSG_LEN);
-
-static inline void mmal_vc_buffer_header_to_msg(mmal_worker_buffer_from_host *msg,
-                                                MMAL_BUFFER_HEADER_T *header)
-{
-   msg->buffer_header.cmd           = header->cmd;
-   msg->buffer_header.offset        = header->offset;
-   msg->buffer_header.length        = header->length;
-   msg->buffer_header.flags         = header->flags;
-   msg->buffer_header.pts           = header->pts;
-   msg->buffer_header.dts           = header->dts;
-   msg->buffer_header.alloc_size    = header->alloc_size;
-   msg->buffer_header.data          = header->data;
-   msg->buffer_header_type_specific = *header->type;
-}
-
-static inline void mmal_vc_msg_to_buffer_header(MMAL_BUFFER_HEADER_T *header,
-                                                mmal_worker_buffer_from_host *msg)
-{
-   header->cmd    = msg->buffer_header.cmd;
-   header->offset = msg->buffer_header.offset;
-   header->length = msg->buffer_header.length;
-   header->flags  = msg->buffer_header.flags;
-   header->pts    = msg->buffer_header.pts;
-   header->dts    = msg->buffer_header.dts;
-   *header->type  = msg->buffer_header_type_specific;
-}
-
-#endif
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_opaque_alloc.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_opaque_alloc.c
deleted file mode 100644
index b5b5ba9..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_opaque_alloc.c
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include "interface/mmal/vc/mmal_vc_opaque_alloc.h"
-#include "mmal_vc_msgs.h"
-#include "mmal_vc_client_priv.h"
-
-MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc_desc(const char *description)
-{
-   MMAL_STATUS_T ret;
-   MMAL_OPAQUE_IMAGE_HANDLE_T h = 0;
-   mmal_worker_opaque_allocator msg;
-   size_t len = sizeof(msg);
-   msg.op = MMAL_WORKER_OPAQUE_MEM_ALLOC;
-   vcos_safe_strcpy(msg.description, description, sizeof(msg.description), 0);
-   ret = mmal_vc_sendwait_message(mmal_vc_get_client(),
-                                  &msg.header, sizeof(msg),
-                                  MMAL_WORKER_OPAQUE_ALLOCATOR_DESC,
-                                  &msg, &len, MMAL_FALSE);
-   if (ret == MMAL_SUCCESS)
-   {
-      h = msg.handle;
-   }
-   return h;
-}
-
-MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc(void)
-{
-   return mmal_vc_opaque_alloc_desc("?");
-}
-
-MMAL_STATUS_T mmal_vc_opaque_acquire(unsigned int handle)
-{
-   MMAL_STATUS_T ret;
-   mmal_worker_opaque_allocator msg;
-   size_t len = sizeof(msg);
-   msg.handle = handle;
-   msg.op = MMAL_WORKER_OPAQUE_MEM_ACQUIRE;
-   ret = mmal_vc_sendwait_message(mmal_vc_get_client(),
-                                  &msg.header, sizeof(msg),
-                                  MMAL_WORKER_OPAQUE_ALLOCATOR,
-                                  &msg, &len, MMAL_FALSE);
-   if (ret == MMAL_SUCCESS)
-      ret = msg.status;
-   return ret;
-}
-
-MMAL_STATUS_T mmal_vc_opaque_release(unsigned int handle)
-{
-   MMAL_STATUS_T ret;
-   mmal_worker_opaque_allocator msg;
-   size_t len = sizeof(msg);
-   msg.handle = handle;
-   msg.op = MMAL_WORKER_OPAQUE_MEM_RELEASE;
-   ret = mmal_vc_sendwait_message(mmal_vc_get_client(),
-                                  &msg.header, sizeof(msg),
-                                  MMAL_WORKER_OPAQUE_ALLOCATOR,
-                                  &msg, &len, MMAL_FALSE);
-   if (ret == MMAL_SUCCESS)
-      ret = msg.status;
-   return ret;
-}
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_opaque_alloc.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_opaque_alloc.h
deleted file mode 100644
index 60a5e56..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_opaque_alloc.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef MMAL_VC_OPAQUE_ALLOC_H
-#define MMAL_VC_OPAQUE_ALLOC_H
-
-
-#include <stdint.h>
-#include "interface/mmal/mmal.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef uint32_t MMAL_OPAQUE_IMAGE_HANDLE_T;
-
-/** Allocate an opaque image on VideoCore.
- *
- * @return allocated handle, or zero if allocation failed.
- */
-MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc(void);
-
-/** Allocate an opaque image on VideoCore, providing a description.
- * @return allocated handle, or zero if allocation failed.
- */
-MMAL_OPAQUE_IMAGE_HANDLE_T mmal_vc_opaque_alloc_desc(const char *description);
-
-/** Release an opaque image.
- *
- * @param handle  handle allocated earlier
- * @return MMAL_SUCCESS or error code if handle not found
- */
-MMAL_STATUS_T mmal_vc_opaque_release(MMAL_OPAQUE_IMAGE_HANDLE_T h);
-
-/** Acquire an additional reference to an opaque image.
- *
- * @param handle  handle allocated earlier
- * @return MMAL_SUCCESS or error code if handle not found
- */
-MMAL_STATUS_T mmal_vc_opaque_acquire(MMAL_OPAQUE_IMAGE_HANDLE_T h);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif
-
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.c b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.c
deleted file mode 100644
index 19222ca..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.c
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#include "interface/mmal/mmal_logging.h"
-#include "interface/mmal/mmal.h"
-#include "interface/vcos/vcos.h"
-
-#include "interface/mmal/vc/mmal_vc_shm.h"
-
-#ifdef ENABLE_MMAL_VCSM
-# include "user-vcsm.h"
-#endif /* ENABLE_MMAL_VCSM */
-
-#define MMAL_VC_PAYLOAD_ELEM_MAX 512
-
-typedef struct MMAL_VC_PAYLOAD_ELEM_T
-{
-   struct MMAL_VC_PAYLOAD_ELEM_T *next;
-   void *handle;
-   void *vc_handle;
-   uint8_t *mem;
-   MMAL_BOOL_T in_use;
-} MMAL_VC_PAYLOAD_ELEM_T;
-
-typedef struct MMAL_VC_PAYLOAD_LIST_T
-{
-   MMAL_VC_PAYLOAD_ELEM_T list[MMAL_VC_PAYLOAD_ELEM_MAX];
-   VCOS_MUTEX_T lock;
-} MMAL_VC_PAYLOAD_LIST_T;
-
-static MMAL_VC_PAYLOAD_LIST_T mmal_vc_payload_list;
-
-static void mmal_vc_payload_list_init()
-{
-   vcos_mutex_create(&mmal_vc_payload_list.lock, "mmal_vc_payload_list");
-}
-
-static MMAL_VC_PAYLOAD_ELEM_T *mmal_vc_payload_list_get()
-{
-   MMAL_VC_PAYLOAD_ELEM_T *elem = 0;
-   unsigned int i;
-
-   vcos_mutex_lock(&mmal_vc_payload_list.lock);
-   for (i = 0; i < MMAL_VC_PAYLOAD_ELEM_MAX; i++)
-   {
-      if (mmal_vc_payload_list.list[i].in_use)
-         continue;
-      elem = &mmal_vc_payload_list.list[i];
-      elem->in_use = 1;
-      break;
-   }
-   vcos_mutex_unlock(&mmal_vc_payload_list.lock);
-
-   return elem;
-}
-
-static void mmal_vc_payload_list_release(MMAL_VC_PAYLOAD_ELEM_T *elem)
-{
-   vcos_mutex_lock(&mmal_vc_payload_list.lock);
-   elem->handle = elem->vc_handle = 0;
-   elem->mem = 0;
-   elem->in_use = 0;
-   vcos_mutex_unlock(&mmal_vc_payload_list.lock);
-}
-
-static MMAL_VC_PAYLOAD_ELEM_T *mmal_vc_payload_list_find_mem(uint8_t *mem)
-{
-   MMAL_VC_PAYLOAD_ELEM_T *elem = 0;
-   unsigned int i;
-
-   vcos_mutex_lock(&mmal_vc_payload_list.lock);
-   for (i = 0; i < MMAL_VC_PAYLOAD_ELEM_MAX; i++)
-   {
-      if (!mmal_vc_payload_list.list[i].in_use)
-         continue;
-      if (mmal_vc_payload_list.list[i].mem != mem)
-         continue;
-      elem = &mmal_vc_payload_list.list[i];
-      break;
-   }
-   vcos_mutex_unlock(&mmal_vc_payload_list.lock);
-
-   return elem;
-}
-
-static MMAL_VC_PAYLOAD_ELEM_T *mmal_vc_payload_list_find_handle(uint8_t *mem)
-{
-   MMAL_VC_PAYLOAD_ELEM_T *elem = 0;
-   unsigned int i;
-
-   vcos_mutex_lock(&mmal_vc_payload_list.lock);
-   for (i = 0; i < MMAL_VC_PAYLOAD_ELEM_MAX; i++)
-   {
-      if (!mmal_vc_payload_list.list[i].in_use)
-         continue;
-      if (mmal_vc_payload_list.list[i].vc_handle != (void *)mem)
-         continue;
-      elem = &mmal_vc_payload_list.list[i];
-      break;
-   }
-   vcos_mutex_unlock(&mmal_vc_payload_list.lock);
-
-   return elem;
-}
-
-/** Initialise the shared memory system */
-MMAL_STATUS_T mmal_vc_shm_init(void)
-{
-#ifdef ENABLE_MMAL_VCSM
-   if (vcsm_init() != 0)
-   {
-      LOG_ERROR("could not initialize vc shared memory service");
-      return MMAL_EIO;
-   }
-#endif /* ENABLE_MMAL_VCSM */
-
-   mmal_vc_payload_list_init();
-   return MMAL_SUCCESS;
-}
-
-/** Allocate a shared memory buffer */
-uint8_t *mmal_vc_shm_alloc(uint32_t size)
-{
-   uint8_t *mem = NULL;
-
-   MMAL_VC_PAYLOAD_ELEM_T *payload_elem = mmal_vc_payload_list_get();
-   if (!payload_elem)
-   {
-      LOG_ERROR("could not get a free slot in the payload list");
-      return NULL;
-   }
-
-#ifdef ENABLE_MMAL_VCSM
-   unsigned int vcsm_handle = vcsm_malloc_cache(size, VCSM_CACHE_TYPE_HOST, "mmal_vc_port buffer");
-   unsigned int vc_handle = vcsm_vc_hdl_from_hdl(vcsm_handle);
-   mem = (uint8_t *)vcsm_lock( vcsm_handle );
-   if (!mem || !vc_handle)
-   {
-      LOG_ERROR("could not allocate %i bytes of shared memory (handle %x)",
-                (int)size, vcsm_handle);
-      if (mem)
-         vcsm_unlock_hdl(vcsm_handle);
-      if (vcsm_handle)
-         vcsm_free(vcsm_handle);
-      mmal_vc_payload_list_release(payload_elem);
-      return NULL;
-   }
-
-   /* The memory area is automatically mem-locked by vcsm's fault
-    * handler when it is next used. So leave it unlocked until it
-    * is needed.
-    */
-   vcsm_unlock_hdl(vcsm_handle);
-
-   payload_elem->mem = mem;
-   payload_elem->handle = (void *)vcsm_handle;
-   payload_elem->vc_handle = (void *)vc_handle;
-#else /* ENABLE_MMAL_VCSM */
-   MMAL_PARAM_UNUSED(size);
-   mmal_vc_payload_list_release(payload_elem);
-#endif /* ENABLE_MMAL_VCSM */
-
-   return mem;
-}
-
-/** Free a shared memory buffer */
-MMAL_STATUS_T mmal_vc_shm_free(uint8_t *mem)
-{
-   MMAL_VC_PAYLOAD_ELEM_T *payload_elem = mmal_vc_payload_list_find_mem(mem);
-   if (payload_elem)
-   {
-#ifdef ENABLE_MMAL_VCSM
-      vcsm_free((unsigned int)payload_elem->handle);
-#endif /* ENABLE_MMAL_VCSM */
-      mmal_vc_payload_list_release(payload_elem);
-      return MMAL_SUCCESS;
-   }
-
-   return MMAL_EINVAL;
-}
-
-/** Lock a shared memory buffer */
-uint8_t *mmal_vc_shm_lock(uint8_t *mem, uint32_t workaround)
-{
-   /* Zero copy stuff */
-   MMAL_VC_PAYLOAD_ELEM_T *elem = mmal_vc_payload_list_find_handle(mem);
-   MMAL_PARAM_UNUSED(workaround);
-
-   if (elem)
-      mem = elem->mem;
-
-   return mem;
-}
-
-/** Unlock a shared memory buffer */
-uint8_t *mmal_vc_shm_unlock(uint8_t *mem, uint32_t *length, uint32_t workaround)
-{
-   /* Zero copy stuff */
-   MMAL_VC_PAYLOAD_ELEM_T *elem = mmal_vc_payload_list_find_mem(mem);
-   MMAL_PARAM_UNUSED(workaround);
-
-   if (elem)
-   {
-      *length = 0;
-      mem = (uint8_t *)elem->vc_handle;
-#ifdef ENABLE_MMAL_VCSM
-      vcsm_unlock_ptr(elem->mem);
-#endif /* ENABLE_MMAL_VCSM */
-   }
-
-   return mem;
-}
diff --git a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.h b/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.h
deleted file mode 100644
index 0aacb5b..0000000
--- a/mjpg-streamer-experimental/plugins/input_raspicam/mmal/vc/mmal_vc_shm.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-#ifndef MMAL_VC_SHM_H
-#define MMAL_VC_SHM_H
-
-/** @file
-  *
-  * Abstraction layer for MMAL VC shared memory.
-  * This API is only used by the MMAL VC component.
-  */
-
-#include "mmal_types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Initialise the shared memory system */
-MMAL_STATUS_T mmal_vc_shm_init(void);
-
-/** Allocate a shared memory buffer */
-uint8_t *mmal_vc_shm_alloc(uint32_t size);
-
-/** Free a shared memory buffer */
-MMAL_STATUS_T mmal_vc_shm_free(uint8_t *mem);
-
-/** Lock a shared memory buffer */
-uint8_t *mmal_vc_shm_lock(uint8_t *mem, uint32_t workaround);
-
-/** Unlock a shared memory buffer */
-uint8_t *mmal_vc_shm_unlock(uint8_t *mem, uint32_t *length, uint32_t workaround);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MMAL_VC_SHM_H */
